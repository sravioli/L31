{"config":{"lang":["it","en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Raccolta di appunti, file, slides, etc. relativi al corso di Informatica L31, dell'Universit\u00e0 di Bari \"Aldo Moro\".</p> <p>Attenzione</p> <p>Gli appunti sono in fase di stesura e cambiano continuamente.</p>"},{"location":"#utilizzo-offline","title":"Utilizzo offline","text":"<p>Per poter sfogliare gli appunti offline bisogna innanzitutto clonare la repository dopodich\u00e9, utilizzando Mask1:</p> <pre><code>mask bootstrap &amp;&amp; mask build\n</code></pre> <p>Il sito sar\u00e0 presente nella cartella <code>./site/</code> e lo si pu\u00f2 sfogliare con un qualsiasi web browser aprendo il file <code>index.md</code>. La pagina visualizzata dovrebbe essere proprio questa.</p>"},{"location":"#come-contribuire","title":"Come contribuire","text":"<p>Per contribuire:</p> <ol> <li> <p>clonare la repository:</p>  Git GitHub CLI <pre><code>git clone https://github.com/sRavioli/L31.git\n</code></pre> <pre><code>gh repo clone sRavioli/L31\n</code></pre> </li> <li> <p>recarsi nella cartella (<code>cd L31</code>) e installare i pacchetti python    richiesti (richiesti: pyton e mask):</p> <pre><code>mask bootstrap\n</code></pre> </li> <li> <p>avviare il server:</p> <pre><code>mask serve --dirty\n</code></pre> <p>Verr\u00e0 fatto partire un server al link http://localhost:8000/L31 che ospiter\u00e0 gli appunti. L'opzione <code>--dirty</code> permette di avere dei tempi di caricamento pi\u00f9 brevi poich\u00e9 mkdocs compiler\u00e0 solo la pagina corrente. Per interrompere il server bisogna premere Ctrl+C.</p> </li> <li> <p>effettuare le modifiche;</p> </li> <li> <p>creare un nuovo ramo con  Git:</p> <pre><code>git checkout -b feat/nuova-feature\n</code></pre> <p>effettuare gli eventuali commit sullo stesso</p> <pre><code>git commit -m \"feat: add new feature\"\n</code></pre> <p>effettuare il push del nuovo ramo:</p> <pre><code>git push -u origin feat/nuova-feature\n</code></pre> </li> <li> <p>recarsi su  GitHub e aprire una pull request.</p> </li> </ol> <p>\ufeff</p> <ol> <li> <p>Nel caso in cui non sia possibile usare mask, \u00e8 possibile eseguire manualmente i due script. Bisogna aprire il file <code>maskfile.md</code>, e recarsi nelle sezioni <code>## bootstrap</code> e <code>## build</code> e eseguire i comandi l\u00ec presenti, esclusi i messaggi (<code>mask msk ... \"...\"</code>).\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/","title":"Appunti del primo anno","text":"<p>In questa sezione sono presenti gli appunti dei seguenti corsi:</p> <ul> <li>Programmazione</li> </ul> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/","title":"Appunti del corso di Programmazione","text":"<p>Corso tenuto da Fabio Abbattista (fabbattista@gmail.com).</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/","title":"Introduzione ai calcolatori","text":""},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistemi-di-elaborazione-dellinformazione","title":"Sistemi di elaborazione dell'informazione","text":"<p>Gli elementi principali di un sistema di calcolo si suddividono in 2 categorie:</p> Hardware La parte fisica dell'elaboratore che \u00e8 costituita da componenti elettronici e   elettromagnetici Software Tutti i programmi che consentono all'Hardware di realizzare specifici compiti <p>Senza Hardware il Software \u00e8 inutile e viceversa. Questi si completano.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#software","title":"Software","text":"<p>I Software sono di due tipi</p> Software di base Funzionale all'utilizzo dell'elaboratore e di tutte le sue periferiche, questo   comprende sia il sistema operativo, che i programmi che traducono i linguaggi   di programmazione. Software applicativo Mostra all'utente il calcolatore come una macchina virtuale che \u00e8 possibile   utilizzare per la risoluzione di problemi specifici. <p>Il Software applicativo comprende tutte le applicazioni che l'utente utilizza come giochi, fogli elettronici, editor di testo, etc.</p> <p>\u00c8 necessario saper utilizzare correttamente il sistema operativo poich\u00e9 saper impostare la macchina al meglio \u00e8 fondamentale.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#architettura-di-un-calcolatore","title":"Architettura di un calcolatore","text":"<p>I componenti fondamentali dell'architettura dei calcolatori sono:</p> <ul> <li>Unit\u00e0 centrale di elaborazione (CPU) che preleva le istruzioni dalla memoria   e le esegue, dunque legge e/o scrive dati dalla memoria;</li> <li>Memoria principale (RAM, ROM) che contiene i dati e le istruzioni dei   programmi;</li> <li>Memoria secondaria o di massa (HD, CD, DVD, ecc.) per memorizzare dati e   programmi in maniera permanente;</li> <li>Dispositivi di input (tastiera, mouse, touch pad, ecc.) per l\u2019inserimento dei   dati;</li> <li>Dispositivi di output (monitor, stampante, ecc.) per ricevere i risultati.</li> </ul> <p>Ogni calcolatore \u00e8 progettato secondo l'architettura di Von Neumann</p> <pre><code>flowchart LR\n  mem[Memory] &lt;--&gt; CPU;\n  in[Input] --&gt; CPU;\n  CPU --&gt; out[Output];\n\n  subgraph CPU\n    %% alu co; --&gt;\n    co[Control Unit ] &lt;--&gt; alu[ALU ];\n  end</code></pre> <p>Dove ALU sta per Unit\u00e0 Logica Aritmetica.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria","title":"Memoria","text":"<p>Vi sono due tipi di memoria: memoria principale, chiamata RAM (Random Access Memory) e la memoria ROM (Read Only Memory).</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria-principale-ram","title":"Memoria Principale (RAM)","text":"<p>La memoria principale contiene i dati e le istruzioni che il processore deve elaborare. Se lo spazio della RAM \u00e8 esaurito, il programma verr\u00e0 eseguito molto lentamente oppure non verr\u00e0 eseguito. L'elemento base della memoria principale \u00e8 la cella di memoria, la quale ha delle caratteristiche specifiche:</p> <ul> <li>Pu\u00f2 assumere solo due stati: \\(0\\) oppure \\(1\\);</li> <li>\u00c8 possibile scrivere nella cella per cambiarne lo stato;</li> <li>\u00c8 possibile leggere lo stato della cella.</li> </ul> <p>La cella di memoria da sola non \u00e8 molto utile ed \u00e8 per questo motivo che vengono organizzate in locazioni di memoria da \\(8\\), \\(16\\) o anche pi\u00f9 celle. Lavorando con questi dati si ha a che fare con \\(8\\), \\(16\\), etc. byte. La singola cella viene chiamata bit, dunque una cella equivale a \\(1\\) bit. Ogni locazione di memoria \u00e8 individuata da un indirizzo univoco che permette di specificarne la posizione. Lavorando con le locazioni di memoria si lavora indirettamente anche con questo indirizzo.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria-rom","title":"Memoria ROM","text":"<p>La ROM \u00e8 una memoria a sola lettura e contiene delle informazioni permanenti e non modificabili. Spesso utilizzata per memorizzare istruzioni di sistema, ad esempio le istruzioni necessarie per avviare il sistema operativo e per il riconoscimento delle periferiche.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria-di-massa","title":"Memoria di Massa","text":"<p>Detta anche memoria secondaria, viene utilizzata per memorizzare grandi volumi di dati in modo persistente.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#codici-di-caratteri","title":"Codici di caratteri","text":"<p>Un codice di caratteri \u00e8 un codice alfabetico, ovvero un insieme di caratteri e pu\u00f2 comprendere caratteri alfabetici (minuscoli e maiuscoli), caratteri numerici, segni di punteggiatura, altri simboli stampabili e caratteri di controllo.</p> <p>I due principali codici di caratteri sono ASCII e UNICODE.</p> <p>Questi codici di caratteri servono alla macchina per capire come interpretare le stringhe di \\(0\\) e \\(1\\) in caratteri.</p> <p>Con il codice ASCII si hanno a disposizione \\(256\\) simboli distinti</p> <p>!!!fig.!!!</p> <p>I primi \\(32\\) simboli sono caratteri di controllo e hanno codici che vanno da \\(0\\) a \\(31\\), sempre sotto forma di \\(0\\) e \\(1\\). I simboli sono \\(256\\) poich\u00e9 con \\(8\\) bit \u00e8 possibile rappresentare da \\(0\\) a \\(255\\) combinazioni differenti. Inizialmente il codice ASCII utilizzava \\(7\\) bit, in seguito l'ASCII esteso porta il numero di bit a \\(8\\).</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistemi-di-numerazione","title":"Sistemi di numerazione","text":"<p>\u00c8 un insieme di simboli (cifre) e regole che assegnano ad ogni sequenza di cifre uno e un solo valore numerico. Questo pu\u00f2 essere:</p> <ul> <li>non posizionale, come ad esempio il sistema di numerazione degli antichi romani;</li> <li>posizionale, come ad esempio il sistema di numerazione decimale.</li> </ul>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistema-di-numerazione-posizionale","title":"Sistema di numerazione posizionale","text":"<p>Il sistema di numerazione posizionale \u00e8 un sistema di numerazione in cui ogni cifra ha un valore diverso a seconda della sua posizione. Il sistema di numerazione decimale \u00e8 un sistema di numerazione posizionale. Dato un numero \\(b &gt; 1\\) detto base e un insieme di \\(n\\) cifre \\(I = \\{0, 1, 2, \\dots, n-1\\}\\), una stringa di \\(n\\) simboli \\(x_{n-1}, x_{n-2}, \\cdots, x_1, x_0\\) si interpreta come:</p> \\[     x_{n-1} \\cdot b^{n-1} + x_{n-2} \\cdot b^{n-2}                           + \\cdots + x_1 \\cdot b^1                           +  x_0 \\cdot b^0 \\]"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistema-di-numerazione-decimale","title":"Sistema di numerazione decimale","text":"<p>Nel sistema di numerazione decimale la base \u00e8 \\(10\\) e le cifre sono \\(0,\\ 1, \\dots, 9\\). Ad esempio la stringa \\(2014\\) rappresenta il numero</p> \\[ 2 \\cdot 10^3 + 0 \\cdot 10^2 + 1 \\cdot 10^1 + 4 \\cdot 10^0 \\]"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistema-di-numerazione-binario","title":"Sistema di numerazione binario","text":"<p>Nel sistema di numerazione binario la base \u00e8 \\(2\\) e le cifre sono \\(0, 1\\). Ad esempio la stringa \\(11110\\) rappresenta il numero</p> \\[ 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0 \\] <p>che equivale a \\(30\\) nel sistema decimale.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#conversione-da-decimale-a-binario","title":"Conversione da decimale a binario","text":"<p>La conversione di un numero da base \\(10\\) a base \\(2\\) \u00e8 un processo iterativo che consiste nel dividere il numero per \\(2\\) e prendere il resto della divisione. Il risultato della divisione viene utilizzato come nuovo numero da dividere per \\(2\\) e cos\u00ec via fino a quando il risultato della divisione non \u00e8 \\(0\\). I resti delle divisioni vengono riportati in ordine inverso.</p> <p>Esempio</p> <p>Convertiamo:</p> Numero \\(7\\)Numero \\(14\\) Text Only<pre><code>7/2 = 3, resto 1\n3/2 = 1, resto 1\n1/2 = 0, resto 1\n</code></pre> <p>Il numero \\(7\\) in binario \u00e8 \\(111\\)</p> Text Only<pre><code>14/2 = 7 resto 0\n7/2 = 3 resto 1\n3/2 = 1 resto 1\n1/2 = 0 resto 1\n</code></pre> <p>Il numero \\(14\\) in binario \u00e8 \\(1110\\).</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/","title":"Problem Solving","text":""},{"location":"Anno_I/Programmazione/01_problem_solving/#il-metodo-di-sviluppo-del-software","title":"Il metodo di sviluppo del Software","text":"<p>Per sviluppare Software \u00e8 necessario seguire i seguenti passaggi:</p> <ol> <li>Specificare i requisiti del problema;</li> <li>Analizzare il problema;</li> <li>Progettare la sequenza di istruzioni per risolvere il problema;</li> <li>Realizzare la sequenza di azioni;</li> <li>Fare il test e la verifica del programma;</li> <li>Fare la manutenzione e l'aggiornamento del programma.</li> </ol> <p>Analizziamo questi passaggi in dettaglio.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#specificare-i-requisiti-del-problema","title":"Specificare i requisiti del problema","text":"<p>\u00c8 necessario specificare il problema in maniera non ambigua eliminando tutti gli aspetti non importanti e specificando tutti quelli che sono necessari per risolvere il problema.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#analizzare-il-problema","title":"Analizzare il problema","text":"<p>L'analisi del problema \u00e8 una fase fondamentale per risolvere il problema. In questa fase si devono identificare i dati da elaborare (input), i risultati desiderati (output), gli eventuali vincoli tra i dati e, infine, il formato di presentazione dei risultati.</p> <p>In questo modo si individuano i dati utili e quelli inutili, si individuano i vincoli tra i dati e si individuano i dati che possono essere calcolati a partire da altri dati.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#progettare-la-sequenza-di-istruzioni-per-risolvere-il-problema","title":"Progettare la sequenza di istruzioni per risolvere il problema","text":"<p>Una volta individuati i dati utili e quelli inutili, i vincoli tra i dati e i dati che possono essere calcolati a partire da altri dati, si pu\u00f2 procedere al progetto della sequenza di istruzioni per risolvere il problema.</p> <p>Per fare ci\u00f2 \u00e8 necessario individuare la sequenza di azioni da eseguire per risolvere il problema, ovvero l'algoritmo. \u00c8 inoltre necessario verificare manualmente che l'algoritmo sia corretto.</p> <p>Nello scrivere l'algoritmo \u00e8 preferibile procedere in maniera Top-Down, individuando inizialmente i passi principali e poi risolvere ognuno di questi separatamente.</p> <p>\u00c8 importante non utilizzare termini ambigui e non utilizzare termini tecnici che non siano stati definiti, come ad esempio sintassi di altri linguaggi di programmazione.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#realizzare-la-sequenza-di-azioni","title":"Realizzare la sequenza di azioni","text":"<p>Una volta individuato l'algoritmo, si pu\u00f2 procedere alla realizzazione del programma. Per fare ci\u00f2 \u00e8 necessario tradurre l'algoritmo in un linguaggio di programmazione.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#fare-il-test-e-la-verifica-del-programma","title":"Fare il test e la verifica del programma","text":"<p>\u00c8 sicuramente l'operazione pi\u00f9 costosa a livello di tempo e risorse. \u00c8 necessario testare il programma in modo da verificare che questo risolva il problema in maniera corretta.</p> <p>Ad esempio, un programma che calcola la somma di due numeri deve essere testato con numeri positivi, negativi, decimali, con numeri molto grandi e con numeri molto piccoli. \u00c8 possibile dire che funzioner\u00e0 con tutti i numeri? \u00c8 impossibile dirlo con certezza poich\u00e9 i numeri sono infiniti; \u00e8 per\u00f2 possibile essere certi che il programma funzioner\u00e0 nel \\(99.9\\%\\) dei casi.</p> <p>Un altro esempio \u00e8 il programma Microsoft PowerPoint. Quest'ultimo presenta innumerevoli funzionalit\u00e0 e questo porta ad avere altrettanti problemi.</p> <p>A volte questa fase pu\u00f2 impiegare mesi per programmi molto complessi e imponenti.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#fare-la-manutenzione-e-laggiornamento-del-programma","title":"Fare la manutenzione e l'aggiornamento del programma","text":"<p>Una volta che il programma \u00e8 stato testato, verificato e rilasciato al pubblico, \u00e8 necessario fare la manutenzione e l'aggiornamento del programma.</p> <p>Ad esempio, tempo fa, i programmi di contabilit\u00e0 codificavano al loro interno il valore dell'IVA. Questo comportava che ogni volta che l'IVA venisse modificata, tutti i programmi di contabilit\u00e0 dovevano essere modificati.</p> <p>L'alternativa sarebbe quella di lasciare che l'utenza inserisca il valore dell'IVA e di utilizzare questo valore per calcolare i prezzi. Se invece si vuole mantenere il pieno controllo del programma, codificarlo \u00e8 l'unico modo.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#metodi-di-descrizione-degli-algoritmi","title":"Metodi di descrizione degli algoritmi","text":"<p>I metodi di descrizione degli algoritmi sono molteplici e sono semplicemente delle convenzioni. Il metodo che utilizzeremo \u00e8 lo pseudo-codice. Sono presenti anche flowchart, etc.</p> <p>Lo -pseudo che utilizzeremo possiede una sintassi ben precisa e, ad esempio, non \u00e8 presente l'istruzione <code>goto</code>. \u00c8 possibile inserire un numero per ogni riga ma non \u00e8 obbligatorio.</p> <p>Come prima cosa bisogna elencare i dati in ingresso e in uscita.</p> <p>Ogni rigo ospita un dato differente con: nome del dato, descrizione dello stesso, tipo di dato1 e vincoli, in questo preciso ordine.</p> <p>Il nome del dato \u00e8 arbitrario, per\u00f2 \u00e8 necessario che sia rappresentativo del dato stesso. \u00c8 possibile utilizzare lettere singole, anche se non \u00e8 consigliabile2.</p> <p>Example</p> <p>Ad esempio, nel convertire un numero da binario a decimale, scriveremo:</p> <p>\u274c numero binario, numero binario</p> <p>\u2714\ufe0f numero binario, numero binario da convertire a decimale</p> <p>In generale, la descrizione del dato deve essere pi\u00f9 dettagliata possibile e pi\u00f9 lunga del nome del dato. Dopo aver scritto la descrizione \u00e8 consigliabile rileggerla circa due volte e cercare di aggiungere informazioni.</p> <p>Per poter scrivere queste informazioni \u00e8 necessario un minimo lavoro di analisi poich\u00e9 non \u00e8 scontato che la traccia del problema fornisca tutte le informazioni necessarie.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#esempio-convertire-da-miglia-a-chilometri","title":"Esempio: convertire da miglia a chilometri","text":"<p>Problema:</p> <p>convertire da miglia a chilometri.</p> <p>Analisi:</p> <p>\u00c8 necessario capire cosa fare: dobbiamo convertire dei valori da un sistema di misura ad un altro, ovvero da miglia a chilometri. Il dato da elaborare \u00e8 quindi una distanza in miglia. Il risultato desiderato \u00e8 la distanza in chilometri.</p> <p>Per poter risolvere il problema \u00e8 necessario conoscere la relazione esistente tra miglia e chilometri: \\(1\\,{\\rm mi} = 1.609\\,{\\rm km}\\).</p> INPUT miglio, la distanza espressa in miglia OUTPUT chilometro, la distanza espressa in chilometri VINCOLI \\(1\\,{\\rm mi} = 1.609\\,{\\rm km}\\) <p>Progettazione:</p> <p>Un algoritmo iniziale potrebbe essere simile al seguente:</p> Algoritmo iniziale<pre><code>Acquisire la distanza in miglia\nConvertire la distanza in chilometri\nVisualizzare la distanza in chilometri\n</code></pre> <p>Il primo e ultimo passo non necessitano di ulteriori raffinamenti, per\u00f2 il secondo passo pu\u00f2 essere migliorato. \u00c8 possibile scrivere: la distanza in chilometri \u00e8 uguale a \\(1.609\\) volte la distanza in miglia.</p> Algoritmo con raffinamenti<pre><code>Acquisire la distanza in miglia\nConvertire la distanza in chilometri\n    La distanza in chilometri \u00e8 uguale a 1.609 volte la distanza in miglia\nVisualizzare la distanza in chilometri\n</code></pre> <p>(Esercizio analisi e progettazione di come cucinare la pasta al forno)</p> <p>\ufeff</p> <ol> <li> <p>Con tipo di dato non si intendono i tipi del C o di altri linguaggi di programmazione, ma semplicemente il tipo di dato che si vuole utilizzare (numero intero, numero reale, stringa, etc.).\u00a0\u21a9</p> </li> <li> <p>Questo \u00e8 generalmente vero, ma nei casi dei contatori \u00e8 possibile utilizzare lettere singole.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Programmazione/02_algoritmo_euclide/","title":"Algoritmo di Euclide","text":"<p>L'algoritmo di Euclide \u00e8 un algoritmo per calcolare il massimo comun divisore di due numeri interi positivi. Dunque, dati due numeri interi \\(a, b\\) calcolare \\(\\lcm(a, b)\\).</p> Input \\(a, b\\) \u2013 coppia di numeri interi maggiori di zero Output \\(\\mcd{}\\) \u2013 massimo comun divisore di \\(a\\) e \\(b\\), numero intero maggiore di zero <p>L'algoritmo di Euclide si basa sulle seguenti propriet\u00e0:</p> <ol> <li>Se \\(a = b\\) allora \\(\\mcd(a, b) = a = b\\);</li> <li>Se \\(a &gt; b\\) allora \\(\\mcd(a, b) = \\mcd(a - b, b)\\);</li> <li>Se \\(a &lt; b\\) allora \\(\\mcd(a, b) = \\mcd(a, b - a)\\).</li> </ol>"},{"location":"Anno_I/Programmazione/02_algoritmo_euclide/#considerazioni","title":"Considerazioni","text":"<p>La prima propriet\u00e0 afferma che il massimo comun divisore di due numeri uguali \u00e8 uno qualunque dei due numeri. La seconda e terza propriet\u00e0 affermano che il massimo comun divisore di due numeri diversi si pu\u00f2 ricondurre al calcolo del massimo comun divisore del pi\u00f9 piccolo dei due numeri e della differenza tra il pi\u00f9 grande e il pi\u00f9 piccolo.</p> <p>Queste propriet\u00e0 non sono l'algoritmo di risoluzione del problema, ma sono un'idea di come risolvere il problema. Queste propriet\u00e0 non dicono quando fermarsi o quando ripetere un'operazione.</p>"},{"location":"Anno_I/Programmazione/02_algoritmo_euclide/#pseudo-codifica","title":"Pseudo codifica","text":"<p>Poich\u00e9 valgono le propriet\u00e0 precedenti, nel caso generale si possono calcolare tante differenze in modo da riportarsi al caso \\(a = b\\), per il quale il problema \u00e8 risolto. Il calcolo delle differenze deve essere ripetuto se risulta vero che \\(a\\) sia diverso da \\(b\\). Si pu\u00f2 utilizzare una iterazione a condizione iniziale.</p> <p>Dunque:</p> Algoritmo di Euclide<pre><code>MENTRE (\ud835\udc4e \u2260 \ud835\udc4f)\n    SE (\ud835\udc4e &gt; \ud835\udc4f)\n        ALLORA assegna ad \ud835\udc4e il valore di \ud835\udc4e - \ud835\udc4f\n        ALTRIMENTI assegna ad \ud835\udc4f il valore di \ud835\udc4f - \ud835\udc4e\n    FINE\nFINE\n</code></pre> <p>Il blocco <code>MENTRE</code> indica una ripetizione di un blocco di istruzioni. Viene ripetuto tutto ci\u00f2 che \u00e8 contenuto fra <code>MENTRE</code> e <code>FINE</code> fino a quando la condizione non risulti falsa. Nel caso in cui il mentre provochi un ciclo infinito, l'algoritmo \u00e8 errato. \u00c8 comunque presente un salto ma non \u00e8 paragonabile a quello del <code>GOTO</code> poich\u00e9 \u00e8 nascosto, non arbitrario e controllato da una condizione. Nel blocco <code>MENTRE</code> si verifica la condizione iniziale, se \u00e8 vera allora si procede col ciclo, altrimenti si esce dal ciclo; una volta terminata la prima iterazione si verifica nuovamente la condizione iniziale, se \u00e8 vera si ripete il ciclo, altrimenti si esce dal ciclo e cos\u00ec via.</p> <p>Ad esempio, se i due numeri fossero minori di zero, il ciclo non terminerebbe mai. In questo caso, l'algoritmo \u00e8 errato. \u00c8 necessario che, durante la stesura dell'algoritmo, si verifichi che non ci siano cicli infiniti. Questo \u00e8 possibile verificando che la condizione di uscita dal ciclo si avveri.</p> <p>Il blocco <code>SE</code> presenta una condizione che pu\u00f2 essere vera o falsa. Se la condizione \u00e8 vera, allora viene eseguito il blocco <code>ALLORA</code> e il blocco <code>ALTRIMENTI</code> viene ignorato. Se la condizione \u00e8 falsa, allora viene eseguito il blocco <code>ALTRIMENTI</code> e il blocco <code>ALLORA</code> viene ignorato. Il blocco <code>SE</code> pu\u00f2 essere utilizzato anche senza il blocco <code>ALTRIMENTI</code>.</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/","title":"Notazione Lineare","text":"<p>Chiamiamo algoritmo un metodo risolutivo per un problema, descritto da un insieme di operazioni elementari o istruzioni. In altre parole un algoritmo \u00e8 una sequenza finita di passi elementari che definiscono un procedimento mediante il quale \u00e8 possibile risolvere un problema. Un passo elementare \u00e8 chiamato anche operazione elementare oppure azione elementare oppure istruzione.</p> <p>Una operazione si dice elementare se:</p> <ul> <li>\u00e8 interpretata in modo univoco dall'esecutore;</li> <li>\u00e8 direttamente eseguita dall'esecutore (uomo o macchina).</li> </ul> <p>Cio\u00e8 l'esecutore comprende in modo univoco che cosa deve fare e sa come farlo.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#proprieta-di-un-algoritmo","title":"Propriet\u00e0 di un algoritmo","text":"<p>Un algoritmo gode necessariamente delle seguenti propriet\u00e0:</p> Non ambiguit\u00e0 ogni operazione descritta nell'algoritmo deve essere interpretata in modo univoco dall'esecutore. Eseguibilit\u00e0 l'esecutore deve essere in grado di eseguire ogni operazione descritta nell'algoritmo in un tempo finito. Finitezza Il numero di operazioni descritte nell'algoritmo deve essere finito e l'esecuzione di quest'ultimo deve terminare in un tempo finito. Generalit\u00e0 Deve produrre un risultato per ogni valore attribuito ai dati iniziali, cio\u00e8 un algoritmo deve risolvere tutti i problemi di una stessa classe"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#specifica-di-un-algoritmo","title":"Specifica di un algoritmo","text":"<p>In un algoritmo il risolutore descrive le operazioni necessarie per risolvere un problema ed anche l'ordine con cui le istruzioni devono essere eseguite</p> <p>In un algoritmo occorre specificare:</p> <ul> <li>L'elenco degli oggetti da manipolare (dati iniziali) e l'elenco delle   informazioni finali (risultati)</li> <li>L'insieme delle azioni da eseguire</li> <li>L'ordine esatto con cui le azioni devono essere eseguite e le condizioni che   devono essere verificate perch\u00e9 ad una azione ne segua una piuttosto che un   altro.</li> </ul> <p>Un algoritmo pu\u00f2 essere specificato mediante:</p> <ul> <li>linguaggio naturale (pseudo-codice);</li> <li>diagrammi di flusso (descrizione grafica);</li> <li>linguaggio di programmazione (codifica).</li> </ul> <p>Per specificare un algoritmo \u00e8 necessario evidenziare:</p> <ul> <li>i dati di ingresso e di uscita;</li> <li>le operazioni elementari;</li> <li>l'ordine in cui le operazioni elementari devono essere eseguite.</li> </ul>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#linguaggio-naturale","title":"Linguaggio naturale","text":"<p>Un algoritmo viene descritto con frasi di un linguaggio naturale (italiano, inglese). Le operazioni elementari sono descritte tramite l'utilizzo di nomi, verbi ed espressioni. Le operazioni sono scelte in relazione al problema da risolvere. I nomi, invece, denotano i dati.</p> <p>Le strutture di controllo o schemi di composizione delle istruzioni sono definite mediante l'utilizzo di parole chiave ben definite che vedremo in seguito.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#strutture-di-controllo","title":"Strutture di controllo","text":"<p>Esse hanno lo scopo di comporre le istruzioni in modo da ottenere un algoritmo, definiscono cio\u00e8 l'ordine in cui le istruzioni devono essere eseguite.</p> <p>Le strutture fondamentali di controllo sono le seguenti:</p> <ul> <li>sequenza;</li> <li>selezione;</li> <li>iterazione.</li> </ul>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#sequenza","title":"Sequenza","text":"<p>La sequenza permette di comporre ede eseguire le istruzioni una di seguito all'altra. Le istruzioni vengono sempre eseguite nell'ordine in cui sono state poste.</p> <p>Un esempio di sequenza \u00e8 il seguente:</p> Text Only<pre><code>sollevare il ricevitore\nattendere il segnale di linea\ncomporre il numero\nattendere la risposta\ncondurre la conversazione\ndeporre il ricevitore\n</code></pre> <p>Il precedente \u00e8 un algoritmo per effettuare una telefonata.</p> <p>Questo termina in un tempo finito? Nonostante il numero di operazioni sia finito, l'esecuzione dell'algoritmo non termina in un tempo finito. Infatti, l'algoritmo non specifica il caso in cui la linea sia occupata e non si possa effettuare la chiamata o ancora, il caso in cui il numero chiamato non risponda. In questi casi l'algoritmo non termina mai.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#selezione-binaria","title":"Selezione binaria","text":"<p>La selezione binaria permette di comporre ed eseguire le istruzioni in base ad una condizione. Se la condizione \u00e8 vera, allora viene eseguita una sequenza di istruzioni, altrimenti viene eseguita un'altra sequenza di istruzioni.</p> <p>La scelta viene effettuata sulla base di un'istruzione booleana o di una condizione1.</p> <p>Il costrutto della selezione binaria \u00e8 il seguente:</p> Text Only<pre><code>SE (condizione)\n    ALLORA &lt;istruzioni&gt;\n    ALTRIMENTI &lt;istruzioni&gt;\nFINE\n</code></pre> <p>Le istruzioni che seguono la parola chiave <code>SE</code> vengono eseguite se la condizione \u00e8 vera, altrimenti vengono eseguite le istruzioni che seguono la parola chiave <code>ALTRIMENTI</code>.</p> <p>Un esempio di selezione binaria \u00e8 il seguente:</p> Text Only<pre><code>SE (a &lt; b)\n    ALLORA massimo := b\n    ALTRIMENTI massimo := a\nFINE\n</code></pre> <p>Il precedente algoritmo determina il massimo tra due numeri interi.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#iterazione-a-condizione-iniziale","title":"Iterazione a condizione iniziale","text":"<p>L'iterazione a condizione iniziale permette di comporre ed eseguire le istruzioni ripetutamente fino a quando una condizione diventa falsa. La condizione viene verificata prima dell'esecuzione della sequenza di istruzioni. Se la condizione \u00e8 falsa, allora le istruzioni non vengono eseguite.</p> <p>Il costrutto dell'iterazione a condizione iniziale \u00e8 il seguente:</p> Text Only<pre><code>MENTRE (&lt;condizione&gt;)\n    &lt;istruzioni&gt;\nFINE\n</code></pre> <p>Un esempio di iterazione a condizione iniziale \u00e8 il seguente:</p> Text Only<pre><code>p := 1\nmassimo := p-esimo elemento di E\nMENTRE (p &lt;= n)\n    p = p + 1\n    SE (massimo &lt; p-esimo elemento di E)\n        ALLORA massimo := p-esimo elemento di E\n    FINE\nFINE\n</code></pre> <p>Il precedente algoritmo determina il massimo tra i numeri interi contenuti in un insieme, con l'ipotesi che l'insieme non sia vuoto. Nell'algoritmo, <code>p</code> \u00e8 un contatore che indica l'elemento corrente dell'insieme, <code>n</code> \u00e8 il numero di elementi dell'insieme, <code>E</code> \u00e8 l'insieme di numeri interi.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#iterazione-a-condizione-finale","title":"Iterazione a condizione finale","text":"<p>L'iterazione a condizione finale permette di comporre ed eseguire le istruzioni ripetutamente fino a quando una condizione diventa falsa. La condizione viene, per\u00f2, controllata dopo l'esecuzione della sequenza di istruzioni.</p> <p>Il costrutto dell'iterazione a condizione finale \u00e8 il seguente:</p> Text Only<pre><code>ESEGUI\n    &lt;istruzioni&gt;\nFINCH\u00c9 (&lt;condizione&gt;)\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#equivalenza","title":"Equivalenza","text":"<p>Due algoritmi si dicono equivalenti se:</p> <ul> <li>hanno lo stesso dominio di definizione;</li> <li>hanno lo stesso dominio immagine;</li> <li>in corrispondenza degli stessi valori nel dominio di definizione producono gli   stessi valori nel dominio immagine.</li> </ul> <p>Dunque, due algoritmi equivalenti, nonostante possano essere diversi e avere diversa efficienza, forniranno lo stesso risultato.</p> <p>\ufeff</p> <ol> <li> <p>Una condizione \u00e8 un'espressione che pu\u00f2 assumere il valore vero o falso.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/","title":"Algebra Booleana","text":"<p>L'algebra do Bool opera su delle variabili, per l'appunto booleane, e su dei valori costanti. I valori costanti sono due: vero e falso. Quest'ultimi possono essere rappresentati con 1 e 0, V e F, true e false ma anche T e F.</p> <p>Questi valori costanti sono detti valori booleani e sono molto utili per le condizioni dei costrutti <code>SE</code> e <code>MENTRE</code>.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#operatori","title":"Operatori","text":"<p>Per poter concatenare tra loro pi\u00f9 condizioni si possono utilizzare gli operatori booleani. Questi operatori sono essenzialmente dei costrutti che operano su valori booleani e restituiscono un valore booleano. Questi operatori sono:</p> <ul> <li><code>NOT</code>: negazione, inverte il valore booleano e si scrive con il simbolo <code>\u00ac</code>;</li> <li><code>AND</code>: congiunzione, restituisce vero se entrambi i valori sono veri,   altrimenti restituisce falso e si scrive con il simbolo <code>\u2227</code>;</li> <li><code>OR</code>: disgiunzione, restituisce vero se almeno uno dei due valori \u00e8 vero,   altrimenti restituisce falso e si scrive con il simbolo <code>\u2228</code>;</li> </ul> A B A \u2227 B A \u2228 B V V V V V F F V F V F V F F F F <p>Come \u00e8 possibile constatare, l'operazione <code>AND</code> \u00e8 molto pi\u00f9 restrittiva delle altre, infatti restituisce vero solo se entrambi i valori sono veri. L'operazione <code>OR</code> invece \u00e8 molto pi\u00f9 permissiva, infatti restituisce vero se almeno uno dei due valori \u00e8 vero.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#esempi","title":"Esempi","text":"<p>Con le variabili booleane \u00e8 possibile costruire delle semplici espressioni che restituiscono dei valori booleani, ad esempio:</p> Text Only<pre><code>\u00acB\n\u00ac(A \u2228 B)\n</code></pre> <p>L'operatore <code>NOT</code> \u00e8 s\u00ec utile per negare una condizione, ma \u00e8 molto pi\u00f9 comodo e leggibile utilizzare le condizioni al \"positivo\", ovvero senza negare la condizione. Ad esempio:</p> Text Only<pre><code>\u00ac(a &gt; b) = (a &lt;= b)\n</code></pre> <p>Bisogna fare attenzione alle condizioni booleane, poich\u00e9 \u00e8 possibile che queste non diventino mai false, ad esempio:</p> Text Only<pre><code>(a &gt; 5 ) \u2227 (a &lt;= 10)\n</code></pre> <p>In questo caso si ha che \\(a \\in \\,]5,\\ 10[\\) e nel caso in cui fosse presente un <code>OR</code> al posto dell'<code>AND</code> la condizione non diventerebbe mai falsa.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#asserzioni","title":"Asserzioni","text":"<p>Le asserzioni in un linguaggio di programmazione sono delle espressioni booleane che possono essere utilizzate per:</p> <ul> <li>documentare un programma, descrivendone la semantica;</li> <li>verificare un programma, provandone la correttezza formale.</li> </ul> <p>Le asserzioni possono essere pre-condizioni e post-condizioni</p> <p>La pre-condizione o premessa, \u00e8 un'espressione booleana che deve essere verificata prima di un'istruzione o di un blocco di istruzioni. La post-condizione o conseguenza, \u00e8 un'espressione booleana che deve essere verificata dopo un'istruzione o un blocco di istruzioni.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#esercizi","title":"Esercizi","text":"<p>Scrivere le espressioni equivalenti alle seguenti senza utilizzare la negazione:</p> <ol> <li><code>(a &gt; b) = (a &lt;= b)</code>;</li> <li><code>((a &lt;= b) \u2227 (c &lt;= d)) = ((a &gt;= b) \u2228 (c &gt;= d))</code>;</li> <li><code>((a &lt; 1) \u2228 (b &lt; 2) \u2227 (c &lt; 3)) = ((a &gt; 1) \u2227 (b &gt; 2) \u2228 (c &gt; 3))</code>.</li> </ol> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/05_dati/","title":"I Dati","text":"<p>I dati rappresentano oggetti e propriet\u00e0 della realt\u00e0 rilevanti per il problema in esame. I dati sono un'astrazione degli oggetti del mondo reale, nel senso che:</p> <p>N. Wirth, Algoritmi e strutture dati</p> <p>Alcune propriet\u00e0 e caratteristiche degli oggetti in esame vengono ignorate perch\u00e9 sono irrilevanti e marginali per il particolare problema considerato</p> <p>Il concetto di dati \u00e8 estremamente importante in informatica e la sua comprensione \u00e8 fondamentale per la progettazione di un programma. Durante il processo di progettazione di un programma \u00e8 necessario individuare i dati che sono rilevanti per il problema in esame e descriverli, fornendo una descrizione il quanto pi\u00f9 completa e appropriata possibile.</p> <p>Le caratteristiche che vanno descritte sono solo alcune, come ad esempio il tipo di dato, la quantit\u00e0 dello stesso, etc.</p> <p>Se, ad esempio, si volesse descrivere un algoritmo utile a gestire i dati anagrafici e la carriera degli studenti universitari, un dato fondamentale sarebbe, ovviamente, lo studente stesso. Dati non fondamentali sono, ad esempio: altezza, colore degli occhi o dei capelli, etc. Dati che invece sono fondamentali sono, ad esempio: nome, cognome, data di nascita, luogo di nascita, residenza, sesso, reddito, etc.</p> <p>All'anagrafe, invece, risultano essere utili tutti i dati che riguardano le caratteristiche fisiche dello studente, in pratica l'opposto dell'algoritmo.</p> <p>Informazioni</p> <p>A seconda della situazione, l'oggetto viene descritto (con dei dati), in modo diverso.</p>"},{"location":"Anno_I/Programmazione/05_dati/#dati-semplici","title":"Dati semplici","text":"<p>I dati semplici o elementari rappresentano oggetti, entit\u00e0, propriet\u00e0 elementari o atomiche non decomponibili. Ad esempio:</p> <ul> <li>la misura di un lato di un poligono;</li> <li>il numero di matricola di uno studente;</li> <li>il voto di un esame.</li> </ul>"},{"location":"Anno_I/Programmazione/05_dati/#dati-strutturati","title":"Dati strutturati","text":"<p>I dati strutturati rappresentano oggetti, entit\u00e0, propriet\u00e0 pi\u00f9 complesse, decomponibili in dati elementari. Essi sono aggregati di dati semplici.</p> <p>Esempio</p> StudenteDataPersona Text Only<pre><code>Studente:\n    Matricola;\n    Nome e cognome;\n    Corso di laurea;\n    Universit\u00e0.\n</code></pre> Text Only<pre><code>Data:\n    Giorno;\n    Mese;\n    Anno.\n</code></pre> Text Only<pre><code>Persona:\n    Informazioni fisiche:\n        Altezza;\n        Colore degli occhi;\n        Colore dei capelli;\n        Peso;\n    Informazioni anagrafiche:\n        Nome;\n        Cognome;\n        Data di nascita;\n        Stato civile;\n        Residenza.\n</code></pre> <p>I dati strutturati possono a loro volta essere descritti con altri dati strutturati.</p>"},{"location":"Anno_I/Programmazione/05_dati/#tipi-di-dati","title":"Tipi di dati","text":"<p>Ogni dato \u00e8 caratterizzato da un nome (o identificatore) e da un tipo. Il nome viene utilizzato per identificare univocamente il dato1 Il tipo di dato \u00e8 legato al contenuto dello stesso, nel caso di dato semplice si tratta del dato stesso, nei casi di dati strutturati si tratta di una descrizione dei dati semplici che lo compongono. Il tipo indica anche le operazioni che possono essere eseguite sul dato.</p> <p>Sui tipi di dati definiti dall'utente, \u00e8 ques'ultimo che deve definire le operazioni che possono essere eseguite.</p> <p>Inoltre, i dati possono essere:</p> <ul> <li>Dati di input</li> <li>Dati di output</li> <li>Dati di lavoro (utilizzati durante l'esecuzione dell'algoritmo)</li> </ul> <p>\ufeff</p> <ol> <li> <p>\u00c8 consigliabile utilizzare nomi che ricordino il contenuto del dato.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/","title":"Metodologia Top-Down","text":"<p>La metodologia di sviluppo di un programma Top-Down riguarda i metodi di risoluzione di un problema, basati sulla decomposizione del problema.</p> <p>Lo stepwise refinement (ovvero raffinamento per passi successivi), \u00e8 una strategia di sviluppo Top-Down proposta da N. Wirth nell'ambito della programmazione strutturata, nell'articolo \"Program Development by Stepwise Refinement\", 1971.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#metodologia-top-down-nellanalisi-del-problema","title":"Metodologia Top-Down nell'analisi del problema","text":"<p>L'analisi Top-Down prevede la scomposizione del problema generale da risolvere in pi\u00f9 sotto-problemi.</p> <p>La scomposizione del problema in sotto-problemi, si ottiene attraverso la decomposizione del problema in sotto-problemi, che a loro volta possono essere decomposti in altri sotto-problemi, e cos\u00ec via.</p> <p>Ognuno di questi sotto-problemi, va analizzato e risolto in modo indipendente dal problema principale. In questo modo, si ottiene una soluzione al problema generale risolvendo i sotto-problemi.</p> <p>Cos\u00ec facendo, il problema generale viene decomposto in sotto-problemi pi\u00f9 semplici del principale. Questi possono essere rappresentati come un albero, in cui il nodo radice rappresenta il problema generale, e i nodi foglia rappresentano i sotto-problemi pi\u00f9 semplici. Quest'albero viene chiamato albero di decomposizione funzionale.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#albero-di-decomposizione","title":"Albero di decomposizione","text":"<p>L'albero di decomposizione funzionale, \u00e8 un albero che rappresenta la scomposizione del problema in sotto-problemi. Ad esempio, il problema iniziale \\(P\\), pu\u00f2 essere decomposto in \\(P_1\\), \\(P_2\\) e \\(P_3\\):</p> <pre><code>flowchart TD\n  P --&gt; P1 &amp; P2 &amp; P3;</code></pre> <p>Nel caso in cui i sotto-problemi \\(P_1\\), \\(P_2\\) e \\(P_3\\) siano a loro volta troppo complessi, possono essere decomposti in altri sotto-problemi.</p> <pre><code>flowchart TD\n  P --&gt; P1 &amp; P2 &amp; P3;\n  P1 --&gt; P1.1 &amp; P1.2;\n  P3 --&gt; P3.1 &amp; P3.2;</code></pre> <p>Quindi si ha che nella radice dell'albero di decomposizione, si ha il problema principale \\(P\\), e i nodi foglia \\(P_{1.1}\\), \\(P_{1.2}\\), \\(P_2\\), \\(P_{3.1}\\) e \\(P_{3.2}\\) si hanno i sotto-problemi pi\u00f9 semplici, considerati pi\u00f9 facilmente risolvibili.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#come-comporre-le-soluzioni-dei-sotto-problemi","title":"Come comporre le soluzioni dei sotto-problemi","text":"<p>Lo scopo del processo di decomposizione, \u00e8 quello di scomporre la soluzione del problema principale nelle soluzioni di altri problemi, ma molto pi\u00f9 semplici e dunque pi\u00f9 facilmente risolvibili.</p> <p>La soluzione per un problema \\(P\\) si ottiene combinando le soluzioni dei suoi sotto-problemi utilizzando le strutture di controllo, ovvero sequenza, selezione e iterazione.</p> <p>La situazione \u00e8 differente se il problema ammette una soluzione ricorsiva.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#specifica-di-un-problema","title":"Specifica di un problema","text":"<p>La specifica di un problema, \u00e8 una descrizione formale del problema, che permette di definire il problema in modo univoco. La specifica di un problema, \u00e8 composta da:</p> <ul> <li>il compito o funzione che il problema richiede che sia svolto;</li> <li>i dati di input e di output.</li> </ul>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#soluzione","title":"Soluzione","text":"<p>La descrizione della soluzione del problema \\(P\\), \u00e8 basata sulla descrizione delle soluzioni dei suoi sotto-problemi, ovvero:</p> <ul> <li>la specifica di ogni singolo sotto-problema (compito/funzione);</li> <li>i dati di input e output di ciascun sotto-problema.</li> </ul>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#metodologia-bottom-up","title":"Metodologia Bottom-Up","text":"<p>La metodologia Bottom-Up, \u00e8 una metodologia di progettazione e sviluppo di un programma che riguarda i metodi di risoluzione di un problema per sintesi, ovvero basandosi sull'interconnessione di componenti gi\u00e0 disponibili.</p> <p>Questo porta alla creazione di componenti standard che possono essere riutilizzati.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#programmazione-in-grande-e-in-piccolo","title":"Programmazione in grande e in piccolo","text":"<p>Il compito della programmazione in grande \u00e8 quello di progettare la struttura del programma come se fosse un insieme di parti, detti moduli.</p> <p>La programmazione in piccolo \u00e8 la fase di sviluppo del programma, in cui si descrivono i singoli moduli, implementando e progettando i singoli algoritmi.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#pseudo-codifica","title":"Pseudo-codifica","text":"<p>Il linguaggio che viene utilizzato per descrivere i singoli algoritmi, \u00e8 detto pseudo-codice. Questo \u00e8 un linguaggio che non \u00e8 un vero linguaggio di programmazione, ma che \u00e8 molto simile ad esso.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#livelli-di-astrazione","title":"Livelli di astrazione","text":"<p>L'algoritmo viene inizialmente espresso in maniera molto astratta, utilizzando il linguaggio naturale (con astrazioni sui controlli, sui tipi di dato e sulle funzioni). Successivamente, si passa ad un livello di astrazione pi\u00f9 basso, utilizzando lo pseudo-codice. Infine, si passa al linguaggio di programmazione</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/","title":"Funzioni e procedure","text":"<p>Come accennato in precedenza, un programma pu\u00f2 essere organizzato in un programma principale e un insieme di sotto-programmi. Ad esempio</p> <pre><code>flowchart TD\n  M --&gt; M1 &amp; M2 &amp; M3;</code></pre> <p>scomponiamo il problema \\(M\\) nei sotto-problemi \\(M_1, M_2, M_3\\)</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#struttura-di-un-programma-in-c","title":"Struttura di un programma in C","text":"<p>Nel C, un programma \u00e8 costituito da una sezione di dichiarazioni globali, dalla funzione <code>main() {}</code> e da altre funzioni, in questo caso \\(f_1\\) e \\(f_2\\).</p> <pre><code>flowchart TD\n  subgraph \"Dichiarazioni Globali\"\n  direction LR;\n    subgraph main; end\n    subgraph f1; end\n    subgraph f2; end\n  end</code></pre> <p>\u00c8 presente un'analogia tra la scomposizione di un problema e la struttura di un programma. Intuitivamente si pu\u00f2 affermare che la soluzione di ciascun sotto-problema sia un sotto-programma a s\u00e8 stante.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#sotto-programmi","title":"Sotto-programmi","text":"<p>Vari linguaggi di programmazione forniscono dei costrutti sintattici per</p> <ul> <li>creare delle unit\u00e0 di programma (sotto-programmi), dando un nome ad un gruppo   di istruzioni;</li> <li>Attivare tali unit\u00e0 con modalit\u00e0 di comunicazione stabilite con l'unit\u00e0   chiamante.</li> </ul>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#caratteristiche-di-un-sotto-programma","title":"Caratteristiche di un sotto-programma","text":"<p>Un sotto-programma \u00e8:</p> <ul> <li>identificato da un nome;</li> <li>costituito da istruzioni.</li> </ul> <p>Generalmente con gli stessi costrutti di un programma, ovvero dichiarazioni e blocco delle dichiarazioni eseguibili</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#attivazione-o-chiamata-di-un-sotto-programma","title":"Attivazione o chiamata di un sotto-programma","text":"<p>Un sotto-programma va in esecuzione solo se la sua attivazione viene richiesta da parte di un'altra unit\u00e0 di programma (che sia in grado di rilevare la presenza del sotto-programma).</p> <p>L'attivazione viene richiesta utilizzando il nome del sotto-programma. Tale nome va utilizzato ogni volta che si vuole eseguire quel determinato blocco di istruzioni.</p> <p>I programmi possono essere sia interni che esterni all'unit\u00e0 che li utilizza.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#parametri-di-un-sotto-programma","title":"Parametri di un sotto-programma","text":"<p>I sotto-programmi possono comunicare con l'unit\u00e0 chiamante attraverso i parametri.</p> <p>Il nome del sotto-programma e l'elenco dei suoi parametri vengono dichiarati esplicitamente nell'intestazione dei sotto-programmi, ovvero la prima istruzione del sotto-programma.</p> <p>I parametri consentono di rappresentare i dati di comunicazione tra il sotto-programma e il programma chiamante, ovvero i dati di ingresso e quelli di uscita del sotto-programma.</p> <p>Ogni parametro \u00e8 individuato da un nome e da un tipo. Inoltre, la lista dei parametri va definita in modo esplicito nell'intestazione del sotto-programma.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#attivazione-di-un-sotto-programma","title":"Attivazione di un sotto-programma","text":"<p>Al momento dell'attivazione del sotto-programma:</p> <ol> <li>viene sospesa l'esecuzione dell'unit\u00e0 contenente la richiesta di attivazione    e il controllo passa al sotto-programma attivato;</li> <li>al termine dell'esecuzione, l'attivazione viene terminata e il controllo    ritorna all'unit\u00e0 chiamante.</li> </ol>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#astrazione-funzionale-e-procedurale","title":"Astrazione funzionale e procedurale","text":"<p>Mediante i sotto-programmi \u00e8 possibile ampliare l'insieme degli operatori e delle istruzioni disponibili in un linguaggio di programmazione. I sotto-programmi sono di due tipi:</p> <ul> <li>Funzioni mediante le quali \u00e8 possibile introdurre nuovi operatori (astrazione   funzionale o astrazione della nozione di operatore);</li> <li>Procedure mediante le quali \u00e8 possibile introdurre nuove istruzioni   (astrazione procedurale o astrazione della nozione di istruzione).</li> </ul>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#funzioni-matematiche","title":"Funzioni matematiche","text":"<p>Un sotto-programma di tipo funzione consente di costruire una funzione matematica.</p> <p>Una funzione matematica \\(f\\) associa ad un valore del suo dominio \\(\\dom f\\) un valore del dominio del risultato, il \\(\\codom f\\). Ad esempio sia \\(f = \\sqrt{x}\\), si ha:</p> \\[ f \\colon \\R \\to \\R \\]"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#funzioni","title":"Funzioni","text":"<p>In un linguaggio di programmazione una funzione \\(f\\) pu\u00f2 essere vista come un operatore che opera su operandi, ovvero i parametri in input, e produce un risultato o valore di output</p> <pre><code>flowchart LR\n    Operandi --&gt; f --&gt; Risultato;</code></pre> <p>Ai parametri di input e al valore di output deve essere associato un tipo. Il valore di output \u00e8 necessariamente scalare.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#attivazione-di-una-funzione","title":"Attivazione di una funzione","text":"<p>Una funzione viene attivata (o chiamata) inserendo il nome della stessa e la sua lista dei parametri (se presente) in un'espressione dello stesso tipo della funzione.</p> <p>Per poter chiamare una funzione \u00e8 sufficiente conoscere il nome di quest'ultima e la sua lista di parametri, dunque una funzione pu\u00f2 essere vista come una scatola nera della quale si conoscono soltanto i dati d'ingresso e il risultato.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#astrazione-funzionale","title":"Astrazione funzionale","text":"<p>Una funzione \\(f\\) pu\u00f2 essere vista come un operatore che opera su tipi di dati primitivi o definiti dal programmatore.</p> <p>Con l'introduzione di una funzione viene ampliato l'insieme degli operatori del linguaggio utilizzato.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#funzioni-in-c","title":"Funzioni in C","text":"<p>Il linguaggio C fornisce il costrutto function per realizzare sia funzioni che procedure. Le differenze consistono essenzialmente nel modo di</p> <ul> <li>Modo di comunicare i dati di uscita</li> <li>Modo di chiamare il sotto-programmi</li> </ul> <p>Per poter utilizzare una funzione \u00e8 necessario:</p> <ul> <li>definire il sotto-programma, cio\u00e8 scrivere in C tutte le istruzioni necessarie;</li> <li>dichiarare il sotto-programma nella parte dichiarativa del programma.</li> </ul>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#definizione-di-una-funzione","title":"Definizione di una funzione","text":"<p>La definizione di una funzione \u00e8 costituita da: un'intestazione e un blocco di dichiarazioni e istruzioni, ovvero sezioni di:</p> <ol> <li>dichiarazioni di costanti, tipi e variabili</li> <li>di istruzioni</li> </ol> <p>La sintassi per definire una funzione nel C \u00e8 la seguente:</p> Funzione in C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;parametri&gt;) {\n&lt;dichiarazioni locali&gt;\n&lt;istruzioni&gt;\n}\n</code></pre> <p>Dopo l'intestazione della funzione vi sono:</p> <ul> <li>le dichiarazioni locali, cio\u00e8 le dichiarazioni di tutte le risorse (costanti,   tipi, variabili, funzioni) necessarie;</li> <li>il blocco delle istruzioni</li> </ul> <p>Infine \u00e8 presente l'istruzione <code>return &lt;valore&gt;;</code> che restituisce il valore calcolato dall'espressione</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#intestazione-di-una-funzione","title":"Intestazione di una funzione","text":"<p>Nell'intestazione di una funzione:</p> C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;parametri&gt;)\n</code></pre> <p>il <code>&lt;tipo&gt;</code> sarebbe il tipo del valore che la funzione restituisce, <code>&lt;identificatore&gt;</code> sarebbe il nome della funzione e <code>&lt;parametri&gt;</code> sarebbe la lista di parametri che la funzione accetta.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#lista-di-parametri-formali","title":"Lista di parametri formali","text":"<p>Ogni parametro della lista \u00e8 definito come tipo e identificatore</p> C<pre><code>(&lt;parametri&gt;) := (&lt;tipo&gt; &lt;identificatore&gt;)\n</code></pre> <p>I parametri sono tra loro separati da virgole.</p> <p>Esempi di intestazione</p> C<pre><code>int abs(int x);\n</code></pre> <p>oppure</p> C<pre><code>float somma(int a, int b);\n</code></pre>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#lista-di-parametri-attuali","title":"Lista di parametri attuali","text":"<p>I parametri attuali indicano i valori degli argomenti rispetto ai quali la funzione deve essere calcolata. Un parametro attuale pu\u00f2 essere:</p> <ul> <li>Una costante;</li> <li>Una variabile;</li> <li>Una espressione;</li> <li>Una chiamata ad una funzione;</li> </ul> <p>Esempi di attivazione</p> <p>Data la seguente funzione</p> C<pre><code>float somma(int a, int b);\n</code></pre> <p>esempi di attivazione della stessa sono i seguenti:</p> C<pre><code>z = somma(a, b);\nz = somma(2, 5*b);\nz = c + somma(a, b);\ny = somma(x, abs(z));\n</code></pre> <p>L'attivazione di una funzione pu\u00f2 essere inserita dovunque possa essere inserito un operatore sul tipo del parametro della funzione.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#prototipi","title":"Prototipi","text":"<p>Una funzione deve essere dichiarata prima del suo utilizzo. La dichiarazione \u00e8 costituita dal suo prototipo.</p> <p>Il prototipo \u00e8 uguale alla intestazione della funzione:</p> C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;parametri&gt;)\n</code></pre> <p>Nel prototipo gli identificatori dei parametri sono opzionali, si pu\u00f2 quindi avere:</p> C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;tipi&gt;)\n</code></pre> <p>Il prototipo di una funzione deve essere inserito nella parte dichiarativa del programma, prima del codice che utilizza la funzione stessa.</p> <p>In tal modo il compilatore pu\u00f2 facilmente controllare il numero ed il tipo dei parametri di input ed il tipo del valore restituito.</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/","title":"Tipi semplici","text":""},{"location":"Anno_I/Programmazione/08_tipi_semplici/#linguaggi-di-programmazione","title":"Linguaggi di programmazione","text":"<p>Un linguaggio di programmazione rappresenta un elaboratore astratto, capace di comprendere i termini del linguaggio che, generalmente, sono delle astrazioni degli oggetti della macchina reale. Ad esempio una variabile \u00e8 un'astrazione della memoria centrale.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dati","title":"Dati","text":"<p>I dati rappresentano oggetti e propriet\u00e0 della realt\u00e0 rilevanti per il problema in esame. I dati sono una astrazione di oggetti del mondo reale.</p> <p>Che cosa si intende per astrazione? \u00c8 un processo per il quale si ignorano gli aspetti reali che non sono rilevanti, in modo tale da concentrarsi completamente sugli aspetti pi\u00f9 importanti. Una astrazione \u00e8 dunque una semplificazione.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dati-semplici-e-strutturati","title":"Dati semplici e strutturati","text":"<p>I dati semplici o elementari rappresentano oggetti, entit\u00e0, propriet\u00e0 elementari o atomiche non decomponibili.</p> <p>I dati strutturati rappresentano oggetti, entit\u00e0 o propriet\u00e0 pi\u00f9 complessi, sono dunque aggregati di dati elementari.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#identificatori-di-variabili-e-costanti","title":"Identificatori di variabili e costanti","text":"<p>Una variabile \u00e8 identificata da un nome, detto identificatore, ed assume un valore che pu\u00f2 essere modificato durante l\u2019esecuzione di un programma.</p> <p>Una costante \u00e8 identificata da un nome, detto identificatore, ed assume un valore che non pu\u00f2 essere modificato durante l\u2019esecuzione di un programma.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-di-dati","title":"Tipi di dati","text":"<p>Ad ogni dato, variabile o costante, deve essere associato un tipo. Generalmente tale associazione \u00e8 dichiarata nella sezione dichiarativa del programma.</p> <p>I tipi sono: numerici, logici, alfanumerici o caratteri:</p> <pre><code>flowchart LR\n  tipo --&gt; numerico &amp; carattere &amp; logico;\n  numerico --&gt; intero &amp; reale;</code></pre> <p>Un tipo di dato o semplicemente tipo indica:</p> <ul> <li>Un insieme di valori \\(D\\) (dominio);</li> <li>Un insieme di operazioni \\(O\\) che si applicano agli elementi di \\(D\\),   operatori e predicati;</li> <li>Un insieme di costanti, cio\u00e8 di simboli con cui si denotano i valori del   dominio \\(D\\).</li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dichiarazione-di-una-variabile","title":"Dichiarazione di una variabile","text":"<p>Per dichiarare una variabile <code>a</code> \u00e8 necessario associare ad essa un tipo che indichi:</p> <ul> <li>i valori che questa pu\u00f2 assumere;</li> <li>le operazioni che possono essere effettuate sull'insieme di tali valori;</li> <li>i simboli con cui si indicano tali valori all'interno di un programma.</li> </ul> <p>Dichiarazione di una variabile</p> <p>Un esempio di dichiarazione in C \u00e8 la seguente</p> C<pre><code>int a\n</code></pre>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#costanti","title":"Costanti","text":"<p>Dichiarazione di una costante</p> <p>Dichiarazione in C di una costante intera identificata da <code>n</code>:</p> C<pre><code>const int n = 100;\n</code></pre> <p>La parola chiave \u00e8 <code>const</code>, <code>int</code> \u00e8 lo specificatore del tipo, <code>100</code> \u00e8 il valore assegnato alla costante <code>n</code>.</p> <p>Una dichiarazione di costante associa permanentemente un identificatore ad un valore.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-e-linguaggi-di-programmazione","title":"Tipi e linguaggi di programmazione","text":"<p>I linguaggi di programmazione consentono di:</p> <ul> <li>Utilizzare tipi di dato predefiniti;</li> <li>Definire nuovi tipi;</li> <li>Convertire una variabile di un tipo in una variabile di altro tipo in modo   implicito o esplicito.</li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-primitivi","title":"Tipi primitivi","text":"<p>I tipi primitivi sono quelli direttamente disponibili nel linguaggio di programmazione. In C i tipi primitivi sono:</p> <ul> <li>Tipi predefiniti:<ul> <li><code>int</code>: per i numeri interi;</li> <li><code>float</code>: per i numeri reali;</li> <li><code>double</code>: per i reali in doppia precisione;</li> <li><code>char</code>: per i caratteri;</li> </ul> </li> <li>Tipi definiti dall'utente:<ul> <li>Tipi enumerati definiti tramite la parola chiave <code>enum</code>.</li> </ul> </li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-semplici-e-tipi-strutturati","title":"Tipi semplici e tipi strutturati","text":"<p>I tipi primitivi sono detti anche tipi semplici ovvero il loro dominio \u00e8 elementare, dunque costituito da elementi atomici non decomponibili (es. <code>int</code>).</p> <p>I tipi strutturati sono quelli il cui dominio \u00e8 composito, ovvero \u00e8 composto aggregando dati pi\u00f9 elementari (es. vettore e struttura).</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dati-numerici-interi-e-reali","title":"Dati numerici interi e reali","text":"<p>I linguaggi di programmazione consentono di rappresentare ed elaborare dati numerici interi e reali. Il linguaggio C fornisce tre tipi predefiniti:</p> <ul> <li><code>int</code> per rappresentare ed elaborare un sottoinsieme dei numeri interi</li> <li><code>float</code> e double per rappresentare ed elaborare un sottoinsieme dei   numeri reali</li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipo-int","title":"Tipo int","text":"<p>I dati di tipo int costituiscono un sottoinsieme dei numeri interi, positivi e negativi. Un <code>int</code> \u00e8 rappresentato generalmente in una parola, \\(2 {\\rm\\,byte}\\) o \\(4 {\\rm\\,byte}\\). Nel caso in cui la parola sia di \\(2 {\\rm\\,byte}\\) il dominio del tipo <code>int</code> \u00e8 costituito dall'insieme.</p> \\[ D = [-2^{15},\\ 2^{15} -1] = [-32768,\\ 32767] \\] <p>Il minimo e il massimo valore intero hanno una rappresentazione simbolica denominata <code>INT_MIN</code> e <code>INT_MAX</code>.</p> <p><code>INT_MIN</code> e <code>INT_MAX</code> sono identificatori di costanti predefinite e contengono il valore del pi\u00f9 piccolo e del pi\u00f9 grande intero rappresentabile.</p> <p>La definizione delle due costanti \u00e8 contenuta nel file <code>limits.h</code>.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#operatori-aritmetici","title":"Operatori aritmetici","text":"<p>Siano \\(a, b\\) due operandi di tipo <code>int</code>. Gli operatori aritmetici restituiscono un valore di tipo <code>int</code></p> Operatore Simbolo Addizione <code>+</code> Sottrazione <code>-</code> Moltiplicazione <code>*</code> Divisione <code>/</code> Modulo <code>%</code> <p>La divisione restituisce il quoziente della divisione, ovvero la parte intera. Il modulo restituisce il resto della divisione.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#operatori-relazionali","title":"Operatori relazionali","text":"<p>Restituiscono un valore vero (<code>1</code>) o falso (<code>0</code>)</p> Operatore Simbolo Uguale <code>==</code> Diverso <code>!=</code> Minore <code>&lt;</code> Maggiore <code>&gt;</code> Minore uguale <code>&lt;=</code> Maggiore uguale <code>&gt;=</code>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#costanti-intere","title":"Costanti intere","text":"<p>I valori del dominio del tipo <code>int</code> sono denotati, all\u2019interno di un programma, con un insieme di valori costanti (costanti intere).</p> <p>Ogni costate intera \u00e8 rappresentata come un numero intero decimale eventualmente con segno. Ad esempio: <code>0</code>, <code>-151</code>, <code>+41</code>.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#espressione-aritmetica","title":"Espressione aritmetica","text":"<p>Una espressione aritmetica intera \u00e8 costituita da termini separati dagli operatori <code>+</code> e <code>-</code>. Ogni termine \u00e8 costituito da fattori, variabili e costanti, separati dagli operatori <code>*</code>, <code>/,</code> <code>%</code>.</p> <p>Esempio</p> C<pre><code>int a, b, c;   // dichiarazione di variabili intere\nc = b / a - 1; // espressione costituita da un solo termine costante\na = 4, b = 2;  // espressione costituita da 2 termini\nc = b % a;     // espressione costituita da un termine\n</code></pre> <p>In ogni caso il risultato \u00e8 un intero.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#compatibilita-tra-tipi","title":"Compatibilit\u00e0 tra tipi","text":"<p>Siano \\(T_1\\) e \\(T_2\\) due tipi differenti. Variabili di tipo differente possono comparire in una stessa espressione? Generalmente s\u00ec, se il linguaggio di programmazione fornisce delle regole di conversione implicite tra i due tipi.</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/10_array/","title":"Array","text":""},{"location":"Anno_I/Programmazione/10_array/#dati-e-tipi-strutturati","title":"Dati e tipi strutturati","text":"<p>I dati strutturati sono aggregati di dati elementari, come vettori, matrici, dizionari, code, liste, pile, etc.</p> <p>I tipi strutturati possono essere costruiti da dei tipi costituenti che sono gi\u00e0 definiti. Gli elementi del dominio di un tipo di dato strutturato sono ottenuti aggregando gli elementi e/o le componenti, appartenenti ai domini dei tipi costituenti.</p>"},{"location":"Anno_I/Programmazione/10_array/#strutture-dati","title":"Strutture dati","text":"<p>Una struttura dati \u00e8 costituita da un insieme di componenti sui quelli sono definiti un insieme di operatori per: selezionare, cancellare, aggiungere, etc. un componente.</p>"},{"location":"Anno_I/Programmazione/10_array/#linearita","title":"Linearit\u00e0","text":"<p>Le strutture dati possono essere lineari, ovvero la struttura pu\u00f2 essere vista come una sequenza di dati in cui \u00e8 possibile individuare la \\(1^\\circ\\) componente, la \\(2^\\circ\\) componente e cos\u00ec via fino ad esaurire la lunghezza della sequenza, come ad esempio i vettori.</p> <p>Le strutture dati possono essere anche non lineari, come ad esempio una matrice.</p>"},{"location":"Anno_I/Programmazione/10_array/#gli-array","title":"Gli array","text":"<p>L\u2019array \u00e8 una struttura dati omogenea, cio\u00e8 costituita da componenti dello stesso tipo, che viene detto tipo base. L\u2019array \u00e8 una struttura ad accesso casuale, tutte le componenti possono essere selezionate a caso, nello stesso tempo, mediante un indice.</p> <p>Una variabile array \u00e8 individuata da un unico identificatore. Ogni componente \u00e8 selezionata mediante un indice.</p> <p>Array monodimensionale: un array ad una dimensione \u00e8 costituito da un insieme finito di elementi omogenei, in corrispondenza biunivoca con un insieme di indici.</p> <p>Array - dichiarazione \u2022 Nei linguaggi di alto livello \u00e8 necessario dichiarare: \u2013 Il tipo delle componenti o tipo base (pu\u00f2 essere semplice o strutturato) \u2013 Il numero delle componenti (costante o variabile) \u2013 Il tipo dell\u2019indice \u2022 Nel linguaggio C l\u2019indice deve essere un intero e variare nel dominio [0, n-1] se n \u00e8 il numero delle componenti</p> <p>Esempio in C</p> C<pre><code>#define DIM 100; // numero di elementi del vettore\n</code></pre> <p>int a[DIM]; // dichiarazione del vettore int i; // dichiarazione dell\u2019indice \u2022 In C e in Pascal non esiste il tipo array, ma la possibilit\u00e0 di costruirlo aggregando componenti omogenee \u2022 Gli operatori che si possono applicare sono soltanto quelli relativi al tipo delle componenti</p> <p>Array \u2013 selezione di una componente \u2022 Sia x un array di n elementi \u2013 Selezione: la selezione di una componente \u00e8 possibile mediante il nome della variabile array ed un valore dell\u2019indice x[i] seleziona la componente di indice i (i varia tra 0 ed n-1)</p> <p>Array \u2013 aggiornamento di una componente \u2022 Sia x un array di n elementi \u2013 Aggiornamento: l\u2019aggiornamento del valore della componente di indice i si pu\u00f2 ottenere: \u2022 Mediante una istruzione di assegnazione: x[i] = v \u2022 Mediante la lettura di un valore: scanf(\u00ab%d\u00bb, &amp;x[i])</p> <p>Rappresentazione in memoria centrale \u2022 Una variabile array \u00e8 rappresentata in memoria centrale in modo sequenziale, cio\u00e8 le diverse componenti sono organizzate in locazioni di memoria contigue x[0] x[1] \u2026 \u2026 \u2026 \u2026 \u2026 x[n-1]</p> <p>Rappresentazione in memoria centrale \u2022 Sia x un array di n componenti (con n costante), e sia i l\u2019indice variabile da 0 a n-1 \u2022 Le componenti di x sono rappresentate in memoria a partire dall'indirizzo iniziale di x, ind(x), uguale all\u2019indirizzo della prima componente x[0] x[1] \u2026 \u2026 \u2026 \u2026 \u2026 x[n-1]</p> <p>Rappresentazione in memoria centrale \u2022 Sia L l\u2019occupazione di memoria in byte di una componente di x, dipendente dal tipo base \u2013 L\u2019occupazione di memoria della variabile x \u00e8 data da n*L \u2013 L\u2019indirizzo di un generico elemento i \u00e8 dato da ind(x[i]) = ind(x) + i*L x[0] x[1] \u2026 \u2026 \u2026 \u2026 \u2026 x[n-1]</p> <p>Strutture dati - omogeneit\u00e0 \u2022 Un linguaggio di programmazione offre diversi metodi di strutturazione dei dati: \u2013 Si possono aggregare dati dello stesso tipo, ad esempio in un array \u2013 Oppure di tipo diverso, ad esempio in un record</p> <p>Strutture dati - accesso \u2022 Si possono avere diversi metodi di accesso alle diverse componenti \u2013 Accesso diretto ad ogni componente \u2013 Accesso sequenziale ad ogni componente \u2013 Accesso diretto solo ad alcune componenti</p> <p>Strutture dati - dimensione \u2022 Strutture dati a dimensione fissa \u2013 il numero delle componenti non cambia \u2022 Strutture dati a dimensione variabile - il numero delle componenti \u00e8 variabile</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/esercizi/10-08-21/","title":"Esercizi del 08/10/2021","text":""},{"location":"Anno_I/Programmazione/esercizi/10-08-21/#esercizio-1-somma-di-due-numeri","title":"Esercizio 1 \u2013 Somma di due numeri","text":"<p>Dati due numeri interi \\(a, b\\), calcolarne la somma. Non \u00e8 accettabile come soluzione \\(a + b\\).</p> <p>Prendiamo, ad esempio, due numeri \\(5, 7\\). Siamo in grado di sommare questi due numeri utilizzando, ad esempio, le dita della mano e il risultato \u00e8 \\(12\\). Come \u00e8 stato ottenuto questo risultato? Incrementando di uno, tante volte il primo numero quante volte \u00e8 il secondo numero, ovvero \\(5 + 1 + \\cdots + 1\\).</p> <p>Il problema \u00e8 stato appena risolto, \u00e8 ora necessario descriverlo in modo tale che chiunque sia in grado di comprendere le operazioni che sono state appena effettuate, dunque:</p> Somma, v1<pre><code>Prendere il valore di a\nPrendere il valore di b\nIncrementare a di 1\nDecrementare b di 1\nSE b &gt; 0 ANDARE a 3\nrisultato := a\n</code></pre> <p>Il precedente \u00e8 un possibile metodo di risoluzione. \u00c8 necessario notare che la parola-chiave <code>ANDARE</code> \u00e8 un termine bandito. Bisogna scrivere questa soluzione in maniera differente.</p> <p>Cosa accadrebbe nel caso in cui \\(a, b \\geq 0\\)?</p> <p>Cambiare il valore di \\(a\\) non fa differenza, ma cambiando il valore di \\(b\\) la soluzione potrebbe essere errata e quindi la procedura restituirebbe un risultato diverso da quello atteso.</p> <p>Quindi:</p> Somma, v2<pre><code>Prendere il valore di a\nPrendere il valore di b\nSE b = 0 ANDARE a 7\nIncrementare a di 1\nDecrementare b di 1\nSE b &gt; 0 ANDARE a 4\nrisultato := a\n</code></pre> <p>Anche questo procedimento non \u00e8 scritto correttamente dato l'uso di <code>ANDARE</code>.</p> <p>Cosa succederebbe se \\(b &lt; 0\\)?</p> <p>La procedura non restituirebbe alcun risultato.</p> <p>Ogni vincolo specificato nei dati va sempre controllato e non va mai dato per scontato.</p> <p>\u00c8 necessario scrivere una procedura che non contenga alcun salto arbitrario, tenendo sempre conto del fatto che le operazioni vengono eseguite dall'alto verso il basso. Per effettuare dei salti, questi devono essere controllati da delle condizioni specifiche che vedremo in seguito.</p> <p>Questa soluzione \u00e8, per ora, accettabile. Una volta visto come effettuare dei salti in maniera controllata, non lo sar\u00e0 pi\u00f9.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-08-21/#esercizio-2-conversione-da-binario-a-decimale","title":"Esercizio 2 \u2013 Conversione da binario a decimale","text":"<p>Dato un numero in base binaria \\(a_{2}\\), convertire lo stesso in base decimale \\(a_{10}\\). Dunque:</p> Conversione, v1<pre><code>Prendere la prima cifra di a\u2082\nMoltiplicare questa per 2 elevato alla posizione della cifra\n</code></pre> <p>Non \u00e8 possibile scrivere <code>ANDARE a 1</code>, tantomeno di prendere la penultima cifra poich\u00e9 la lunghezza del numero non \u00e8 nota.</p> <p>\u00c8 necessario utilizzare un contatore il cui valore venga incrementato di uno dopo ogni iterazione. Poich\u00e9 non conosciamo la lunghezza del numero, \u00e8 necessario esplicitare quest'ultima tramite altri mezzi, dunque:</p> Conversione, v2<pre><code>p := 0\nPrendere la cifra di a\u2082 in posizione p\nMoltiplicare questa per 2^p\nIncrementare il valore di p di 1\nANDARE a 2\n</code></pre> <p>Nonostante l'utilizzo del contatore <code>p</code>, questa soluzione non \u00e8 funzionale. Come \u00e8 possibile capire quando fermarsi? Ovviamente quando terminano le cifre, ma come lo si pu\u00f2 determinare? Bisogna inserire un controllo.</p> Conversione, v3<pre><code>p := 0\nPrendere la cifra di a\u2082 in posizione p\nMoltiplicare questa per 2^p\nIncrementare il valore di p di 1\nSE p &lt; C ANDARE a 2\n</code></pre> <p>Dove \\(C\\) indica la lunghezza di \\(a_{2}\\).</p> <p>Questa procedura rende l'idea di come risolvere il problema, ma non \u00e8 ancora corretta poich\u00e9 bisogna sommare le cifre ottenute al risultato finale.</p> Conversione, v4<pre><code>p := 0\nPrendere la cifra di a\u2082 in posizione p\nMoltiplicare questa per 2^p\nSommare questo valore al risultato\nIncrementare il valore di p di 1\nSE p &lt; C ANDARE a 2\n</code></pre> <p>Sono spesso necessarie delle informazioni che il problema non fornisce e spetta a chi trova la soluzione individuarle. Ad esempio, se sono presenti delle sequenze di simboli e/o di numeri, \u00e8 necessario conoscere la lunghezza degli stessi, anche se la traccia non lo esplicita.</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/esercizi/10-14-21/","title":"Esercizio del 14/10/2021","text":"<p>Dati due insiemi di elementi \\(I_{1}\\) e \\(I_{2}\\), di cardinalit\u00e0 rispettivamente \\(n, m\\), scrivere un algoritmo in grado di individuare gli elementi comuni ai due insiemi.</p> <p>Iniziamo ad elencare i dati.</p> INPUT \\(I_{1}\\) \u2013 insieme di elementi, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_{1}\\), appartiene a \\(\\N^\\ast\\) \\(I_{2}\\) \u2013 insieme di elementi, insieme \\(m\\) \u2013 cardinalit\u00e0 di \\(I_{2}\\), appartiene a \\(\\N^\\ast\\) OUTPUT \\(I_{3}\\) \u2013 insieme di elementi comuni a \\(I_{1}\\) e \\(I_{2}\\) <p>Consideriamo ad esempio \\(I_{1} = \\{3, 12, 7, 41, 35\\}\\) e \\(I_{2} = \\{8, 5, 62, 7, 27, 56\\}\\), ne risulta che \\(I_{3} = \\{7\\}\\). Che procedimento \u00e8 stato utilizzato?</p> Bozza<pre><code>Prendere ogni elemento di I1\nControllare se \u00e8 presente in I2\nSe \u00e8 presente, aggiungerlo a I3\n</code></pre> <p>Non \u00e8 un algoritmo, ma il procedimento \u00e8 sostanzialmente questo. Vediamolo:</p> Algoritmo, v1<pre><code>p := 1\nMENTRE (p &lt;= n)\n  q := 1\n  MENTRE (q &lt;= m)\n    SE (elemento p-esimo di I1 = elemento q-esimo di I2)\n      ALLORA inserire l'elemento p-esimo di I1 in I3\n    FINE\n    q := q + 1\n  FINE\n  p := p + 1\nFINE\n</code></pre> <p>Questa \u00e8 una possibile soluzione. Iteriamo all'interno del primo insieme e confrontiamo il primo elemento di questo con tutti gli elementi dell'altro insieme, e cos\u00ec via. C'\u00e8 tuttavia un errore, non viene specificato l'inserimento dell'elemento nell'insieme \\(I_{3}\\). Inoltre l'algoritmo potrebbe essere reso pi\u00f9 efficiente interrompendo il ciclo dopo aver trovato il numero in comune. Dunque</p> Algoritmo, v2<pre><code>p := 1\nr := 1\nMENTRE (p &lt;= n)\n  q := 1\n  MENTRE (q &lt;= m)\n    SE (elemento p-esimo di I1 = elemento q-esimo di I2)\n      ALLORA elemento r-esimo di I3 := elemento p-esimo di I1\n      r := r + 1\n    FINE\n    q := q + 1\n  FINE\n  p := p + 1\nFINE\n</code></pre> <p>Questo algoritmo per\u00f2 non funziona tutte le volte poich\u00e9 nel caso in cui l'insieme \\(I_{3}\\) sia vuoto, questo dovrebbe essere \\(I_{3} = \\emptyset\\) ma il valore di \\(r\\) parte da uno e non da zero. Bisogna tener conto del fatto che la cardinalit\u00e0 \u00e8 maggiorata di uno nel momento in cui sia necessario dare la soluzione, dunque <code>r - 1 = 0</code>, allora \\(I_{3} = \\emptyset\\).</p> <p>Dopo aver letto la sezione sull'Algebra Booleana, \u00e8 possibile scrivere un algoritmo migliore, che utilizza un valore booleano che indica se l'elemento \u00e8 presente o meno nell'insieme \\(I_{2}\\).</p> Algoritmo, v3<pre><code>p := 1\nr := 1\ntrovato := FALSO\nMENTRE (p &lt;= n) \u2227 (trovato = FALSO)\n  q := 1\n  MENTRE (q &lt;= m)\n    SE (elemento p-esimo di I1 = elemento q-esimo di I2)\n      ALLORA elemento r-esimo di I3 := elemento p-esimo di I1\n      trovato := VERO\n      r := r + 1\n    FINE\n    q := q + 1\n  FINE\n  p := p + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-14-21/#controllo","title":"Controllo","text":"<p>Controlliamo che l'algoritmo sia corretto. Siano \\(I_{1} = \\set{5, 10, 31}\\) e \\(I_{2} = \\set{7, 10}\\), dunque \\(I_{3} = \\set{10}\\). Inoltre \\(n = 3\\) e \\(m = 2\\).</p> Controllo<pre><code>I1 = {5, 10, 31}    n = 3\nI2 = {7, 10}        m = 2\nr -&gt; 1; 2;\np -&gt; 1; 2; 3; 4;\nq -&gt; 1; 2; 3; / 1; 2; 3; / 1; 2; 3; /\ntrovato -&gt; FALSO\n</code></pre> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/esercizi/10-21-21/","title":"Esercizi del 21/10/2021","text":""},{"location":"Anno_I/Programmazione/esercizi/10-21-21/#esercizio-1","title":"Esercizio 1","text":"<p>Leggere in input due interi \\(n, k &gt; 0\\) e calcolare i primi \\(n\\) multipli di \\(k\\). Realizzare l'algoritmo in pseudo-codice, considerando i controlli sull'input.</p> <p>Esempio:</p> <p>Dati \\(n = 3\\) e \\(k = 4\\), i primi \\(3\\) multipli di \\(4\\) sono \\(4, 8, 12\\).</p> INPUT: \\(n\\) \u2013 numero di multipli di \\(k\\) da calcolare, \\(n \\in \\N^\\ast\\) \\(k\\) \u2013 numero di cui calcolare gli \\(n\\) multipli, \\(n \\in \\N^\\ast\\) OUTPUT: multipli \u2013 Insieme di \\(n\\) multipli di \\(k\\), insieme di naturali, cardinalit\u00e0 \\(n\\). <p>ALGORITMO</p> Bozza<pre><code>leggere n\nleggere k\ncontrollare n e k   &gt;&gt; si pu\u00f2 operare in due modi\ncalcolare i multipli\n</code></pre> <p>Il precedente non \u00e8 un algoritmo ma, come sempre, un'idea di come risolvere il problema. Il controllo, come accennato, \u00e8 possibile effettuarlo in due modi.</p> Primo modoSecondo modo Bozza, v2a<pre><code>leggere n\nleggere k\nSE (n e k soddisfano i vincoli)\n  ALLORA calcolare i multipli\nFINE\n</code></pre> Bozza, v2b<pre><code>leggere n\nleggere k\nSE (n e k soddisfano i vincoli)\n  ALLORA ANDARE a 1\n  ALTRIMENTI calcolare i multipli\nFINE\n</code></pre> <p>\u00c8 presente l'istruzione <code>ANDARE</code>, ma questa \u00e8 solo una bozza, verr\u00e0 rimossa nell'algoritmo.</p> <p>Bisogna rendere chiari i vincoli, magari con un messaggio che li specifichi o che chiarisca il comportamento aspettato. Poich\u00e9 vengono richiesti due valori positivi dando in input, ad esempio, \\(5, -1\\) l'algoritmo tornerebbe al primo punto e richiederebbe entrambi i numeri, nonostante il primo fosse corretto. Sarebbe quindi consigliato controllare ogni dato separatamente.</p> Bozza, v2b.1<pre><code>leggere n\nSE (n non soddisfa i vincoli)\n  ALLORA TORNARE a 1\nFINE\nleggere k\nSE (k non soddisfa i vincoli)\n  ALLORA TORNARE a 5\nFINE\ncalcolare i multipli\n</code></pre> <p>In questo modo vengono evitate operazioni inutili. Dunque, traducendo:</p> Algoritmo, v1<pre><code>n := 0\nMENTRE (n &lt; 0)\n  leggere n\nFINE\n\nk := 0\nMENTRE (k &lt; 0)\n  leggere k\nFINE\ncalcolare i multipli\n</code></pre> <p>Con questa sintassi l'algoritmo non procede finch\u00e9 non riceve i dati corretti in input, per questo \u00e8 possibile aggiungere un messaggio che renda noto che il valore di \\(n\\) o di \\(k\\) \u00e8 errato.</p> <p>Una possibile alternativa sarebbe:</p> Algoritmo, v1a<pre><code>ESEGUI\n  scrivere messaggio\n  leggere n\nFINCH\u00c9 (n &lt;= 0)\nFINE\n\nESEGUI\n  scrivere messaggio\n  leggere k\nFINCH\u00c9 (k &lt;= 0)\nFINE\n\ncalcolare i multipli\n</code></pre> <p>Dal punto di vista dell'efficienza, questo algoritmo \u00e8 migliore. Inoltre rimuove il problema di assegnare dei valori sia ad \\(n\\) che a \\(k\\). Entrambe le soluzioni sono valide, ma in questo caso \u00e8 preferibile utilizzare il blocco <code>ESEGUI [...] FINCH\u00c9</code>.</p> <p>Dopo aver migliorato la struttura di controllo, ora \u00e8 necessario specificare cosa significhi <code>calcolare i multipli</code>. Bisogna calcolare \\(n\\) volte i multipli di \\(k\\) e poich\u00e9 \u00e8 presente una ripetizione \u00e8 necessario usare un'iterazione. Dunque:</p> Calcolo dei multipli<pre><code>p := 1\nMENTRE (p &lt;= n)\n  elemento p-esimo di multipli := k * p\n  p := p + 1\nFINE\n</code></pre> <p>Attenzione</p> <p>una cosa che non \u00e8 possibile fare \u00e8 la seguente</p> Text Only<pre><code>multipli := k * p\n</code></pre> <p>poich\u00e9 <code>multipli</code> \u00e8 un insieme e non un singolo elemento. Questo significa che bisogna assegnare un valore in una posizione specifica.</p> <p>Bisogna ora specificare il messaggio da mostrare nel caso in cui vengano inseriti dei dati non corretti.</p> <p>Nel C sono presenti funzioni che permettono di stampare a video ci\u00f2 che si desidera (<code>printf()</code>), nello pseudo-codice scriveremo <code>StampareAVideo()</code>, quindi, ad esempio:</p> Text Only<pre><code>StampareAVideo(\"Inserire il numero di multipli da calcolare\")\n</code></pre> <p>Leggere in input</p> <p>Per leggere dei dati in input, il C offre la funzione <code>scanf()</code>, in pseudo-codice useremo <code>LeggereDaTastiera()</code>. In questo modo il programma si blocca finch\u00e9 non riceve un dato in input.</p> <p>Mettendo tutto insieme si ottiene:</p> ALgoritmo<pre><code>ESEGUI\n  StampareAVideo(\"Inserire il numero di multipli da calcolare, maggiore di 0\")\n  n := LeggereDaTastiera()\nFINCH\u00c9 (n &lt;= 0)\nFINE\n\nESEGUI\n  StampareAVideo(\"Inserire il numero di cui calcolare i multipli, maggiore di 0\")\n  k := LeggereDaTastiera()\nFINCH\u00c9 (k &lt;= 0)\nFINE\n\np := 1\nMENTRE (p &lt;= n)\n  elemento p-esimo di multipli := k * p\n  p := p + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-21-21/#esercizio-2","title":"Esercizio 2","text":"<p>Leggere in input due interi \\(n,k  &gt; 0\\) e verificare se \\(n\\) \u00e8 divisibile per \\(k\\). Realizzare l\u2019algoritmo in pseudo-codice, considerando i controlli sugli input.</p> <p>Esempio: Dati \\(n = 3\\) e \\(k = 4\\), \\(n\\) non \u00e8 divisibile per \\(k\\).</p> INPUT: \\(n\\) - numero di cui verificare la divisibilit\u00e0 per \\(k\\), \\(n \\in \\N^\\ast\\) \\(k\\) - numero di cui verificare se sia divisore di \\(n\\), \\(k \\in \\N^\\ast\\) OUTPUT: divisibile - indica se \\(n\\) sia divisibile (vero) o meno (falso) per \\(k\\), booleano <p>La prima bozza di questo algoritmo \u00e8 molto simile a quella del'algoritmo dell'esercizio precedente, l'unica differenza consiste nel verificare la divisibilit\u00e0 anzich\u00e9 calcolare i multipli.</p> Algoritmo, v1<pre><code>SE (n modulo k = 0)\n  ALLORA divisibile := vero\n  ALTRIMENTI divisibile := falso\nFINE\n</code></pre> <p>Nel caso in cui il resto (ovvero il modulo) sia zero, allora \\(n\\) \u00e8 divisibile per \\(k\\). Ma com'\u00e8 di preciso definita l'operazione <code>modulo</code>? Va specificata.</p> <p>\u00c8 possibile risolvere il problema senza utilizzare l'operazione <code>modulo</code> facendo uso di sottrazioni ripetute. Nel caso in cui il risultato sia zero allora non \u00e8 presente resto, se invece il risultato fosse maggiore di zero, allora il resto \u00e8 presente.</p> Algoritmo, v2<pre><code>MENTRE (n &gt;= k)\n  n := n - k\nFINE\n\nSE (n = 0)\n  ALLORA divisibile := vero\n  ALTRIMENTI divisibile := falso\nFINE\n</code></pre> <p>In questo algoritmo si va a perdere il valore di \\(n\\) e sarebbe meglio preservarlo utilizzando una variabile come <code>temp</code>.</p> <p>\u00c8 importante notare come la prima versione dell'algoritmo nel caso in cui venga tradotto in un linguaggio che non possegga l'operazione <code>modulo</code>, l'esecutore non saprebbe come fare. Dunque o si risolve il problema in maniera differente, oppure si specifica cosa fa l'operazione <code>modulo</code>.</p> <p>Abbiamo dato per scontato che esista una funzione</p> Text Only<pre><code>r := modulo(n, k)\n</code></pre> <p>il che non \u00e8 sempre vero ed \u00e8 quindi un errore.</p> <p>\ufeff</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/","title":"Esercizio del 28/10/21","text":"<p>Letti in input due insiemi di elementi \\(I_{1}\\) e \\(I_{2}\\), di cardinalit\u00e0 rispettivamente \\(n\\) e \\(m\\), scrivere un algoritmo in grado di:</p> <ul> <li>individuare gli elementi comuni ai due insiemi;</li> <li>unire i due insiemi in un unico insieme;</li> <li>calcolare la differenza tra i due insiemi;</li> <li>stampare a video tutti i risultati.</li> </ul> <p>Considerare i controlli sui dati di input. Realizzare come prima cosa la decomposizione funzionale.</p> <p>Iniziare immediatamente con lo pseudo-codice potrebbe essere controproducente, dunque analizziamo prima le macro-operazioni.</p> <p>Come prima cosa \u00e8 necessario ricevere gli insiemi in input, dunque</p> Text Only<pre><code>leggere insieme I1\nleggere insieme I2\n</code></pre> <p>Successivamente sono presenti le operazioni sugli insiemi, quindi:</p> Text Only<pre><code>calcolare I1 \u2229 I2\ncalcolare I1 \u222a I2\ncalcolare I1 \u2216 I2\n</code></pre> <p>e, infine:</p> Text Only<pre><code>stampare i risultati\n</code></pre> <p>Si tratta di una sequenza di azioni. Quelle appena elencate non sono altro che delle sotto-operazioni dell'operazione principale.</p> <p>Tralasciando ancora lo pseudo-codice, leggere <code>leggere insieme [...]</code> fa immediatamente pensare a <code>LeggereDaTastiera()</code>, ma per fare questo \u00e8 necessaria la cardinalit\u00e0 dell'insieme, dopodich\u00e9 i valori dell'insieme e infine verificare i vincoli sui dati. Quindi le operazioni distinte da effettuare sono quattro.</p> <p>Analizzando ora <code>stampare i risultati</code>, bisogna stampare gli insiemi Unione, Intersezione e Differenza, vedremo dopo come.</p> <p>Per quanto riguarda le operazioni sugli insiemi, il calcolo dell'intersezione \u00e8 stato visto precedentemente. Il calcolo dell'unione \u00e8 molto simile, bisogna prima inserire tutti gli elementi del primo insieme e poi controllare quali elementi del primo sono presenti nel secondo e se non \u00e8 presente, aggiungerlo. Anche la differenza \u00e8 simile in quanto si effettua una ricerca.</p> <p>L'algoritmo va ora risolto per ogni operazione separata, ogni operazione ha un suo algoritmo separato delle altre.</p> <p>Ora che son state analizzate brevemente le varie operazioni, possiamo creare un albero di lavoro:</p> TestoDiagramma Albero di lavoro<pre><code>Operazioni su insiemi\n  Leggere insieme I1\n    leggere cardinalit\u00e0 n di I1\n    verificare i vincoli di n\n    leggere i valori di I1\n    verificare i vincoli di I1\n  Leggere insieme I2\n    leggere cardinalit\u00e0 m di I2\n    verificare i vincoli di m\n    leggere i valori di I2\n    verificare i vincoli di I2\n  Calcolare intersezione\n    ricercare elemento in insieme\n  Calcolare unione\n    ricercare elemento in insieme\n  Calcolare Differenza\n    ricercare elemento in insieme\n  Stampare i risultati\n    stampare l'insieme intersezione\n    stampare l'insieme unione\n    stampare l'insieme differenza\n</code></pre> <pre><code>flowchart LR;\n  %% main node\n  ops(Operazioni su insiemi);\n\n  %%% secondary nodes\n  rI1(\"leggere l'insieme I\u2081\"); rI2(\"leggere l'insieme I\u2082\");\n  cc(calcolare l'insieme);\n  pp(stampare i risultati); ppi(stampare l'insieme);\n\n  %%%% tertiary nodes\n  rcI1(leggere la cardinalit\u00e0 n); rcI2(leggere la cardinalit\u00e0 m);\n  vvn(verificare i vincoli di n); vvm(verificare i vincoli di m);\n  rvI1(\"leggere i valori di I\u2081\"); rvI2(\"leggere i valori di I\u2082\");\n  vvI1(\"verificare i vincoli di I\u2081\"); vvI2(\"verificare i vincoli di I\u2082\");\n\n  cint(intersezione); cuni(unione); cdif(differenza);\n  pint(intersezione); puni(unione); pdif(differenza);\n\n  %% from main\n  ops ---&gt; rI1 &amp; rI2 &amp; cc &amp; pp;\n\n  %%% from secondary\n  rI1 --&gt; rcI1 --&gt; vvn;\n  rI1 --&gt; rvI1 --&gt; vvI1;\n\n  rI2 --&gt; rcI2 --&gt; vvm;\n  rI2 --&gt; rvI2 --&gt; vvI2;\n\n  cc --&gt; cint &amp; cuni &amp; cdif;\n\n  pp ---&gt; ppi --&gt; pint &amp; puni &amp; pdif;</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#operazioni-sugli-insiemi","title":"Operazioni sugli insiemi","text":"<p>Rappresenta il problema nella sua interezza.</p> INPUT: \\(I_{1}\\) \u2013 primo insieme di \\(n\\) elementi, insieme \\(I_{2}\\) \u2013 secondo insieme di \\(m\\) elementi, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_{1}\\), con \\(n \\in \\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_{2}\\), con \\(m \\in \\N^\\ast\\) OUTPUT: <code>intersezione</code> \u2013 insieme di elementi comuni a \\(I_{1}\\) e \\(I_{2}\\), insieme <code>unione</code> \u2013 insieme di elementi di \\(I_{1}\\) e \\(I_{2}\\) distinti, insieme <code>differenza</code> \u2013 insieme di elementi di \\(I_{1}\\) non comuni a \\(I_{2}\\), insieme Bozza<pre><code>leggere insieme I1\nleggere insieme I2\ncalcolare intersezione\ncalcolare unione\ncalcolare differenza\nstampare risultati\n</code></pre> <p>Questa \u00e8 un'idea di come l'algoritmo debba funzionare. Poich\u00e9 diventi un vero algoritmo andrebbe scritto in pseudo-codice.</p> <p>ALGORITMO:</p> <p>La lettura degli insiemi, come le altre operazioni saranno delle funzioni:</p> Operazioni<pre><code>n := LeggereCardinalit\u00e0()\nI1 := LeggereInsieme(n)\nm := LeggereCardinalit\u00e0()\nI2 := LeggereInsieme(m)\n\nIntersezione := CalcolareIntersezione(I1, n, I2, m)\nUnione := CalcolareUnione(I1, n, I2, m)\nDifferenza := CalcolareDifferenza(I1, n, I2, m)\n\nStampareRisultati(\n  Intersezione, cardinalit\u00e0Intersezione,\n  Differenza, cardinalit\u00e0Differenza,\n  Unione, cardinalit\u00e0Unione,\n)\n</code></pre> <p>L'algoritmo non si discosta molto dall'albero di lavoro.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#leggere-cardinalita","title":"Leggere cardinalit\u00e0","text":"<p>Poich\u00e9 la cardinalit\u00e0 degli insiemi \u00e8 un dato continuamente utilizzato, \u00e8 necessario richiederlo in input.</p> INPUT: vuoto \u2013 non \u00e8 presente input OUTPUT: <code>cardinalit\u00e0</code> \u2013 numero di elementi di un insieme, naturale <p>ALGORITMO:</p> Text Only<pre><code>ESEGUI\n  StampareAVideo(\"Inserire il numero di elementi dell'insieme: \")\n  cardinalit\u00e0 := LeggereDaTastiera()\nFINCH\u00c9 (cardinalit\u00e0 &lt;= 0)\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#leggere-insieme","title":"Leggere insieme","text":"INPUT: <code>cardinalit\u00e0</code> \u2013 numero di elementi dell'insieme \\(I\\), appartiene a \\(\\N^\\ast\\) OUTPUT: \\(I\\) \u2013 insieme di elementi, insieme <p>ALGORITMO:</p> Text Only<pre><code>SE (cardinalit\u00e0 &gt; 0)\n  ALLORA leggere i valori di I\n  verificare i vincoli di I\n  ALTRIMENTI StampareAVideo(\"Il numero immesso \u00e8 negativo\")\nFINE\n</code></pre> <p>\u00c8 necessario dare la possibilit\u00e0 di controllare la cardinalit\u00e0 e, finch\u00e9 questa non sia corretta, l'algoritmo non produce risultato.</p> <p>Alcune di queste operazioni possono essere riscritte, ad esempio:</p> Text Only<pre><code>cardinalit\u00e0 := LeggereCardinalit\u00e0()\nI := LeggereValoriInsieme(cardinalit\u00e0)\n</code></pre> <p>Per quanto riguarda la verifica dei vincoli, sarebbe meglio che questi vengano uniti alla lettura dei valori dell'insieme:</p> Text Only<pre><code>ESEGUI\n  I := LeggereValoriInsieme(cardinalit\u00e0)\n  verificato := VerificareVincoli(I)\nFINCH\u00c9 (verificato = FALSO)\nFINE\n</code></pre> <p>La precedente soluzione \u00e8 funzionale, per\u00f2 non risulta essere comoda per l'utente poich\u00e9 nel caso in cui anche un singolo valore sia errato, \u00e8 necessario reinserire anche gli altri.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#calcolare","title":"Calcolare","text":""},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#intersezione","title":"Intersezione","text":"INPUT: \\(I_{1}\\) \u2013 primo insieme di cui effettuare l'intersezione, insieme \\(I_{2}\\) \u2013 secondo insieme di cui effettuare l'intersezione, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_{1}\\), appartiene a \\(\\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_{2}\\), appartiene a \\(\\N^\\ast\\) OUTPUT: <code>intersezione</code> \u2013 insieme risultante dell'intersezione tra \\(I_{1}\\) e \\(I_{2}\\), insieme LAVORO: \\(p\\) \u2013 posizione degli elementi di \\(I_{1}\\), appartiene a \\(\\N^\\ast\\) \\(q\\) \u2013 posizione degli elementi di <code>intersezione</code>, appartiene a \\(\\N^\\ast\\) <code>trovato</code> \u2013 indica se un elemento \u00e8 presente in un insieme, booleano <p>ALGORITMO:</p> Text Only<pre><code>q := 1\np := 1\nMENTRE ( p &lt;= n)\n  trovato := RicercaElemento(p-esimo elemento di I1, I2, m)\n  SE (trovato = VERO)\n    ALLORA q-esimo elemento di intersezione := p-esimo elemento di I1\n    q := q + 1\n  FINE\n  p := p + 1\nFINE\n\n&gt;&gt; per rappresentare la fine dell'insieme\n&gt;&gt; q-esimo elemento di intersezione := VALORE_FINALE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#differenza","title":"Differenza","text":"INPUT: \\(I_{1}\\) \u2013 primo insieme di cui effettuare l'intersezione, insieme \\(I_{2}\\) \u2013 secondo insieme di cui effettuare l'intersezione, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_{1}\\), appartiene a \\(\\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_{2}\\), appartiene a \\(\\N^\\ast\\) OUTPUT: <code>differenza</code> \u2013 insieme risultante dell'intersezione tra \\(I_{1}\\) e \\(I_{2}\\), insieme LAVORO: \\(p\\) \u2013 posizione degli elementi di \\(I_{1}\\), appartiene a \\(\\N^\\ast\\) \\(q\\) \u2013 posizione degli elementi di <code>differenza</code>, appartiene a \\(\\N^\\ast\\) <code>trovato</code> \u2013 indica se un elemento \u00e8 presente in un insieme, booleano <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nq := 1\nMENTRE (p &lt;= n)\n  trovato := RicercareElemento(p-esimo elemento di I1, I2, m)\n  SE (Trovato=FALSO)\n    ALLORA q-esimo elemento di differenza := p-esimo elemento di I1\n    q := q+1\n  FINE\n  p := p+1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#unione","title":"Unione","text":"INPUT: \\(I_{1}\\) \u2013 primo insieme di cui effettuare l'intersezione, insieme \\(I_{2}\\) \u2013 secondo insieme di cui effettuare l'intersezione, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_{1}\\), appartiene a \\(\\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_{2}\\), appartiene a \\(\\N^\\ast\\) OUTPUT: <code>unione</code> \u2013 insieme risultante dell'intersezione tra \\(I_{1}\\) e \\(I_{2}\\), insieme LAVORO: \\(p\\) \u2013 posizione degli elementi di \\(I_{1}\\), appartiene a \\(\\N^\\ast\\) \\(q\\) \u2013 posizione degli elementi di <code>unione</code>, appartiene a \\(\\N^\\ast\\) <code>trovato</code> \u2013 indica se un elemento \u00e8 presente in un insieme, booleano <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nMENTRE (p &lt;= n)\n  p-esimo elemento di unione := p-esimo elemento di I1\n  p := p+1\nFINE\n\nq := 1\nMENTRE (q &lt;= m)\n  trovato := RicercareElemento(p-esimo elemento di I2, Unione, p - 1)\n  SE (trovato = FALSO)\n    ALLORA p-esimo elemento di unione := p-esimo elemento di I2\n    p := p + 1\n  FINE\n  q := q + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#stampare-risultati","title":"Stampare risultati","text":"INPUT: <code>intersezione</code> \u2013 insieme di elementi comuni a \\(I_{1}\\) e \\(I_{2}\\), insieme <code>differenza</code> \u2013 insieme di elementi di \\(I_{1}\\) non comuni a \\(I_{2}\\), insieme <code>unione</code> \u2013 insieme di elementi di \\(I_{1}\\) e \\(I_{2}\\) distinti, insieme <code>cardinalit\u00e0Intersezione</code> \u2013 numero di elementi di <code>intersezione</code>, appartiene a \\(\\N^\\ast\\) <code>cardinalit\u00e0Differenza</code> \u2013 numero di elementi di <code>differenza</code>, appartiene a \\(\\N^\\ast\\) <code>cardinalit\u00e0Unione</code> \u2013 numero di elementi di <code>unione</code>, appartiene a \\(\\N^\\ast\\) OUTPUT: nullo \u2013 non \u00e8 previsto output <p>ALGORITMO:</p> Algoritmo 1<pre><code>p := 1\nMENTRE (p &lt; cardinalit\u00e0Intersezione)\n  StampareAVideo(p-esimo elemento di intersezione)\n  p := p + 1\nFINE\n\np := 1\nMENTRE (p &lt; cardinalit\u00e0Differenza)\n  StampareAVideo(p-esimo elemento di differenza)\n  p := p + 1\nFINE\n\np := 1\nMENTRE (p &lt; cardinalit\u00e0Unione)\n  StampareAVideo(p-esimo elemento di unione)\n  p := p + 1\nFINE\n</code></pre> <p>Questa soluzione \u00e8 certamente funzionale ma risulta essere estremamente brutta. L'alternativa pi\u00f9 piacevole \u00e8 la seguente:</p> Algoritmo 2<pre><code>StampareInsieme(Intersezione, cardinalit\u00e0Intersezione)\nStampareInsieme(Differenza, cardinalit\u00e0Differenza)\nStampareInsieme(Unione, cardinalit\u00e0Unione)\n</code></pre> <p>In questo modo introduciamo una nuova funzione, <code>StampareInsieme()</code>, la quale va specificata con le appropriate liste di input, output, etc. Quindi:</p> INPUT: \\(I\\) \u2013 insieme di elementi da stampare, insieme <code>cardinalit\u00e0</code> \u2013 numero di elementi dell'insieme da stampare, appartiene a \\(\\N^\\ast\\) OUTPUT: nullo \u2013 non \u00e8 previsto output LAVORO: \\(p\\) \u2013 posizione degli elementi dell'insieme \\(I\\), appartiene a \\(\\N^\\ast\\) <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nMENTRE (p &lt; cardinalit\u00e0)\n  StampareAVideo(p-esimo elemento di I)\n  p := p + 1\nFINE\n</code></pre> <p>In questo modo, anzich\u00e9 avere tre cicli <code>MENTRE</code> diversi, utilizziamo una funzione, che risulta essere una soluzione pi\u00f9 elegante.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#calcolo-della-cardinalita","title":"Calcolo della cardinalit\u00e0","text":"<p>Per ovviare al problema di chiedere continuamente come dato di input la cardinalit\u00e0 di ogni insieme, sarebbe possibile calcolarla.</p> INPUT: \\(I\\) \u2013 insieme di elementi di cui calcolare la cardinalit\u00e0, insieme OUTPUT: \\(C\\) \u2013 cardinalit\u00e0 dell'insieme \\(I\\), appartiene a \\(\\N^\\ast\\) <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nMENTRE (p-esimo elemento di I != VALORE_FINALE)\n  p := p + 1\nFINE\nC := p - 1\n</code></pre> <p>Ma cos'\u00e8 <code>VALORE_FINALE</code>? Si tratta di un elemento di controllo che non contribuisce ad aumentare la cardinalit\u00e0 dell'insieme ma permette all'algoritmo di terminare. Un insieme potrebbe dunque essere il seguente:</p> Text Only<pre><code>I = {1, 3, 7, 9 VALORE_FINALE}\n</code></pre> <p>In questo modo \u00e8 possibile calcolare la cardinalit\u00e0 di un insieme, avendo la certezza di fermare l'iterazione al momento corretto.</p> <p>\u00c8 importante notare che, se la cardinalit\u00e0 viene utilizzata molte volte, risulta pi\u00f9 efficiente1 o conservare il valore della stessa o chiederla in input.</p> <p>\ufeff</p> <ol> <li> <p>Pi\u00f9 efficiente dal punto di vista computazionale.\u00a0\u21a9</p> </li> </ol>"}]}