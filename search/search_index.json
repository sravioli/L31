{"config":{"lang":["it","en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Raccolta di appunti, file, slides, etc. relativi al corso di Informatica L31, dell'Universit\u00e0 di Bari \"Aldo Moro\".</p> <p>Attenzione</p> <p>Gli appunti sono in fase di stesura e cambiano continuamente.</p>"},{"location":"#utilizzo-offline","title":"Utilizzo offline","text":"<p>Per poter sfogliare gli appunti offline bisogna innanzitutto clonare la repository dopodich\u00e9, utilizzando Mask<sup>1</sup>:</p> <pre><code>mask bootstrap &amp;&amp; mask build\n</code></pre> <p>Il sito sar\u00e0 presente nella cartella <code>./site/</code> e lo si pu\u00f2 sfogliare con un qualsiasi web browser aprendo il file <code>index.md</code>. La pagina visualizzata dovrebbe essere proprio questa.</p>"},{"location":"#come-contribuire","title":"Come contribuire","text":"<p>Per contribuire:</p> <ol> <li> <p>clonare la repository:</p>  Git GitHub CLI <pre><code>git clone https://github.com/sRavioli/L31.git\n</code></pre> <pre><code>gh repo clone sRavioli/L31\n</code></pre> </li> <li> <p>recarsi nella cartella (<code>cd L31</code>) e installare i pacchetti python    richiesti (richiesti: python e mask):</p> <pre><code>mask bootstrap\n</code></pre> </li> <li> <p>avviare il server:</p> <pre><code>mask serve --dirty\n</code></pre> <p>Verr\u00e0 fatto partire un server al link http://localhost:8000/L31 che ospiter\u00e0 gli appunti. L'opzione <code>--dirty</code> permette di avere dei tempi di caricamento pi\u00f9 brevi poich\u00e9 mkdocs compiler\u00e0 solo la pagina corrente. Per interrompere il server bisogna premere Ctrl+C.</p> </li> <li> <p>effettuare le modifiche;</p> </li> <li> <p>creare un nuovo ramo con  Git:</p> <pre><code>git checkout -b feat/nuova-feature\n</code></pre> <p>effettuare gli eventuali commit sullo stesso</p> <pre><code>git commit -m \"feat: add new feature\"\n</code></pre> <p>effettuare il push del nuovo ramo:</p> <pre><code>git push -u origin feat/nuova-feature\n</code></pre> </li> <li> <p>recarsi su  GitHub e aprire una pull request.</p> </li> </ol>"},{"location":"#keymaps","title":"Keymaps","text":"<p>Il sito possiede della mappature dei tasti personalizzate:</p> <ul> <li>H e L \u2013 naviga verso la pagina precedente e verso la successiva (se)   esistono);</li> <li>K e J \u2013 scorri verso l'alto e verso il basso;</li> <li>G e Shift+G \u2013 scorri verso l'inizio e verso la fine della pagina;</li> <li>Shift+K e Shift+J \u2013 naviga verso l'intestazione precedente e verso   l'intestazione successiva;</li> <li>Shift+H \u2013 torna alla pagina principale.</li> </ul> <ol> <li> <p>Nel caso in cui non sia possibile usare mask, \u00e8 possibile eseguire manualmente i due script. Bisogna aprire il file <code>maskfile.md</code>, e recarsi nelle sezioni <code>## bootstrap</code> e <code>## build</code> e eseguire i comandi l\u00ec presenti, esclusi i messaggi (<code>mask msg ... \"...\"</code>).\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/","title":"Appunti del primo anno","text":"<p>In questa sezione sono presenti gli appunti dei seguenti corsi:</p> <ul> <li>Programmazione;</li> <li>Linguaggi di Programmazione;</li> <li>Laboratorio_di_Informatica;</li> <li>Architettura degli Elaboratori e Sistemi Operativi.</li> </ul>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/","title":"Tipi di dato e la loro rappresentazione","text":""},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#il-bit","title":"Il bit","text":"<p>L'alfabeto del calcolatore costituito da due simboli: <code>0</code> e <code>1</code>.</p> <p>BIT</p> <p>\u00c8 l'unit\u00e0 elementare di informazione. La cifra binaria pu\u00f2 assumere solo due valori alternativi: <code>0</code> oppure <code>1</code>. Viene archiviato da un dispositivo digitale o un sistema fisico che esiste in uno di due possibili stati distinti.</p> Presenza Assenza Vero Falso <code>1</code> <code>0</code> \\(+\\) \\(-\\) S\u00ec No Favorevole Contrario Yang Ying Lisa Bart <p>Esempi</p> <ul> <li>i due stati stabili di un flip-flop;</li> <li>due posizioni di un interruttore elettrico;</li> <li>due distinte tensione o gli attuali livelli consentiti da un circuito;</li> <li>due distinti livelli di intensit\u00e0 della luce;</li> <li>due direzioni di magnetizzazione o di polarizzazione, ecc;</li> </ul>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#sequenze-di-bit","title":"Sequenze di bit","text":"<p>Per poter rappresentare un numero maggiore di informazione si usano sequenze di bit. Il processo che fa corrispondere a un dato reale una sequenza di bit prende il nome di codifica dell'informazione.</p> <p>Esempi</p> Esiti di un esameRappresentazione di otto colori <p>Ad esempio, un esame pu\u00f2 avere quattro possibili esiti. Quanti bit sono necessari per codificare tale informazione?</p> \\[     \\begin{array}{ c|l }         \\text{Voto} &amp; \\text{Bit}    \\\\ \\hline         \\text{Ottimo}        &amp; 0  0 \\\\         \\text{Discreto}      &amp; 0  1 \\\\         \\text{Sufficiente}   &amp; 1  0 \\\\         \\text{Insufficiente} &amp; 1  1 \\\\     \\end{array} \\] <p>Ad esempio, per la rappresentazione di otto colori:</p> \\[     \\begin{array}{ l|l }         \\text{Colore} &amp; \\text{Bit} \\\\ \\hline         \\text{Rosso}  &amp; 000        \\\\         \\text{Blu}    &amp; 001        \\\\         \\text{Verde}  &amp; 010        \\\\         \\text{Giallo} &amp; 011        \\\\         \\text{Viola}  &amp; 100        \\\\         \\text{Bianco} &amp; 101        \\\\         \\text{Nero}   &amp; 110        \\\\         \\text{Grigio} &amp; 111        \\\\     \\end{array} \\]"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#bit-byte-e-word","title":"Bit, byte e word","text":"<p>Con \\(n \\bbit\\) si possono rappresentare \\(2^n\\) stati o valori differenti. Per rappresentare \\(n\\) stati o valori, bisogna usare almeno \\(\\ceil{\\log_2 n}\\bit\\).</p> <p>I sistemi moderni memorizzano e manipolano miliardi di bit: vi \u00e8 quindi la necessit\u00e0 di avere dei multipli, infatti si ha che \\(8 \\bbit = 1 \\bbyte\\).</p> <p>Con la lettera \"\\(\\bit\\)\" minuscola si indicano i bit, mentre con la lettera \"\\(\\byte\\)\" maiuscola si indicano i byte.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#multipli-del-byte","title":"Multipli del byte","text":"Unit\u00e0 Simbolo Valore relativo Valore pot. \\(10\\) Byte \\(\\byte\\) \\(8 \\bit\\) \\(10^0 \\byte\\) KiloByte \\(\\KB\\) \\(1000 \\byte\\) \\(10^3 \\byte\\) MegaByte \\(\\MB\\) \\(1000 \\KB\\) \\(10^6 \\byte\\) GigaByte \\(\\GB\\) \\(1000 \\MB\\) \\(10^9 \\byte\\) TeraByte \\(\\TB\\) \\(1000 \\GB\\) \\(10^{12} \\byte\\) PetaByte \\(\\PB\\) \\(1000 \\TB\\) \\(10^{15} \\byte\\) ExaByte \\(\\EB\\) \\(1000 \\PB\\) \\(10^{18} \\byte\\) ZettaByte \\(\\ZB\\) \\(1000 \\EB\\) \\(10^{21} \\byte\\) YottaByte \\(\\YB\\) \\(1000 \\ZB\\) \\(10^{24} \\byte\\) <p>Esistono misure in potenza di due dove \\(1 \\KiB = 1024 \\byte\\), dove \\(\\KiB\\) sta per KibiByte. Gli altri multipli sono equivalenti a quelli elencati sopra, eccetto che sono in potenza di due e non di dieci.</p> <p>Esistono analoghe misure per i multipli dei \\(\\bbit\\) (\\(\\small{\\rm Kb}\\), ovvero KiloBit, quindi \\(1000\\bbit\\)), utilizzati generalmente come misura nelle quantit\u00e0 di dati trasmessi.</p> <p>Fino a qualche anno fa le misure \\(\\KiB,\\, \\GiB,\\, \\TiB,\\,\\dotsc\\,\\) non esistevano e i nomi dei multipli in tabella erano corrispondenti agli altri, ovvero \\(1 \\KB = 1024 \\byte\\).</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#tipi-di-dati-non-numerici","title":"Tipi di dati non numerici","text":"<p>La rappresentazione dei numeri, cos\u00ec come tutte le altre rappresentazioni dei dati, in informatica, a livello circuitale, avviene per tramite del codice binario. Le unit\u00e0 in memoria sono valori binari (corrispondenti ai bit).</p> <p>Vi sono molteplici tipi di dati non numerici.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#booleani","title":"Booleani","text":"<p>I dati booleani sono contenuti all'interno di singoli bit che assumono valore <code>0/1</code> o <code>F/V</code>. Comunemente si considera come falso il valore <code>0</code> e come vero qualsiasi altro valore.</p> <p>Esempio</p> <p>L'espressione <code>if(a)</code> corrisponde a <code>if(a != 0)</code>.</p> <p>In questa situazione il valore viene memorizzato all'interno di uno (es. per il <code>char</code>) o pi\u00f9 byte (es. per <code>short</code>, <code>int</code>, etc).</p> <p>L'unico caso in cui un booleano viene effettivamente memorizzato in un singolo bit si ha quando si utilizzano le mappe di bit: viene considerato un byte come se fosse un array di bit, ciascuno dei quali rappresenta un valore booleano.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#caratteri","title":"Caratteri","text":"<p>Mappati come interi equivalenti in ASCII/UNICODE. In particolare si ha che l'UNICODE ha diversi \"tipi\", rappresentati in tabella.</p> Sigla # di bit Descrizione UTF-8 \\(8\\bit\\; (1 \\byte)\\) ASCII esteso UTF-16 \\(16\\bit\\; (2 \\byte)\\) Espansione a linguaggi occidentali UTF-32 \\(32\\bit\\; (4 \\byte)\\) Set pi\u00f9 completo di caratteri <p>L'ASCII invece occupa \\(7 \\bit\\).</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#puntatori","title":"Puntatori","text":"<p>Rappresentano e memorizzano delle locazioni in memoria. Lo spazio occupato per un puntatore dipende dalla dimensione dello spazio di indirizzamento.</p> <pre><code>stateDiagram-v2\n  direction LR\n  var: Variabile normale\n  state var {\n    varAddress: 1001\\n (indirizzo)\n    varValue: 50\\n (valore)\n  }\n\n  ptr: Puntatore\n  state ptr {\n    ptrAddress: 2047\\n (indirizzo)\n    ptrValue: 1001\\n (valore)\n   }\n\n  ptrValue --&gt; varAddress</code></pre> <p>Ovvero il puntatore, appunto, punta all'indirizzo della variabile con valore \\(50\\) e indirizzo \\(1001\\), infatti il puntatore assume valore \\(1001\\).</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#basi-numeriche","title":"Basi numeriche","text":"<p>Il nostro sistema numerico \u00e8 in base \\(10\\). Un numero \\(n\\) si denota come scritto in una certa base numerica \\(b\\) mediante la seguente notazione:</p> \\[ n_b \\] <p>Esempi</p> <ul> <li>\\(15_{10}\\) indica il numero \\(15\\) in base \\(10\\);</li> <li>\\(010001_{2}\\) indica il numero \\(010001\\) in base \\(2\\);</li> <li>\\(23C_{16}\\) indica il numero \\(23C\\) in base \\(16\\);</li> </ul> <p>Un numero scritto in base \\(b\\) pu\u00f2 essere composto unicamente dalle cifre comprese tra \\(0\\) e \\(b \u2212 1\\) incluse.</p> <p>Per le basi superiori a \\(10\\) si usano le lettere dell'alfabeto per indicare le cifre successive. Ad esempio, in base \\(16\\) si usano le seguenti cifre:</p> \\[     \\begin{array}{ cccccccccccccccc }         0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp;  A &amp;  B &amp;  C &amp;  D &amp;  E &amp;  F \\\\         \\hline         0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 \\\\     \\end{array} \\] <p>Le basi pi\u00f9 utilizzate in informatica (oltre alla base \\(10\\)) sono:</p> <ul> <li>La base \\(2\\), detto sistema binario. Le stringhe binarie sono generalmente   indicate con il prefisso \\(\\bin{}\\) (es. \\(\\bin{01001010}\\));</li> <li>La base \\(8\\), detto sistema ottale</li> <li>La base \\(16\\), detto sistema esadecimale (HEX). Le stringhe esadecimali sono   generalmente indicate con il prefisso \\(\\hex{}\\) (es. \\(\\hex{FF2C9A}\\)).</li> </ul>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#conversione-da-base-b-in-base-10","title":"Conversione da base \\(b\\) in base \\(10\\)","text":"<p>Sia \\(k_b = {(c_{n-1} \\,\\dots\\, c_3\\, c_2\\, c_1\\, c_0)}_b\\) un numero di \\(n\\) cifre in base \\(b\\), dove \\(c_i\\) rappresenta la cifra \\(i\\)-esima in base \\(b\\) partendo da destra. Un numero si converte in base \\(10\\) mediante la seguente formula:</p> \\[     k_{10} = \\sum_{i=0}^{n-1} c_i b_i            = (c_0 \\cdot b^0) + (c_1 \\cdot b^1) +\\dots+ (c_n \\cdot b^{n-1}) \\] <p>Esempi</p> Da esadecimaleDa binario <p>Dato \\(\\hex{3FC2}\\), si ha:</p> \\[     \\begin{align*}         3 \\cdot 16^3 + F \\cdot 16^2 + C \\cdot 16^1 + 2 \\cdot 16^0             &amp;= 3 \\cdot 16^3 + 15 \\cdot 16^2                             + 12 \\cdot 16^1 + 2 \\cdot 16^0      \\\\             &amp;= 3 \\cdot 4096 + 15 \\cdot 256                             + 12 \\cdot 16 + 2 \\cdot 1           \\\\             &amp;= {16322}_{10}     \\end{align*} \\] <p>Dato \\(\\bin{10010101}\\), si ha:</p> \\[     \\begin{array}{ cccccccc }         2^7  &amp; 2^6 &amp; 2^5 &amp; 2^4 &amp; 2^3 &amp; 2^2 &amp; 2^1 &amp; 2^0  \\\\ \\hline         1    &amp;  0  &amp;  0  &amp;  1  &amp;  0  &amp;  1  &amp;  0  &amp; 1    \\\\ \\hline         128  &amp;  -  &amp;  -  &amp; 16  &amp;  -  &amp;  4  &amp;  -  &amp; 1    \\\\     \\end{array} \\] <p>Infatti:</p> \\[ 128 + 16 + 4 + 1 = 149_{10} \\]"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#conversione-da-base-10-a-base-b","title":"Conversione da base \\(10\\) a base \\(b\\)","text":"<p>Si prende il numero e lo si divide per la base \\(b\\) in forma di quoto e resto, successivamente si divide il quoto come prima e si continua fin quando non si ottiene il valore \\(0\\) come quoto.</p> <p>Il numero in base \\(b\\) \u00e8 rappresentato dai singoli resti, presi come cifre, considerando l'ultimo resto come cifra pi\u00f9 significativa e il primo resto come cifra meno significativa.</p> ALGORITMO<pre><code>i := 0\nESEGUI\n    c\u1d62 := n % b   &gt;&gt; operazione modulo (resto della divisione)\n    n = \u230an/b\u230b\n    i := i + 1\nFINCH\u00c9 (n != 0)\n</code></pre> <p>Esempi</p> In esadecimaleIn binario <p>Dato \\(3425_{10}\\), per convertirlo in base \\(16\\), si ha:</p> \\[     \\begin{array}{ ccc|c }         \\text{dividendo}             &amp; \\text{operazione}                 &amp; \\text{quoto} &amp; \\text{resto} \\\\[.5em] \\hline         3425 &amp; 3425/16 &amp; 214 &amp; 1 \\\\         214  &amp; 214/16  &amp; 13  &amp; 6 \\\\         13   &amp; 13/16   &amp; 0   &amp; D \\\\     \\end{array} \\] <p>Dunque il risultato \u00e8 \\(\\hex{D61}\\).</p> <p>Dato \\(213_{10}\\), per convertirlo in binario si ha:</p> \\[     \\begin{array}{ c|c }         213 &amp; 1 \\\\[-0.25em]         106 &amp; 0 \\\\[-0.25em]          53 &amp; 1 \\\\[-0.25em]          26 &amp; 0 \\\\[-0.25em]          13 &amp; 1 \\\\[-0.25em]           6 &amp; 0 \\\\[-0.25em]           3 &amp; 1 \\\\[-0.25em]           1 &amp; 1 \\\\[-0.25em]           0     \\\\     \\end{array} \\] <p>Dividendo per due \u00e8 immediato ricavare che il resto \u00e8 \\(0\\) se il numero \u00e8 pari, mentre \u00e8 \\(1\\) se dispari.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#conversione-rapida-da-base-2n-a-base-2-e-viceversa","title":"Conversione rapida da base \\(2^n\\) a base \\(2\\) e viceversa","text":"<p>Poich\u00e9 la base \\(16 = 2^4\\) \u00e8 possibile dividere in blocchi da \\(4\\) cifre a partire da destra e trasformare il blocco da una base all'altra.</p> \\[     \\begin{array}{ ccc|cccc|cccc|cccc }         0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ \\hline           &amp; 1 &amp;   &amp;&amp;&amp;  B  &amp;       &amp;&amp;&amp;    6        &amp;&amp;&amp;     F       \\\\     \\end{array} \\]"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#rappresentazione-di-un-numero","title":"Rappresentazione di un numero","text":"<p>Per rappresentare un numero \\(n \\in \\N\\) in base \\(b\\) sono necessarie \\(\\ceil{\\log_b n}\\) cifre. Quindi, la stessa regola la si applica anche in binario.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#somma-e-sottrazione","title":"Somma e sottrazione","text":"<p>Nel sistema binario le operazioni di somma e sottrazione si effettuano nella stessa maniera in cui le si effettuano in base \\(10\\), considerando per\u00f2 i riporti alla base \\(2\\):</p> \\[     \\begin{array}{lr}         \\begin{array}{ r rrrrr|l }             22_{10} &amp; 1 &amp; ^1 0 &amp; ^1 1 &amp; 1 &amp; 0 &amp; + \\\\              7_{10} &amp; 0 &amp;    0 &amp;    1 &amp; 1 &amp; 1 &amp; = \\\\ \\hline             29_{10} &amp; 1 &amp;    1 &amp;    1 &amp; 0 &amp; 1     \\\\         \\end{array} &amp; \\qquad         \\begin{array}{ r rrrrr|l }             22_{10} &amp; ^0 \\cancel{1} &amp; ^1 \\cancel{0} &amp; ^0 \\cancel{1} &amp; ^0 \\cancel{1} &amp; 0 &amp; - \\\\              7_{10} &amp;    0 &amp;    0 &amp;    1 &amp;    1 &amp; 1 &amp; = \\\\ \\hline             15_{10} &amp;    1 &amp;    1 &amp;    1 &amp;    0 &amp; 1     \\\\         \\end{array}     \\end{array} \\]"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#rappresentazione-dei-numeri-relativi","title":"Rappresentazione dei numeri relativi","text":""},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#modulo-e-segno","title":"Modulo e segno","text":"<p>Viene destinato il bit pi\u00f9 significativo al segno, rispettivamente \\(0\\) indica segno positivo e \\(1\\) segno negativo, e i restanti bit al modulo del numero.</p> <p>Esempio</p> <p>Dato il numero \\(\\bin{11010101}\\), si ha:</p> \\[     \\begin{array}{ r|l }         \\text{segno} &amp; \\text{modulo} \\\\ \\hline         1            &amp; 1010101       \\\\     \\end{array} \\] <p>Il che equivale al numero \\(-85_{10}\\)</p> <p>Con la rappresentazione modulo e segno in \\(n \\bit\\) si possono rappresentare \\(2n - 1\\) numeri cos\u00ec divisi:</p> <ul> <li>\\(2^{n-1}\\) numeri positivi (incluso lo zero);</li> <li>\\(2^{n-1}\\) numeri negativi (incluso lo zero).</li> </ul> <p>L'intervallo rappresentabile \u00e8 \\({[-2^{n-1} + 1,\\; 2^{n-1}-1]}_{10}\\).</p> <p>Se si hanno a disposizione \\(n\\) bit \u00e8 normalmente possibile rappresentare \\(2^n\\) valori, ma con il modulo e segno se ne possono rappresentare \\(2^n - 1\\). Ci\u00f2 \u00e8 dovuto alla doppia rappresentazione del valore zero:</p> \\[     \\begin{array}{ r|l }         \\text{segno} &amp; \\text{modulo} \\\\ \\hline                    0 &amp; 0000000       \\\\                    1 &amp; 0000000       \\\\     \\end{array} \\] <p>Che corrispondono rispettivamente a \\(+0\\) e \\(\u22120\\).</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#operazioni-di-somma-e-sottrazione","title":"Operazioni di somma e sottrazione","text":"<p>Di seguito come vengono effettuate le operazioni di addizione e sottrazione nella rappresentazione in modulo e segno.</p> <p>Le operazioni di sottrazione possono essere sempre ottenute invertendo il sottraendo:</p> \\[ A - B = A + (-B) \\] <p>Vi saranno casi in cui le operazioni produrranno un overflow in termini di bit. Laddove i segni siano concordi \u00e8 necessario valutare se la somma dei moduli (sia essa positiva o negativa) costituisca un valore rappresentabile con il numero di bit scelti per la rappresentazione:</p> <ul> <li>se il modulo \u00e8 troppo grande per essere rappresentato si ha una situazione di   overflow, se gli operandi sono positivi, o di underflow, se gli operandi   sono negativi. Le operazioni produrranno dunque un risultato errato;</li> <li>se invece il modulo pu\u00f2 essere rappresentato, il bit in eccesso dovr\u00e0 essere   gestito correttamente per garantire la validit\u00e0 del risultato.</li> </ul> <p>Il bit in eccesso si pu\u00f2 presentare anche nei casi in cui i segni sono discordi, in tal caso dovr\u00e0 essere gestito correttamente per garantire la validit\u00e0 del risultato.</p> <p>Per effettuare le operazioni di somma e sottrazione tra numeri in modulo e segno \u00e8 necessario rimuovere il bit di segno e procedere come segue sulla base del segno. Ipotizzando di voler effettuare la somma \\(A + B\\), si ha:</p> \\(A &gt; 0\\) \\(A &lt; 0\\) \\(B &gt; 0\\) \\(\\abs{A} + \\abs{B}\\) \\(\\abs{B} &lt; \\abs{A} \\implies -(\\abs{A} - \\abs{B})\\)\\(\\abs{B} &gt; \\abs{A} \\implies \\abs{B} - \\abs{A}\\) \\(B &lt; 0\\) \\(\\abs{A} &lt; \\abs{B} \\implies -(\\abs{B} - \\abs{A})\\)\\(\\abs{A} &gt; \\abs{B} \\implies \\abs{A} - \\abs{B}\\) \\(-(\\abs{A} + \\abs{B})\\) <p>Lo svantaggio \u00e8 che l'operazione risulta estremamente complicata.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#complemento-a-uno","title":"Complemento a uno","text":"<p>In questo caso i numeri negativi vengono rappresentati tramite il complemento della loro rappresentazione positiva.</p> <p>Esempio</p> \\[     \\begin{array}{ r|l }         \\text{decimale} &amp; \\text{binario} \\\\ \\hline                     +89 &amp; 01011001       \\\\                     -89 &amp; 10100110     \\end{array} \\] <p>Anche in questo caso \u00e8 possibile rappresentare \\(2^n - 1\\) valori, in quanto vi \u00e8 la doppia rappresentazione dello zero: \\(\\bin{00000000}\\) e \\(\\bin{11111111}\\). Di nuovo, l'intervallo rappresentabile \u00e8 \\({[-2^{n-1} + 1,\\; 2^{n-1} - 1]}_{10}\\).</p> <p>Il primo bit non viene comunque utilizzato per rappresentare il modulo (se fosse pari a \\(1\\) supererebbe il valore massimo rappresentabile), quindi pu\u00f2 essere utilizzato per identificare il segno.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#somma-e-sottrazione-in-complemento-a-uno","title":"Somma e sottrazione in complemento a uno","text":"<p>Si procede sommando normalmente i valori e laddove l'operazione produca un riporto successivo al bit del segno, quest'ultimo viene aggiunto al risultato:</p> \\[     \\begin{array}{ r|rrrrrr|l }         +10 &amp; ^1       &amp; ^1 0 &amp; 1 &amp; ^1 0 &amp; 1 &amp; 0 &amp; +   \\\\          -4 &amp;          &amp;    1 &amp; 1 &amp;    0 &amp; 1 &amp; 1 &amp; =   \\\\ \\hline             &amp; \\fbox{1} &amp;    0 &amp; 0 &amp;    1 &amp; 0 &amp; 1 &amp;     \\\\             &amp;          &amp;      &amp;   &amp;      &amp;   &amp;   &amp;     \\\\             &amp;          &amp;    0 &amp; 0 &amp;    1 &amp; 0 &amp; 1 &amp; +   \\\\             &amp;          &amp;      &amp;   &amp;      &amp;   &amp; 1 &amp; =   \\\\ \\hline          +6 &amp;          &amp;    0 &amp; 0 &amp;    1 &amp; 1 &amp; 0 &amp;     \\end{array} \\] <p>Lo svantaggio \u00e8 che il riporto in eccesso va sommato, quindi \u00e8 possibile avere una somma in pi\u00f9 da effettuare. Il vantaggio \u00e8 per\u00f2 che \u00e8 evidentemente pi\u00f9 comodo del modulo e segno.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#rappresentazione-in-complemento-a-due","title":"Rappresentazione in complemento a due","text":"<p>Nel complemento a due i numeri negativi vengono rappresentati con il complemento a uno incrementato di uno.</p> <p>Esempio</p> \\[     \\begin{array}{ r|l }         \\text{decimale}     &amp; \\text{binario}    \\\\ \\hline                         +90 &amp; 0\\;1011010        \\\\         (\\complement_1) -90 &amp; 1\\;0100101        \\\\         (\\complement_2) -90 &amp; 1\\;0100110     \\end{array} \\] <p>Il primo bit non viene comunque utilizzato per rappresentare il modulo (in quanto se fosse \\(1\\) supererebbe il valore massimo rappresentabile), quindi pu\u00f2 essere utilizzato per identificare il segno.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#vantaggi-del-complemento-a-due","title":"Vantaggi del complemento a due","text":"<p>Innanzitutto vi \u00e8 un'unica rappresentazione dello zero, infatti:</p> \\[     \\begin{array}{ r|rl }                         +0 &amp;               &amp; 0\\; 0000000 \\\\ \\hline         (\\complement_1) -0 &amp;               &amp; 1\\; 1111111 \\\\         (\\complement_2) -0 &amp; ^{\\cancel{1}} &amp; 0\\; 0000000     \\end{array} \\] <p>Si pu\u00f2 notare che la rappresentazione di \\(+0\\) e \\(\u22120\\) si equivalgono, in quanto la somma finale genera un overflow che non viene considerato, poich\u00e9 sfora il numero di bit in considerazione.</p> <p>Il secondo vantaggio consiste nell'utilizzare al massimo le rappresentazioni possibili. Questo deriva dal fatto che, contestualmente al fatto che lo zero viene rappresentato una sola volta, la rappresentazione \"aggiuntiva\" occupata dallo zero nel \\(\\complement_1\\) (complemento a uno) diventa la rappresentazione di un altro valore.</p> <p>In particolare:</p> <ul> <li>lo zero resta corrispondente solo alla notazione composta da tutti zeri;</li> <li>la notazione composta da tutti uno corrisponde invece al valore \\(\u22121\\);</li> <li>viene rappresentato un valore negativo in pi\u00f9: \\(\u22122^{n\u22121}\\).</li> </ul> <p>Nel complemento a due su \\(n\\) bit sono quindi rappresentati \\(2^n\\) valori e, dunque, l'intervallo rappresentabile \u00e8 \\({[\u22122^{n\u22121},\\; 2^{n\u22121} \u2212 1]}_{10}\\)</p> <p>Il valore decimale di un numero negativo in complemento a due pu\u00f2 essere ricavato velocemente tramite il seguente trucco.</p> <p>Basta considerare solo i valori \\(1\\), senza considerare il bit di segno. Il valore della potenza di due corrispondete al bit pi\u00f9 significativo (ovvero \\(-2^{n-1}\\) nel \\(\\complement_2\\) a \\(n\\) bit) va negato e a questo si sommano i valori di potenza di due corrispondenti ai bit con valore \\(1\\):</p> \\[     \\begin{array}{ r|ccccccc }            2^7 &amp;  2^6 &amp;   2^5 &amp; 2^4 &amp;  2^3 &amp;  2^2 &amp;  2^1 &amp;  2^0  \\\\ \\hline            1   &amp;  0   &amp;   1   &amp; 0   &amp;  1   &amp;  1   &amp;  0   &amp;  1    \\\\ \\hline         -128   &amp;      &amp; +32   &amp;     &amp; +8   &amp; +4   &amp;      &amp; +1    \\\\     \\end{array} \\] <p>Appunto:</p> \\[ -128 + 32 + 8 + 4 + 1 = -83 \\] <p>Il valore di un numero binario su \\(n\\) bit composto dai bit \\(c_{n-1}\\, c_{n-2}\\,\\dots\\, c_1\\, c_0\\) in \\(\\complement_2\\) \u00e8 equivalente infatti a:</p> \\[     -2^{n-1} c_{n-1} + \\sum_{i=0}^{n-2} c_i 2^i \\]"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#somma-e-sottrazione-in-complemento-a-due","title":"Somma e sottrazione in complemento a due","text":"<p>Si procede normalmente ignorando l'eventuale bit di overflow:</p> \\[     \\begin{array}{ r|rrrrrr|l }         +10 &amp; \\cancel{^1} &amp; ^1 0 &amp; 1 &amp; ^1 0 &amp; 1 &amp; 0 &amp; +   \\\\          -6 &amp;             &amp;    1 &amp; 1 &amp;    0 &amp; 1 &amp; 0 &amp; =   \\\\ \\hline          +4 &amp;             &amp;    0 &amp; 0 &amp;    1 &amp; 0 &amp; 0 &amp;     \\end{array} \\] <p>Il terzo vantaggio \u00e8 che, appunto, somme e sottrazioni possono essere ottenute senza particolari problemi.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#bug-dellanno-2038","title":"Bug dell'anno 2038","text":"<p>Nel complemento a due, come notato precedentemente, sommando \\(1\\) al numero pi\u00f9 grande rappresentabile si ottiene il numero pi\u00f9 piccolo rappresentabile. Questo effetto indesiderato pu\u00f2 procurare bug nei sistemi che gestiscono il tempo come numero intero. Ad esempio, nei sistemi UNIX, il tempo \u00e8 considerato come il numero di secondi a partire dal capodanno del \\(1970\\) (rappresentazione POSIX).</p> <p>Poich\u00e9 tale valore di tempo veniva memorizzato in variabili da \\(32 \\bit\\), giunti al massimo valore rappresentabile, il secondo immediatamente successivo viene interpretato come il minimo valore rappresentabile su \\(32 \\bit\\)<sup>[\\(\\dagger\\)]</sup>.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#rappresentazione-dei-numeri-razionali","title":"Rappresentazione dei numeri razionali","text":"<p>Per rappresentare un numero razionale<sup>1</sup>, al netto degli errori di approssimazione, vi sono due strade principali:</p> <ol> <li> <p>notazione in virgola fissa: si dedica un numero di cifre alla parte intera    e un numero di cifre alla parte decimale:</p> \\[ \\pm iiii.ddd \\] </li> <li> <p>notazione in virgola mobile (floating point \u2013 IEEE 754): la virgola    scorre secondo le esigenze di rappresentazione. Cos\u00ec facendo, con lo stesso    numero di bit della notazione in virgola fissa, \u00e8 possibile rappresentare    pi\u00f9 valori.</p> </li> </ol>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#rappresentazione-floating-point","title":"Rappresentazione floating point","text":"<p>Qualsiasi numero pu\u00f2 essere scritto nella seguente forma:</p> \\[ \\pm M \\times b^{\\pm e} \\] <p>Dove \\(M\\) \u00e8 la mantissa, \\(b\\) \u00e8 la base e \\(e\\) \u00e8 l'esponente.</p> <p>Quando tale sistema viene applicato alla base \\(10\\) prende il nome di notazione scientifica (es. \\(0.83234 \\times 10^2\\)).</p> <p>Naturalmente, tale rappresentazione dovr\u00e0 essere approssimata destinando un certo numero di bit alla mantissa e un certo numero di bit all\u2019esponente. La precisione nel floating point \u00e8 la seguente:</p> Precisione Singola Precisione doppia Segno \\(1 \\bit\\) \\(1 \\bit\\) Esponente \\(8 \\bit\\) \\(11 \\bit\\) Mantissa \\(23 \\bit\\) \\(52 \\bit\\) Totale \\(32 \\bit\\) \\(64 \\bit\\) Intervallo esponente \\([-126,\\; 127]\\) \\([-1022,\\; 1023]\\) Bias esponente \\(127\\) \\(1023\\) <p>Non \u00e8 necessario memorizzare la base in quanto \u00e8 implicita (\u00e8 due). Non tutte le configurazioni di esponenti sono disponibili, alcune sono riservate.</p> <p>Gli esponenti sono rappresentati in forma polarizzata, ovvero viene memorizzato l'esponente (in forma binaria) sommato ad una costante detta bias. Questo consente di effettuare pi\u00f9 facilmente i controlli di maggioranza o minoranza tra interi polarizzati poich\u00e9 l'esponente pi\u00f9 basso assume valore \\(\\bin{00000000}\\) e il pi\u00f9 alto \\(\\bin{11111111}\\).</p> <p>Vi sono diverse tipologie di numeri nel floating point:</p> \\[     \\begin{array}{ c|c|c|l }         \\text{Segno} &amp; \\text{Esponente} &amp; \\text{Mantissa}             &amp; \\text{Valore}                                     \\\\ \\hline         \\pm &amp; \\neq 0 \\lor 111\\dots111 &amp; \\text{qualsiasi}             &amp; \\text{n. normalizzato}                            \\\\         \\pm &amp; 0 &amp; \\text{qualsiasi tranne } 0             &amp; \\text{n. denormalizzato}                          \\\\         \\pm &amp; 0 &amp; \\text{0}             &amp; \\pm 0                                             \\\\         \\pm &amp; 111\\dots111 &amp; 0             &amp; \\pm\\infty                                         \\\\         \\pm &amp; 111\\dots111 &amp; \\text{qualsiasi tranne } 0             &amp; \\text{NaN (Not a Number)}     \\end{array} \\]"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#numeri-normalizzati","title":"Numeri normalizzati","text":"<p>Un numero normalizzato espresso in floating point su un calcolatore \u00e8 definito come segue:</p> \\[ \\pm 1.xxxxxxx \\times 2^{yyyy} \\] <p>dove \\(xxxxxxx\\) sono i (sette) bit destinati alla mantissa e \\(yyyy\\) i (quattro) bit destinati all'esponente. Il valore di un numero normalizzato \u00e8 sempre compreso tra \\(1\\) incluso e \\(2\\) escluso.</p> <p>Si usano tutti i bit \\(x\\) per identificare la parte frazionaria (l'\\(1\\) intero \u00e8 implicito).</p> \\[     \\begin{array}{ c|c|c }         \\text{segno} &amp; \\text{esponente } (8\\bit) &amp; \\text{mantissa } (23\\bit) \\\\ \\hline         0            &amp; 01111100                  &amp; 01000000000000000000000   \\\\     \\end{array} \\] <p>Il valore di un numero a \\(32\\bit\\) in floating point \u00e8 dato dalla seguente formula:</p> \\[     (-1)^{b_{31}} \\times 2^{(b_{30},\\, b_{29},\\, \\dots,\\, b_{23}) - 127}                   \\times (1,\\, b_{22}\\, b_{21} \\dots b_0)_2 \\]"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#conversione-di-un-numero-reale-in-binario","title":"Conversione di un numero reale in binario","text":"<p>Per la parte intera si procede come gi\u00e0 visto in precedenza. Per la parte frazionaria si moltiplica il valore per due e si prende la cifra intera ricavata, la si sottrae e si procede fin quando non si esaurisce la precisione (numero di cifre binarie che \u00e8 possibile memorizzare) o il risultato \u00e8 \\(1\\).</p> <p>Esempio</p> <p>Dato il numero decimale \\(19.3125\\), si ha che la parte intera, ovvero \\(19\\) \u00e8 pari a \\(\\bin{10011}\\). Per la parte decimale:</p> \\[     \\begin{align}         0.3125 \\times 2 &amp;= \\underline{0}.625    \\\\         0.625  \\times 2 &amp;= \\underline{1}.250    \\\\         0.250  \\times 2 &amp;= \\underline{0}.500    \\\\         0.500  \\times 2 &amp;= \\underline{1}.0      \\\\     \\end{align} \\] <p>Dunque \\({19.3125}_{10} = \\bin{10011.\\underline{0101}}\\). A riprova di ci\u00f2:</p> \\[     \\begin{array}{ lllll c llll }         2^4 &amp; 2^3 &amp; 2^2 &amp; 2^1 &amp; 2^0 &amp;   &amp; 2^{-1} &amp; 2^{-2} &amp; 2^{-3} &amp; 2^{-4} \\\\             \\hline         1   &amp; 0   &amp; 0   &amp; 1   &amp; 1   &amp; . &amp; 0      &amp; 1      &amp; 0      &amp; 1      \\\\             \\hline         16  &amp;     &amp;     &amp; 2   &amp; 1   &amp;   &amp;        &amp; 0.25   &amp;        &amp; 0.0625     \\end{array} \\] <p>Infatti</p> \\[ 16 + 2 + 1 + 0.25 + 0.0625 = 19.3125 \\] <p>Dopo aver effettuato la conversione si imposta l'esponente in maniera tale da far scorrere la virgola del numero di posizioni necessarie per rappresentare il numero correttamente.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#numeri-denormalizzati","title":"Numeri denormalizzati","text":"<p>Un numero denormalizzato espresso in floating point su un calcolatore \u00e8 definito come segue:</p> \\[ \\pm 0.xxxxxxx \\times 2 ^{1-b} \\] <p>dove \\(b\\) indica il bias. In questo caso la mantissa \u00e8 sempre compresa tra \\(0\\) e \\(1\\) e i bit dell'esponente sono impostati a \\(0\\). Servono a riempire l'intervallo tra lo \\(0\\) e il pi\u00f9 piccolo numero normalizzato rappresentabile.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#problematiche-nel-floating-point","title":"Problematiche nel floating point","text":"<p>In generale l'aritmetica a virgola mobile \u00e8 affetta da alcune problematiche:</p> <ol> <li>non sono valide in generale la propriet\u00e0 associativa e la propriet\u00e0 distributiva;</li> <li>assorbimento: numeri molto grandi \"assorbono\" numeri pi\u00f9 piccoli, es.    \\(10^{15} + 1 = 10^{15}\\);</li> <li>cancellazione: quando sottraendo due numeri molto vicini si ottiene \\(0\\);</li> <li>arrotondamento.</li> </ol> <p>Gli errori di calcolo sono invece ottenuti da:</p> <ol> <li>le operazioni in overflow danno risultato \\(\\pm\\infty\\);</li> <li>situazioni di underflow, ovvero valori molto piccoli trasformati in \\(0\\);</li> <li>le operazioni impossibili (es. la radice quadrata di un numero negativo)    restituisce NaN.</li> </ol> <p>I problemi di arrotondamento sono dati da una duplice natura:</p> <ol> <li>operazioni aritmetiche, es \\(\\ifrac{2}{3} = 0.666667\\);</li> <li>numeri non rappresentabili.</li> </ol> <p>Ad esempio \\(0.1\\) non \u00e8 un numero rappresentabile, infatti:</p> \\[     \\begin{align}         0.1 \\times 2 &amp;= \\underline{0}.2 \\\\         0.2 \\times 2 &amp;= \\underline{0}.4 \\\\         0.4 \\times 2 &amp;= \\underline{0}.8 \\\\         0.8 \\times 2 &amp;= \\underline{1}.6 \\\\         0.6 \\times 2 &amp;= \\underline{1}.2 \\\\         0.2 \\times 2 &amp;= \\underline{0}.4 \\\\         0.4 \\times 2 &amp;= \\underline{0}.8 \\\\     \\end{align} \\] <p>Si ha un ciclo infinito sulla cifra finae \\(2\\)-\\(4\\)-\\(8\\)-\\(6\\)</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#operazioni-in-floating-point","title":"Operazioni in floating point","text":""},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#confronto-di-uguaglianza","title":"Confronto di uguaglianza","text":"<p>Poich\u00e9 i dati possono provenire da operazioni di natura diversa ha senso definire l\u2019uguaglianza come segue. Preso un \\(\\varepsilon\\) sufficientemente piccolo:</p> \\[ A = B \\iff \\abs{A - B} &lt; \\varepsilon \\] <p>ovvero se i due numeri sono abbastanza vicini tra loro.</p>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#confronto-maggioreminore","title":"Confronto maggiore/minore","text":"<p>Non a caso vegono memorizzati nell'ordine segno, esponente e mantissa. Per confrontarli \u00e8 sufficiente scorrere i bit dei due numeri fin quando non si trova un bit diverso:</p> <ul> <li>se si trova nel segno, \u00e8 pi\u00f9 grande il numero con il segno positivo (\\(0\\));</li> <li>se si trova nell\u2019esponente o nella mantissa \u00e8 pi\u00f9 grande il numero con il   bit a \\(1\\).</li> </ul>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#sommasottrazione","title":"Somma/sottrazione","text":"<p>Per effettuare la somma o la sottrazione:</p> <ul> <li>si allineano i due numeri per raggiungere lo stesso esponente;</li> <li>si sommano le mantisse;</li> <li>si normalizza il risultato;</li> <li>si controlla se \u00e8 overflow o underflow;</li> <li>si arrotonda il numero;</li> <li>se non \u00e8 normalizzato, lo si normalizza.</li> </ul>"},{"location":"Anno_I/AESO/AE1_dati_rappresentazione/#prodottodivisione","title":"Prodotto/divisione","text":"<p>Per effettuare il prodotto o la divisione:</p> <ul> <li>si sommano gli esponenti \u2013 bias;</li> <li>si moltiplicano le mantisse;</li> <li>si normalizza il risultato;</li> <li>si controlla se \u00e8 overflow o underflow;</li> <li>si arrotonda il numero;</li> <li>se non \u00e8 normalizzato, lo si normalizza.</li> </ul> <ol> <li> <p>I numeri reali sono composti dai numeri razionali e irrazionali. Quest'ultimi non sono rappresentabili.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/","title":"Espressioni logiche booleane e mappe di Karnaugh","text":""},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#espressioni-logiche","title":"Espressioni logiche","text":"<p>Espressione Logica</p> <p>Un'espressione logica (o funzione logica) \u00e8 una qualsiasi espressione composta da variabili logiche, le quali possono assumere solo valori booleani (vero/falso) e da connettivi logici (operatori logici).</p> <p>Un esempio di espressione logica \u00e8:</p> \\[ f = \\overline{AB} + \\bar{A}(\\bar{B} + \\bar{C}\\bar{D}) \\] <p>La quale \u00e8 una funzione logica in \\(4\\) variabili ovvero \\(A\\), \\(B\\), \\(C\\) e \\(D\\).</p> <p>L'algebra di Boole ha le seguenti propriet\u00e0:</p> Nome Forma AND Forma OR Elemento neutro \\(1A = A\\) \\(0 + A = A\\) Annullamento \\(0A = 0\\) \\(1 + A = 1\\) Idempotenza \\(AA = A\\) \\(A + A = A\\) Complementazione \\(A\\bar{A} = 0\\) \\(A + \\bar{A} = A\\) Propriet\u00e0 commutativa \\(AB = BA\\) \\(A + B = B + A\\) Propriet\u00e0 associativa \\((AB)C = A(BC)\\) \\((A + B)C = A + (B + C)\\) Propriet\u00e0 distributiva \\(A + BC = (A + B)(A + C)\\) \\(A(B + C) = AB + AC\\) Legge di de Morgan \\(\\overline{AB} = \\bar{A} + \\bar{B}\\) \\(\\overline{A + B} = \\bar{A}\\bar{B}\\) 1<sup>a</sup> legge di assorbimento \\(A(A + B) = A\\) \\(A + AB = A\\) 2<sup>a</sup> legge di assorbimento \\(A(\\bar{A} + B) = AB\\) \\(A + \\bar{A}B = A + B\\) <p>Un'espressione logica pu\u00f2 essere rappresentata in modo esaustivo utilizzando una tavola di verit\u00e0. Ciascuna espressione logica ha un suo equivalente circuito logico. Ad esempio, \\(A + B\\bar{C}\\):</p> \\[     \\begin{array}{ ccccc|c }         A &amp; B &amp; C &amp; \\bar{C} &amp; B\\bar{C} &amp; A + B\\bar{C}   \\\\ \\hline         0 &amp; 0 &amp; 0 &amp;    1    &amp;     0    &amp;     0          \\\\         0 &amp; 0 &amp; 1 &amp;    0    &amp;     0    &amp;     0          \\\\         0 &amp; 1 &amp; 0 &amp;    1    &amp;     1    &amp;     1          \\\\         0 &amp; 1 &amp; 1 &amp;    0    &amp;     0    &amp;     0          \\\\         1 &amp; 0 &amp; 0 &amp;    1    &amp;     0    &amp;     1          \\\\         1 &amp; 0 &amp; 1 &amp;    0    &amp;     0    &amp;     1          \\\\         1 &amp; 1 &amp; 0 &amp;    1    &amp;     1    &amp;     1          \\\\         1 &amp; 1 &amp; 1 &amp;    0    &amp;     0    &amp;     1          \\\\     \\end{array} \\] <p> </p> Circuito logico corrispondente alla funzione riportata sopra"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#forma-normale-disgiuntiva-e-congiuntiva","title":"Forma normale disgiuntiva e congiuntiva","text":"<p>DNF</p> <p>Un'espressione logica \u00e8 detta in forma normale disgiuntiva (DNF o anche prima forma canonica) se \u00e8 una disgiunzione di clausole, dove ciascuna clausola \u00e8 una congiunzione di letterali.</p> <p>Ad esempio:</p> \\[ AB + B\\bar{C} + A\\bar{B}C \\] <p>CNF</p> <p>Un'espressione logica \u00e8 detta in forma normale congiuntiva (CNF o anche seconda forma canonica) se \u00e8 una congiunzione di clausole, dove ciascuna clausola \u00e8 una disgiunzione di letterali.</p> <p>Ad esempio:</p> \\[ (A + B)(B + \\bar{C})(A + \\bar{B} + C) \\] <p>Una qualsiasi espressione logica pu\u00f2 essere tradotta in DNF o in CNF.</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#ricostruire-unespressione-logica","title":"Ricostruire un'espressione logica","text":"<p>\u00c8 immediato, avendo a disposizione una funzione logica arbitraria, ricavarne la tavola di verit\u00e0 e il circuito logico corrispondente. Partendo da un circuito logico \u00e8 immediato ricostruire l'espressione corrispondente a tale circuito.</p> <p>Come ricavare l'espressione logica corrispondente alla tavola di verit\u00e0 di una funzione logica?</p> <p>Per raggiungere tale scopo si utilizzano diversi strumenti, tra cui:</p> <ul> <li>la riscrittura in somma di mintermini;</li> <li>la riscrittura in prodotto di maxtermini;</li> <li>il Teorema di Shannon;</li> <li>le mappe di Karnaugh.</li> </ul>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#mintermini-e-maxtermini","title":"Mintermini e maxtermini","text":"<p>La procedura di riscrittura in somma di mintermini (o somma di prodotti) consente di ricavare l'espressione logica di una funzione booleana qualsiasi. L'espressione risultante sar\u00e0 espressa, appunto, come somma di mintermini, ovvero sar\u00e0 in forma normale disgiuntiva.</p> <p>Mintermine</p> <p>Un mintermine (o prodotto canonico) \u00e8 una funzione booleana che assume il valore vero in corrispondenza di un'unica configurazione di variabili booleane indipendenti.</p> <p>In maniera perfettamente speculare,</p> <p>Maxtermine</p> <p>Si definisce maxtermine (o somma canonica) una funzione booleana che assume il valore falso in corrispondenza di un'unica configurazione di variabili booleane indipendenti.</p> <p>Allo stesso modo, quindi, sar\u00e0 possibile riscrivere una funzione booleana qualsiasi come prodotto di maxtermini (o prodotto di somme), il cui risultato sar\u00e0 in CNF. Le due scritture si equivalgono.</p> <p>Per ciascuna combinazione di input della tavola di verit\u00e0 \u00e8 quindi possibile ricavare un mintermine e un maxtermine</p> \\[     \\begin{array}{ ccc|c|c }         A &amp; B &amp; C &amp; \\text{Mintermine}     &amp; \\text{Maxtermine}           \\\\ \\hline         0 &amp; 0 &amp; 0 &amp; \\bar{A}\\bar{B}\\bar{C} &amp; A + B + C                   \\\\         0 &amp; 0 &amp; 1 &amp; \\bar{A}\\bar{B}C       &amp; A + B + \\bar{C}             \\\\         0 &amp; 1 &amp; 0 &amp; \\bar{A}B\\bar{C}       &amp; A + \\bar{B} + C             \\\\         0 &amp; 1 &amp; 1 &amp; \\bar{A}BC             &amp; A + \\bar{B} + \\bar{C}       \\\\         1 &amp; 0 &amp; 0 &amp; A\\bar{B}\\bar{C}       &amp; \\bar{A} + B + C             \\\\         1 &amp; 0 &amp; 1 &amp; A\\bar{B}C             &amp; \\bar{A} + B + \\bar{C}       \\\\         1 &amp; 1 &amp; 0 &amp; AB\\bar{C}             &amp; \\bar{A} + \\bar{B} + C       \\\\         1 &amp; 1 &amp; 1 &amp; ABC                   &amp; \\bar{A} + \\bar{B} + \\bar{C} \\\\     \\end{array} \\] <p>Ciascun mintermine si ottiene come prodotto delle singole variabili booleane, associando:</p> <ul> <li>la variabile booleana quando il valore \u00e8 \\(1\\);</li> <li>la variabile booleana negata quando il valore \u00e8 \\(0\\).</li> </ul> <p>Ciascun maxtermine si ottiene come somma delle singole variabili booleane, associando:</p> <ul> <li>la variabile booleana negata quando il valore \u00e8 \\(1\\);</li> <li>la variabile booleana quando il valore \u00e8 \\(0\\)</li> </ul> <p>Ciascun mintermine \u00e8 la negazione logica del relativo maxtermine (e viceversa) a seguito dell'applicazione delle leggi di de Morgan.</p> <p>\u00c8 facile verificare che ciascun mintermine e ciascun maxtermine rispetta la definizione:</p> <ul> <li>mintermine: assume il valore vero in corrispondenza di un'unica   configurazione di variabili booleane indipendenti;</li> <li>maxtermine: assume il valore falso in corrispondenza di un'unica   configurazione di variabili booleane indipendenti.</li> </ul> <p>Ad esempio, la configurazione \\(A = 0\\), \\(B = 1\\), \\(C = 0\\), \\(D = 1\\) ha per mintermine: \\(\\bar{A}B\\bar{C}D\\), mentre per maxtermine: \\(A + \\bar{B} + C + \\bar{D}\\).</p> <p>Infatti, in corrispondenza della configurazione \\(A = 0\\), \\(B = 1\\), \\(C = 0\\), \\(D = 1\\), si ha come mintermine: \\(\\bar{A}B\\bar{C}D\\) ovvero \\(\\bar{0}1\\bar{0}1 = 1111 = 1\\). In tutte le altre configurazioni restituir\u00e0 \\(0\\), mentre come maxtermine: \\(A + \\bar{B} + C + \\bar{D}\\) ovvero \\(0 + \\bar{1} + 0 + \\bar{1}\\) e quindi \\(0 + 0 + 0 + 0 = 0\\). In tutte le altre configurazioni restituir\u00e0 \\(1\\).</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#somma-di-mintermini","title":"Somma di mintermini","text":"<p>Una qualsiasi funzione booleana pu\u00f2 essere scritta in somma di mintermini sommando tutti i mintermini delle combinazioni dove la funzione assume valore \\(1\\). Ad esempio:</p> \\[     \\begin{array}{ ccc|l }         A &amp; B &amp; C &amp; f                           \\\\ \\hline         0 &amp; 0 &amp; 0 &amp; 1 \\to \\bar{A}\\bar{B}\\bar{C} \\\\         0 &amp; 0 &amp; 1 &amp; 0                           \\\\         0 &amp; 1 &amp; 0 &amp; 1 \\to \\bar{A}B\\bar{C}       \\\\         0 &amp; 1 &amp; 1 &amp; 1 \\to \\bar{A}BC             \\\\         1 &amp; 0 &amp; 0 &amp; 0                           \\\\         1 &amp; 0 &amp; 1 &amp; 0                           \\\\         1 &amp; 1 &amp; 0 &amp; 1 \\to AB\\bar{C}             \\\\         1 &amp; 1 &amp; 1 &amp; 1 \\to ABC                   \\\\     \\end{array} \\] <p>Quindi.</p> \\[ f = \\bar{A}\\bar{B}\\bar{C} + \\bar{A}B\\bar{C} + \\bar{A}BC + AB\\bar{C} + ABC. \\]"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#prodotto-di-maxtermini","title":"Prodotto di maxtermini","text":"<p>Una qualsiasi funzione booleana pu\u00f2 essere scritta in prodotto di maxtermini moltiplicando tutti i maxtermini delle combinazioni dove la funzione assume valore \\(0\\). Ad esempio:</p> \\[     \\begin{array}{ ccc|l }         A &amp; B &amp; C &amp; f                           \\\\ \\hline         0 &amp; 0 &amp; 0 &amp; 1                           \\\\         0 &amp; 0 &amp; 1 &amp; 0 \\to A + B + \\bar{C}       \\\\         0 &amp; 1 &amp; 0 &amp; 1                           \\\\         0 &amp; 1 &amp; 1 &amp; 1                           \\\\         1 &amp; 0 &amp; 0 &amp; 0 \\to \\bar{A} + B + C       \\\\         1 &amp; 0 &amp; 1 &amp; 0 \\to \\bar{A} + B + \\bar{C} \\\\         1 &amp; 1 &amp; 0 &amp; 1                           \\\\         1 &amp; 1 &amp; 1 &amp; 1                           \\\\     \\end{array} \\] <p>Quindi,</p> \\[ f = (A + B + \\bar{C})(\\bar{A} + B + C)(\\bar{A} + B + \\bar{C}). \\] <p>La stessa funzione pu\u00f2 essere quindi scritta, equivalentemente, come somma di mintermini o prodotto di maxtermini. Generalmente, la scrittura in somma di mintermini \u00e8 preferita.</p> <p>L'espressione risultante, per\u00f2, non \u00e8 detto che sia minima, pertanto si deve provare a semplificarla attraverso l'uso delle propriet\u00e0 dell'algebra di Boole mediante, quindi, dei passaggi algebrici.</p> <p>Semplificare l'espressione consente dei vantaggi:</p> <ul> <li>gestione algebrica pi\u00f9 semplice: avere meno porte significa avere un circuito   pi\u00f9 semplice;</li> <li>in termini di velocit\u00e0: avere meno porte significa avere un circuito pi\u00f9   veloce;</li> <li>in termini di costi: avere meno porte significa avere meno spese.</li> </ul> <p>Ad esempio, l'espressione di prima:</p> \\[ f = \\bar{A}\\bar{B}\\bar{C} + \\bar{A}B\\bar{C} + \\bar{A}BC + AB\\bar{C} + ABC \\] <p>richiede \\(5\\) porte AND a tre vie, \\(1\\) porta OR a \\(5\\) vie e \\(7\\) porte NOT. Se fossero disponibili solo porte a due vie, servirebbero \\(10\\) porte AND, \\(4\\) porte OR e \\(7\\) porte NOT.</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#semplificazione-dellespressione","title":"Semplificazione dell'espressione","text":"<p>Sia dunque l'espressione logica da semplificare la seguente:</p> \\[     f = \\bar{A}\\bar{B}\\bar{C}         + \\underline{\\bar{A}B\\bar{C} + \\bar{A}BC}         + \\underline{AB\\bar{C} + ABC} \\] <p>\u00c8 innanzitutto possibile applicare la forma distributiva della forma OR e la complementazione in forma OR. dunque:</p> \\[     f = \\bar{A}\\bar{B}\\bar{C}         + \\bar{A}B\\underbrace{(\\bar{C} + C)}_1         + AB\\underbrace{(\\bar{C} + C)}_1 \\] <p>L'elemento neutro per l'AND \u00e8 l'\\(1\\):</p> \\[     f = \\bar{A}\\bar{B}\\bar{C} + \\underline{\\bar{A}B + AB} \\] <p>\u00c8 ora possibile applicare la propriet\u00e0 distributiva nella forma OR agli elementi evidenziati e successivamente la complementazione in forma OR:</p> \\[     f = \\bar{A}\\bar{B}\\bar{C} + B\\underbrace{(A + \\bar{A})}_1 \\] <p>di nuovo, l'elemento neutro per l'AND \u00e8 proprio l'\\(1\\) e dunque si pu\u00f2 applicare la seconda legge di assorbimento nella forma OR:</p> \\[ f = \\bar{A}\\bar{C} + B \\]"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#teorema-di-shannon","title":"Teorema di Shannon","text":"<p>Il teorema di Shannon<sup>1</sup> consente di scomporre una funzione booleana complessa in funzioni pi\u00f9 semplici</p> <p>Teorema di Shannon</p> <p>data una funzione booleana \\(f\\) in \\(n\\) variabili \\(\\oneton{v}\\) si ha che:</p> \\[     f(\\oneton{v}) = v_1 \\cdot f(1,\\, v_2, \\,\\dots,\\, v_n)                     + \\bar{v}_1 \\cdot f(0,\\, v_2, \\,\\dots,\\, v_n) \\] <p>Nel caso sopracitato il teorema \u00e8 applicato rispetto alla variabile \\(v_1\\), ma pu\u00f2 essere applicato a una qualsiasi delle variabili \\(\\oneton{v}\\).</p> <p>La funzione complessa di partenza in \\(n\\) variabili viene trasformata in una somma di due prodotti, aventi ciascuno una funzione in \\(n \u2212 1\\) variabili (in quanto la variabile su cui \u00e8 applicato il Teorema di Shannon \u00e8 gi\u00e0 avvalorata).</p> <p>Un esempio pratico di applicazione del teorema di Shannon \u00e8 il seguente.</p> <p>Sia \\(f\\) una funzione delle variabili \\(A\\), \\(B\\), \\(C\\), avente la seguente tavola di verit\u00e0:</p> \\[     \\begin{array}{ ccc|c }         A &amp; B &amp; C &amp; f \\\\ \\hline         0 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 1 \\\\         0 &amp; 1 &amp; 1 &amp; 0 \\\\         1 &amp; 0 &amp; 0 &amp; 0 \\\\         1 &amp; 0 &amp; 1 &amp; 1 \\\\         1 &amp; 1 &amp; 0 &amp; 1 \\\\         1 &amp; 1 &amp; 1 &amp; 1     \\end{array} \\] <p>essa pu\u00f2 essere riscritta in due funzioni pi\u00f9 semplici, separando sulla base di una variabile.</p> <p>Ad esempio, scegliendo di separare sulla base della variabile \\(B\\):</p> \\[     \\begin{array}{ ccc|c }         A &amp;         B        &amp; C &amp; f \\\\ \\hline         0 &amp; {\\color{green}0} &amp; 0 &amp; 1 \\\\         0 &amp; {\\color{green}0} &amp; 1 &amp; 0 \\\\         0 &amp; {\\color{teal}1}  &amp; 0 &amp; 1 \\\\         0 &amp; {\\color{teal}1}  &amp; 1 &amp; 0 \\\\         1 &amp; {\\color{green}0} &amp; 0 &amp; 0 \\\\         1 &amp; {\\color{green}0} &amp; 1 &amp; 1 \\\\         1 &amp; {\\color{teal}1}  &amp; 0 &amp; 1 \\\\         1 &amp; {\\color{teal}1}  &amp; 1 &amp; 1     \\end{array}         \\qquad\\qquad     \\begin{array}{c}         \\begin{array}{ ccc|c }             A &amp;        B         &amp; C &amp; f \\\\ \\hline             0 &amp; {\\color{green}0} &amp; 0 &amp; 1 \\\\             0 &amp; {\\color{green}0} &amp; 1 &amp; 0 \\\\             1 &amp; {\\color{green}0} &amp; 0 &amp; 0 \\\\             1 &amp; {\\color{green}0} &amp; 1 &amp; 1 \\\\         \\end{array}     \\\\[1em]         \\begin{array}{ ccc|c }             A &amp;        B        &amp; C &amp; f \\\\ \\hline             0 &amp; {\\color{teal}1} &amp; 0 &amp; 1 \\\\             0 &amp; {\\color{teal}1} &amp; 1 &amp; 0 \\\\             1 &amp; {\\color{teal}1} &amp; 0 &amp; 1 \\\\             1 &amp; {\\color{teal}1} &amp; 1 &amp; 1         \\end{array}     \\end{array} \\] <p>Si avr\u00e0 allora che:</p> \\[ f(A,\\, B,\\, C) = B \\cdot f(A,\\, 1,\\, C) + \\bar{B} \\cdot f(A,\\, 0,\\, C) \\] <p>Il funzionamento del teorema di Shannon \u00e8 il seguente nel caso in cui \\(B = 0\\):</p> \\[     \\begin{align}         f(A,\\, B,\\, C) &amp;= B \\cdot f(A,\\, 1,\\, C) + \\bar{B} \\cdot f(A,\\, 0,\\, C) \\\\                        &amp;= 0 \\cdot f(A,\\, 1,\\, C) + \\bar{0} \\cdot f(A,\\, 0,\\, C) \\\\                        &amp;= 0 + 1 \\cdot f(A,\\, 0,\\, C)                            \\\\                        &amp;= 0 + f(A,\\, 0,\\, C)                                    \\\\                        &amp;= f(A,\\, 0,\\, C)     \\end{align} \\] <p>\u00c8 analogo per \\(B = 1\\).</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#mappe-di-karnaugh","title":"Mappe di Karnaugh","text":"<p>La mappa di Karnaugh \u00e8 uno strumento che consente di ricavare, partendo dalla tavola di verit\u00e0 di una funzione logica, la sua espressione minima.</p> <p>Il metodo della mappa di Karnaugh si basa sul metodo della somma di mintermini, ma le espressioni vengono semplificate direttamente. Se il metodo viene applicato al massimo delle sue potenzialit\u00e0, ovvero scegliendo i raggruppamenti migliori, si ricaver\u00e0 l'espressione minima, altrimenti si ricaveranno delle espressioni semplificabili.</p> <p>Tale metodo \u00e8 particolarmente efficace nei casi di funzioni fino a quattro variabili, gestibile nei casi di cinque e sei variabili, difficilmente applicabile nei casi di funzioni a pi\u00f9 di sei variabili. Per quest'ultime si utilizzano altri metodi che non saranno trattati in questo corso.</p> <p>La mappa di Karnaugh pu\u00f2 essere quindi utilizzata per ottimizzare un'espressione logica o un circuito logico. La mappa di Karnaugh opera in tre fasi:</p> <ol> <li>costruzione della o delle mappe;</li> <li>scelta dei raggruppamenti;</li> <li>generazione degli implicanti e dell'espressione finale.</li> </ol>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#costruzione-della-mappa","title":"Costruzione della mappa","text":"<p>Una singola mappa di Karnaugh pu\u00f2 essere realizzata per due, tre o quattro variabili. La costruzione di tale mappa avviene disponendo le variabili lungo il lato sinistro e il lato superiore di una tabella (massimo due variabili per lato). I lati dove sono disposte due variabili verranno divisi in quattro parti, i lati dove \u00e8 disposta una sola variabile verranno divisi in due parti. La scelta di come disporre le variabili e in quale ordine sta all'utilizzatore della mappa ed \u00e8 indifferente per il risultato.</p> Mappe di Karnaugh... <p> </p> <p>Lungo i lati della mappa di Karnaugh si riportano le configurazioni:</p> <ul> <li>\\(0\\)-\\(1\\) per i lati a singola variabile;</li> <li>\\(00\\)-\\(01\\)-\\(11\\)-\\(10\\) per i lati a doppia variabile.</li> </ul> <p>I valori riportati rappresentano le possibili configurazioni delle variabili. Tali disposizioni possono essere anche scritte al contrario (\\(1\\)-\\(0\\) e \\(10\\)-\\(11\\)-\\(01\\)-\\(00\\)).</p> <p>Attenzione</p> <p>La configurazione per la doppia variabile NON \u00e8 \\(00\\)-\\(01\\)-\\(10\\)-\\(11\\), ma \u00e8 \\(00\\)-\\(01\\)-\\(11\\)-\\(10\\). Tale codifica prende il nome di codifica di Gray ed \u00e8 utilizzata in questo caso in maniera tale che nel passare da una casella all'altra cambi sempre il valore di una sola variabile.</p> <p>Prendendo la tavola di verit\u00e0, si riportano nella mappa di Karnaugh i valori. \u00c8 sufficiente riportare i valori per i quali la funzione assume il valore \\(1\\) della funzione per ciascuna configurazione:</p> \\[     \\begin{array}{ cccc|c }         A &amp; B &amp; C &amp; D &amp; f \\\\ \\hline         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\\\         0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\\\         0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\         1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\         1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\         1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\\\         1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\         1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\         1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\         1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\     \\end{array} \\] <p> </p> Mappa di Karnaugh della tabella precedente <p>Le due rappresentazioni si equivalgono.</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#scelta-dei-raggruppamenti","title":"Scelta dei raggruppamenti","text":"<p>dalla mappa di Karnaugh devono essere effettuati dei raggruppamenti delle celle dove \u00e8 contenuto il valore \\(1\\). Tali raggruppamenti devono rispondere a tutte le seguenti condizioni:</p> <ol> <li>si possono raggruppare solo elementi tra celle adiacenti orizzontalmente o    verticalmente;</li> <li>i raggruppamenti non devono contenere celle con il valore \\(0\\);</li> <li>si possono raggruppare solo elementi in rettangoli o quadrati;</li> <li>il numero di celle di ciascun raggruppamento deve essere una potenza di \\(2\\);</li> <li>tutte le celle con il valore \\(1\\) devono essere contenute almeno in un    raggruppamento</li> </ol> <p>I raggruppamenti di \\(2^k\\) elementi prendono anche il nome di \\(k\\)-cubi.</p> <p>Esempi di singoli raggruppamenti validi</p> <p> </p> <p>Nota Bene</p> <p>La griglia non \u00e8 da considerarsi come un piano, bens\u00ec come un toro. Pertanto i raggruppamenti possono attraversare i bordi della mappa, sia verticalmente che orizzontalmente, passando da un lato a quello opposto.</p> <p>Sono quindi dei raggruppamenti validi:</p> <p> </p> <p>Come da figura \u00e8 possibile oltrepassare il limite sia orizzontalmente, che verticalmente, che in entrambe le direzioni</p> <p>Esempi di singoli raggruppamenti NON validi</p> <p> </p> <p>In ordine:</p> <ul> <li>il numero di elementi non \u00e8 una potenza di \\(2\\);</li> <li>sono prese celle non aventi il valore \\(1\\);</li> <li>il raggruppamento non \u00e8 n\u00e9 rettangolare n\u00e9 quadrato;</li> <li>sono prese celle non adiacenti.</li> </ul> <p>Nell'ambito della scelta dei raggruppamenti, \u00e8 sempre preferibile scegliere i raggruppamenti in maniera tale che siano sempre i pi\u00f9 grandi possibile, anche selezionando lo stesso valore pi\u00f9 volte (ridondanza). La ragione verr\u00e0 spiegata in seguito.</p> <p> </p> <p>La qualit\u00e0 dei raggruppamenti migliora progressivamente dal primo esempio (figura \\(\\text{(a)}\\)) all'ultimo (figura \\(\\text{(D)}\\)). L'ultimo esempio \u00e8 infatti quello che ha i raggruppamenti di dimensione pi\u00f9 grande che coprono l'intera superficie delle celle con valore \\(1\\).</p> <p>Non ha invece senso creare un raggruppamento ridondante se tutte le celle interessate sono gi\u00e0 state selezionate.</p> <p> </p> Raggruppamento inutile (rosso) <p>Il raggruppamento in rosso \u00e8 superfluo, quindi inutile: tutte le celle del raggruppamento sono gi\u00e0 coperte dal quello azzurro e dal quello in verde.</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#generazione-degli-implicanti","title":"Generazione degli implicanti","text":"<p>L'espressione finale risultante dalla mappa di Karnaugh sar\u00e0 una somma di implicanti:</p> \\[ f = \\sumton{I} \\] <p>Ciascun raggruppamento individuato dar\u00e0 luogo a un singolo implicante. Il singolo termine \\(I_i\\), corrispondente a un \\(k\\)-cubo, \u00e8 detto implicante in quanto implica la funzione \\(f\\): se \\(I_i\\) \u00e8 vero allora \\(f\\) \u00e8 vero. Questo, \"se \\(I_i\\) \u00e8 vero allora \\(f\\) \u00e8 vero\", \u00e8 corretto in virt\u00f9 delle propriet\u00e0 dell'OR (somma logica), cio\u00e8 che una qualsiasi somma logica \u00e8 vera se almeno uno degli elementi che la compone \u00e8 vero.</p> <p>Ma come si generano gli implicanti a partire dai raggruppamenti?</p> <p> </p> <p>L'implicante di un raggruppamento composto da una singola cella \u00e8 equivalente al mintermine di tale cella, in questo caso:</p> \\[     \\begin{array}{ cccc }         A &amp; B &amp; C &amp; D \\\\ \\hline         0 &amp; 1 &amp; 1 &amp; 1     \\end{array} \\] <p>Ovvero:</p> \\[ \\bar{A}BCD \\] <p>La mappa di Karnaugh, quindi, nel caso in cui vengano scelti tutti i raggruppamenti con celle singole, corrisponde perfettamente alla somma di mintermini:</p> <p> </p> <p>Che corrispondono, dall'alto verso il basso, a:</p> \\[     \\begin{array}{ cccc }         A &amp; B &amp; C &amp; D \\\\ \\hline         1 &amp; 0 &amp; 0 &amp; 0     \\end{array}     \\qquad     \\begin{array}{ cccc }         A &amp; B &amp; C &amp; D \\\\ \\hline         0 &amp; 1 &amp; 1 &amp; 1     \\end{array}     \\qquad     \\begin{array}{ cccc }         A &amp; B &amp; C &amp; D \\\\ \\hline         1 &amp; 0 &amp; 1 &amp; 0     \\end{array} \\] <p>ovvero a:</p> \\[     A\\bar{B}\\bar{C}\\bar{D}     \\qquad     \\bar{A}BCD     \\qquad     A\\bar{B}C\\bar{D} \\] <p>e dunque:</p> \\[ f = A\\bar{B}\\bar{C}\\bar{D} + \\bar{A}BCD + A\\bar{B}C\\bar{D} \\] <p>L'implicante di un raggruppamento composto da pi\u00f9 celle \u00e8 calcolato in maniera analoga al mintermine ma utilizzando solo le variabili che mantengono un valore costante:</p> <p> </p> <p>In questo caso si ha</p> \\[     \\begin{array}{ cccc }         A &amp; B &amp; C &amp; D \\\\ \\hline         0 &amp; 1 &amp; 1 &amp; 1 \\\\         1 &amp; 1 &amp; 1 &amp; 1     \\end{array} \\] <p>che sarebbe \\(BCD\\). Questo perch\u00e9:</p> <ul> <li>\\(A\\) varia (\\(0\\)-\\(1\\)), viene esclusa;</li> <li>\\(B\\) \u00e8 costante (\\(1\\)), viene mantenuta;</li> <li>\\(C\\) \u00e8 costante (\\(1\\)), viene mantenuta;</li> <li>\\(D\\) \u00e8 costante (\\(1\\)), viene mantenuta.</li> </ul> <p>Altri due esempi:</p> <p> </p> <p>Nel primo raggruppamento si ha:</p> \\[     \\begin{array}{ cccc }         A &amp; B &amp; C &amp; D \\\\ \\hline         0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         1 &amp; 1 &amp; 0 &amp; 0 \\\\         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 1 &amp; 0 &amp; 1 \\\\         1 &amp; 1 &amp; 0 &amp; 1 \\\\         1 &amp; 0 &amp; 0 &amp; 1     \\end{array} \\] <p>poich\u00e9</p> <ul> <li>\\(A\\) varia (\\(0\\)-\\(1\\)), viene esclusa;</li> <li>\\(B\\) varia (\\(0\\)-\\(1\\)), viene esclusa;</li> <li>\\(C\\) \u00e8 costante (\\(0\\)), viene mantenuta;</li> <li>\\(D\\) varia (\\(0\\)-\\(1\\)), viene esclusa.</li> </ul> <p>Nel secondo raggruppamento, invece, si ha:</p> \\[     \\begin{array}{ cccc }         A &amp; B &amp; C &amp; D \\\\ \\hline         1 &amp; 1 &amp; 1 &amp; 1 \\\\         1 &amp; 0 &amp; 1 &amp; 1 \\\\         1 &amp; 1 &amp; 1 &amp; 0 \\\\         1 &amp; 0 &amp; 1 &amp; 0     \\end{array} \\] <p>questo poich\u00e9:</p> <ul> <li>\\(A\\) \u00e8 costante (\\(1\\)), viene mantenuta;</li> <li>\\(B\\) varia (\\(0\\)-\\(1\\)), viene esclusa;</li> <li>\\(C\\) \u00e8 costante (\\(1\\)), viene mantenuta;</li> <li>\\(D\\) varia (\\(0\\)-\\(1\\)), viene esclusa.</li> </ul> <p>Implicante primo</p> <p>Un implicante \u00e8 detto implicante primo di \\(f\\) se non implica un altro implicante di \\(f\\). Un implicante primo corrisponde a un \\(k\\)-cubo di dimensione massima, ovvero un \\(k\\)-cubo che non \u00e8 contenuto per intero in un \\(x\\)-cubo di dimensioni maggiori.</p> <p>Ovvero:</p> <p> </p> <p>Gli implicanti prodotti dai raggruppamenti magenta e beige non sono primi, in quanto sono contenuti interamente nel raggruppamento blu. Il raggruppamento blu \u00e8 un \\(2\\)-cubo, mentre il raggruppamento magenta e quello beige sono \\(1\\)-cubi. Il raggruppamento blu genera un implicante primo, in quanto \\(k\\)-cubo di dimensione maggiore.</p> <p>\u00c8 semplice dimostrare che gli implicanti corrispondenti ai raggruppamenti rosso e giallo implicano quello corrispondente al raggruppamento azzurro (pertanto non sono primi).</p> <p>Siano:</p> \\[     {\\color{blue}\\bar{A}D}     \\qquad     {\\color{magenta}\\bar{A}\\bar{B}D}     \\qquad     {\\color{beige}\\bar{A}BD} \\] <p>Sia \\({\\color{magenta}\\bar{A}\\bar{B}D} \\implies {\\color{blue}\\bar{A}D}\\), ovvero che se \\({\\color{magenta}\\bar{A}\\bar{B}D}\\) \u00e8 vero, allora \\({\\color{blue}\\bar{A}D}\\) \u00e8 vero. Allora, per propriet\u00e0 associativa, \\(\\bar{A}\\bar{B}D = (\\bar{A}D)\\bar{B}\\). dalle propriet\u00e0 dell'AND deriva che se \\((\\bar{A}D)\\bar{B}\\) \u00e8 vero, allora lo sono sia \\(\\bar{A}D\\) che \\(\\bar{B}\\). Quindi \\((\\bar{A}D)\\) \u00e8 vero.</p> <p>Sia \\({\\color{beige}\\bar{A}BD} \\implies {\\color{blue}\\bar{A}D}\\) ovvero che se \\({\\color{beige}\\bar{A}BD}\\) \u00e8 vero allora \\({\\color{blue}\\bar{A}D}\\) \u00e8 vero. Allora, per propriet\u00e0 associativa, \\(\\bar{A}BD = (\\bar{A}D)B\\). dalle propriet\u00e0 dell'AND, se \\((\\bar{A}D)B\\) \u00e8 vero, allora lo sono sia \\(\\bar{A}D\\) che \\(B\\). Quindi \\(\\bar{A}D\\) \u00e8 vero.</p> <p>Infatti gli implicanti dei raggruppamenti rosso e giallo possono essere semplificati algebricamente nell'implicante primo del raggruppamento azzurro:</p> \\[     {\\color{magenta}\\bar{A}\\bar{B}D}         + {\\color{beige}\\bar{A}BD} = \\bar{A}D(\\bar{B} + B)                                    = \\bar{A}D(1)                                    = {\\color{blue}\\bar{A}D} \\] <p>Come gi\u00e0 affermato in precedenza, i raggruppamenti di destra nell'esempio di sotto sono preferibili a quelli di sinistra. Ci\u00f2 perch\u00e9 gli implicanti dei raggruppamenti di destra sono pi\u00f9 semplici</p> <p> </p> <p>e sono ricavabili algebricamente dagli implicanti dei raggruppamenti di sinistra, scomponendo il raggruppamento azzurro nelle sue parti, applicando le propriet\u00e0 e ricomponendo il raggruppamento azzurro:</p> \\[     \\begin{align}         f = {\\color{blue}\\bar{A}D} + {\\color{magenta}ABCD}             &amp;= {\\color{blue}(\\bar{A}\\bar{B}\\bar{C}D + \\bar{A}B\\bar{C}D                 + \\bar{A}\\bar{B}CD + \\bar{A}BCD)} + \\color{magenta}{ABCD}   \\\\             &amp;= \\bar{A}\\bar{B}\\bar{C}D + \\bar{A}B\\bar{C}D                 + \\bar{A}\\bar{B}CD + \\bar{A}BCD + ABCD                      \\\\             &amp;= \\bar{A}\\bar{B}\\bar{C}D + \\bar{A}\\bar{B}CD                 + \\bar{A}BCD + ABCD + \\bar{A}BCD                            \\\\             &amp;= \\bar{A}\\bar{B}\\bar{C}D + \\bar{A}B\\bar{C}D                 + \\bar{A}\\bar{B}CD + \\bar{A}BCD + ABCD + \\bar{A}BCD         \\\\             &amp;= \\bar{A}\\bar{B}\\bar{C}D + \\bar{A}B\\bar{C}D                 + \\bar{A}\\bar{B}CD + \\bar{A}BCD + BCD(A + \\bar{A})          \\\\             &amp;= \\bar{A}\\bar{B}\\bar{C}D + \\bar{A}B\\bar{C}D                 + \\bar{A}\\bar{B}CD + \\bar{A}BCD + BCD(1)                    \\\\             &amp;= \\bar{A}\\bar{B}\\bar{C}D + \\bar{A}B\\bar{C}D                 + \\bar{A}\\bar{B}CD + \\bar{A}BCD + BCD                       \\\\             &amp;= {\\color{blue}(\\bar{A}\\bar{B}\\bar{C}D + \\bar{A}B\\bar{C}D                 + \\bar{A}\\bar{B}CD + \\bar{A}BCD)} + {\\color{green}BCD}      \\\\             &amp;= {\\color{blue}\\bar{A}D} + {\\color{green}BCD}                  \\\\             &amp;= f'     \\end{align} \\] <p>\\({\\color{blue}\\bar{A}D}\\) e \\({\\color{green}BCD}\\) sono quindi ambedue implicanti primi (anche se hanno \\({\\color{red}\\bar{A}BCD}\\) in comune). Infatti, l'uno non implica l'altro. Provando a dimostrare che l'uno implichi l'altro si ha:</p> <ol> <li>\\({\\color{blue}\\bar{A}D} \\implies {\\color{green}BCD}\\) ovvero che se    \\({\\color{blue}\\bar{A}D}\\) \u00e8 vero allora \\({\\color{green}BCD}\\) \u00e8 vero;</li> <li>\\({\\color{green}BCD} \\implies {\\color{blue}\\bar{A}D}\\) ovvero che se    \\({\\color{green}BCD}\\) \u00e8 vero allora \\({\\color{blue}\\bar{A}D}\\) \u00e8 vero.</li> </ol> <p>Allora:</p> <ol> <li>Per propriet\u00e0 associativa \\(\\bar{A}D = (\\bar{A})(D)\\). Sapendo che    \\(\\bar{A}D\\) \u00e8 vero, allora sia \\(\\bar{A}\\) che \\(D\\) sono vere. Pertanto    \\(BCD = BC1 = BC\\). Si vuole quindi ora dimostrare che \\(\\bar{A}D \\implies BC\\),    ovvero che \\(1 \\implies BC\\), ma non vi sono elementi sulla veridicit\u00e0 di \\(B\\)    e \\(C\\), pertanto l'uno non implica l'altro.</li> <li>Per propriet\u00e0 associativa \\(BCD = (B)(C)(D)\\). Sapendo che \\(BCD\\) \u00e8 vero,    allora sia \\(B\\) che \\(C\\) che \\(D\\) sono vere. Pertanto    \\(\\bar{A}D = \\bar{A}1 = \\bar{A}\\). Si vuole quindi ora dimostrare che    \\(BCD \\implies \\bar{A}\\), ovvero che \\(1 \\implies \\bar{A}\\), ma non vi sono    elementi sulla veridicit\u00e0 di \\(A\\), pertanto l'uno non implica l'altro.</li> </ol>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#condizioni-di-indifferenza","title":"Condizioni di indifferenza","text":"<p>\u00c8 possibile avere delle funzioni booleane nelle quali l'output della funzione per una certa configurazione, per diverse ragioni possibili (es. \u00e8 una configurazione non ammessa), non \u00e8 di interesse. Tale condizione prende il nome di condizione di indifferenza per la specifica configurazione.</p> <p>Le condizioni di indifferenza sono generalmente indicate con la lettera greca phi \\(\\varphi\\) (che idealmente rappresenta uno zero e un uno sovrapposti), ma anche con \\(X\\), \\(\\delta\\), \\(\\ast\\), etc.</p> <p> </p> <p>Le condizioni di indifferenza rappresentano quindi un jolly: verranno considerate se aiutano (in verde) a costituire un raggruppamento o a costituire un raggruppamento migliore, non verranno considerate se non forniscono un contributo (in rosso).</p> <p>Non hanno senso raggruppamenti di sole condizioni di indifferenza</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#dividere-in-piu-mappe","title":"Dividere in pi\u00f9 mappe","text":"<p>Utilizzando il Teorema di Shannon, si pu\u00f2 dividere una qualsiasi mappa di Karnaugh a \\(n\\) variabili in due mappe di Karnaugh a \\(n \u2212 1\\) variabili. Ad esempio, dividendo una mappa a \\(4\\) variabili \\(A\\), \\(B\\), \\(C\\) e \\(D\\) sulla base della variabile \\(C\\):</p> <p> </p> <p>Agli implicanti ottenuti dalle singole mappe sar\u00e0 quindi necessario moltiplicare il termine \\(C\\), sulla base della mappa:</p> <ul> <li>\\(C\\) per la mappa con \\(C = 1\\);</li> <li>\\(\\bar{C}\\) per la mappa con \\(C = 0\\).</li> </ul> <p>Tale approccio viene applicato per utilizzare le mappe di Karnaugh con \\(5\\) variabili (due mappe da \\(4\\) variabili) e con \\(6\\) variabili (quattro mappe da (4) variabili).</p> <p>Le due mappe separate possono essere viste in maniera sovrapposta, consentendo dei raggruppamenti cubici: si \u00e8 parlato, infatti, di \\(k\\)-cubi (in realt\u00e0 sono parallelepipedi):</p> <p> </p> <p>Queste due mappe \u00e8 come se fossero sovrapposte, formando dunque:</p> \\[     \\begin{array}{c}         \\begin{array}{ ccccc }             A &amp; B &amp; C &amp; D &amp; E \\\\ \\hline             0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\             0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\             0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\\\             0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ \\hline             0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\\\             0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\\\             0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\\\             0 &amp; 1 &amp; 1 &amp; 1 &amp; 1         \\end{array} \\\\         {\\color{magenta}\\bar{A}D}     \\end{array} %     \\qquad\\qquad %     \\begin{array}{c}         \\begin{array}{ ccccc }             A &amp; B &amp; C &amp; D &amp; E \\\\ \\hline             1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\\\ \\hline             1 &amp; 0 &amp; 1 &amp; 1 &amp; 1         \\end{array} \\\\         {\\color{yellow}A\\bar{B}CD}     \\end{array} \\] <p>Nota Bene</p> <p>Quelli proposti non sono i raggruppamenti migliori, in quanto si sarebbe potuto operare un raggruppamento di \\(4\\) elementi, ovvero il raggruppamento giallo con \\(\\bar{A}\\bar{B}CD\\bar{E}\\) e \\(\\bar{A}\\bar{B}CDE\\).</p>"},{"location":"Anno_I/AESO/AE4_expr_booleane_karnaugh/#maxtermini","title":"Maxtermini","text":"<p>\u00c8 possibile, in maniera speculare, utilizzare le mappe di Karnaugh con gli zeri, individuando un corrispettivo speculare degli implicanti analogo ai maxtermini:</p> <p> </p> <p>Cos\u00ec si ha:</p> \\[     \\begin{array}{ c }         \\begin{array}{ cccc }             A &amp; B &amp; C &amp; D \\\\ \\hline             0 &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 1 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; 1 \\\\             0 &amp; 1 &amp; 0 &amp; 1         \\end{array} \\\\         {\\color{blue}A + C}     \\end{array} %     \\qquad %     \\begin{array}{ c }         \\begin{array}{ cccc }             A &amp; B &amp; C &amp; D \\\\ \\hline             0 &amp; 1 &amp; 1 &amp; 1 \\\\             1 &amp; 1 &amp; 1 &amp; 1         \\end{array} \\\\         {\\color{magenta}\\bar{B} + \\bar{C} + \\bar{D}}     \\end{array} %     \\qquad %     \\begin{array}{ c }         \\begin{array}{ cccc }             A &amp; B &amp; C &amp; D \\\\ \\hline             0 &amp; 0 &amp; 0 &amp; 0 \\\\             0 &amp; 0 &amp; 0 &amp; 1 \\\\             0 &amp; 0 &amp; 1 &amp; 1 \\\\             0 &amp; 0 &amp; 1 &amp; 0         \\end{array} \\\\         {\\color{green}A + B}     \\end{array} \\] <p>Dunque:</p> \\[     f = (A + C)(\\bar{B} + \\bar{C} + \\bar{D})(A + B). \\] <ol> <li> <p>\u00c8 attribuito a Shannon nonostante sia stato enunciato prima da George Boole.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/","title":"Formati di istruzioni e indirizzamento","text":""},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#architetture-cisc-e-risc","title":"Architetture CISC e RISC","text":"<p>L'architettura CISC:</p> <p>\u00c8 un'architettura per microprocessori formata da un set di istruzioni contenente, appunto, istruzioni in grado di eseguire operazioni complesse (es. lettura di un dato in memoria, modifica e salvataggio direttamente in memoria tramite una singola istruzione). Ne sono un esempio i processori dell'architettura x86 di Intel.</p> <p>Spesso traducono l'istruzione da CISC in un lotto di operazioni elaborate come RISC. Sovente sono microprogrammate, ovvero all'interno della CPU stessa \u00e8 presente un programma che traduce le istruzioni in fase di decodifica.</p> <p>I vantaggi dell'architettura CISC sono che avvicinano il linguaggio macchina ai linguaggi di alto livello.</p> <p>L'architettura RISC \u00e8 un'architettura per microprocessori che sceglie un set di istruzioni pi\u00f9 semplice e lineare. I suoi vantaggi sono che eseguono le operazioni in maniera pi\u00f9 veloce rispetto alla CISC.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#tipi-di-istruzioni","title":"Tipi di istruzioni","text":"<p>Ve ne sono molteplici.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#istruzioni-di-trasferimento-dati","title":"Istruzioni di trasferimento dati","text":"<p>\u00c8 fondamentale per poter copiare dati da una locazione all'altra. Un esempio pratico sono le istruzioni di assegnamento (es. <code>A = B</code> copia in <code>A</code> i bit contenuti nella locazione di <code>B</code> in quella di <code>A</code>).</p> <p>I dati possono avere due sorgenti: la memoria o i registri, ergo ci sono quattro tipi di trasferimenti possibili. Alcune architetture usano un'unica istruzione per tutte le tipologie, altre ad esempio utilizzano le seguenti istruzioni:</p> <ul> <li><code>LOAD</code>: copia dalla memoria ai registri;</li> <li><code>STORE</code>: copia dai registri alla memoria</li> <li><code>MOVE</code>: copia dai registri ai registri;</li> <li>generalmente non \u00e8 prevista un'istruzione per copiare dalla memoria alla   memoria.</li> </ul>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#operazioni-binarie","title":"Operazioni binarie","text":"<p>Producono un risultato dalla combinazione di due operandi. Tutti gli ISA, ad esempio posseggono operazioni per somma e sottrazione tra interi.</p> <p>Tra le operazioni binarie vi sono anche le operazioni booleane. In genere sono disponibili le operazioni AND, OR (e NOT, che \u00e8 unario) e a volte si trovano anche XOR, NOR e NAND. Queste ultime operazioni sono bitwise: effettuano il calcolo bit a bit.</p> <p>Per ottenere tutte le operazioni booleane \u00e8 sufficiente avere a disposizione il NOT e un'operazione tra AND e OR:</p> <ul> <li>tramite i teoremi di De Morgan \u00e8 possibile ricavare l'OR dall'AND e viceversa;</li> <li>si utilizzano NOT, OR e AND per generare le altre funzioni booleane mediante   le equivalenze logiche (ad esempio \\(A \\lxor B = A\\bar{B} + \\bar{A}B\\))<sup>1</sup>;</li> <li>si utilizzano le mappe di Karnaugh o un sistema equivalente per esprimere la   funzione booleana.</li> </ul> <p>Un uso importante dell'AND \u00e8 l'estrazione della parola. Ci\u00f2 avviene mediante l'utilizzo di un AND tra il dato originale e una costante, detta maschera, che identifica la parola da estrarre:</p> \\[     \\begin{array}{ r|cccc }         A                &amp; 11011101 &amp; 01101011 &amp; 00101101 &amp; 10111011 \\\\ \\hline         B\\;(\\text{mask}) &amp; 00000000 &amp; 11111111 &amp; 00000000 &amp; 00000000 \\\\ \\hline         A \\land B        &amp; 00000000 &amp; 01101011 &amp; 00000000 &amp; 00000000 \\\\     \\end{array} \\] <p>La maschera si comporr\u00e0 di uno dove vi sono i bit da estrarre e di zero negli altri bit. Il risultato verr\u00e0 infine fatto scorrere in modo da isolare a destra il risultato (nell'esempio sopra: di \\(16 \\bbit\\)).</p> <p>L'uso dell'OR \u00e8 quello di impacchettare bit in una parola, ovvero l'operazione complementare all'estrazione:</p> \\[     \\begin{array}{ r|cccc }         A        &amp; 11011101 &amp; 01101011 &amp; 00101101 &amp; 00000000 \\\\ \\hline         B        &amp; 00000000 &amp; 00000000 &amp; 00000000 &amp; 11011010 \\\\ \\hline         A \\lor B &amp; 11011101 &amp; 01101011 &amp; 00101101 &amp; 11011010 \\\\     \\end{array} \\] <p>Per sostituire una parola (o dei bit) si utilizzano in sequenza estrazione e impacchettamento:</p> \\[     \\begin{array}{ r|cccc }         A                 &amp; 11011101 &amp; 01101011 &amp; 00101101 &amp; 11011010 \\\\ \\hline         B\\; (\\text{mask}) &amp; 11111111 &amp; 11111111 &amp; 11111111 &amp; 00000000 \\\\ \\hline         A \\land B         &amp; 11011101 &amp; 01101011 &amp; 00101101 &amp; 00000000 \\\\ \\hline         C                 &amp; 00000000 &amp; 00000000 &amp; 00000000 &amp; 01101011 \\\\ \\hline         A \\land B \\lor C  &amp; 11011101 &amp; 01101011 &amp; 00101101 &amp; 01101011     \\end{array} \\] <p>La sequenza \\(B\\) viene utilizzata come maschera per cancellare i bit da sostituire (\\(A \\land B\\) \u2013 estrazione dei bit da preservare), i nuovi bit vengono aggiunti tramite \\(C\\) (impacchettamento mediante OR \\(C\\)).</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#operazioni-unarie","title":"Operazioni unarie","text":"<p>Tra le operazioni unarie si trova il NOT che calcola il complemento binario (gli \\(0\\) diventano \\(1\\) e viceversa) e il NEG che calcola l'inverso del valore numerico (es \\(5\\) diventa \\(\u20135\\)). Le due operazioni, nel caso in cui i numeri siano rappresentati in complemento a uno, coincidono. In tutti gli altri casi il NEG dipende ovviamente dall'implementazione dei numeri.</p> <p>Tra le operazioni unarie si trovano anche lo scorrimento (shift) e la rotazione:</p> \\[     \\begin{array}{ r|c }         A                      &amp; 0100\\; 0000\\; 0101\\; 01{\\color{teal}10} \\\\ \\hline         \\to 2\\bit              &amp; {\\color{red}00}01\\;  0000\\; 0001\\; 0101 \\\\ \\hline         \\curvearrowright 2\\bit &amp; {\\color{teal}10}01\\; 0000\\; 0001\\; 0101 \\\\     \\end{array} \\] <p>Nello shifting, i bit che fuoriescono dalla parola si perdono e gli spazi vuoti che si generano nella direzione opposta allo shifting vengono riempiti con zeri.</p> <p>Sono possibili anche shift e rotazioni (verso destra) con l'estensione del segno: in tal caso le posizioni vuote che si generano sulla sinistra vengono riempite con il bit del segno originale. Le moltiplicazioni e le divisioni per \\(2^k\\) sono un'applicazione importante dello shifting (nei numeri positivi). Le operazioni di rotazione sono generalmente utilizzate insieme alle gi\u00e0 citate operazioni di estrazione e impacchettamento per lo spostamento dei bit. Le operazioni di rotazione non comportano perdita di informazione a differenza delle operazioni di shifting. Tipi di istruzioni</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#istruzioni-di-confronto","title":"Istruzioni di confronto","text":"<p>Tra queste:</p> <ul> <li>uguaglianza tra parole;</li> <li>verificare se una certa parola \u00e8 zero (molto usata);</li> <li>confronto di maggioranza o minoranza tra numeri (dipende dall'implementazione   del numero).</li> </ul>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#istruzioni-di-inputoutput","title":"Istruzioni di input/output","text":"<p>Interagiscono con i dispositivi di I/O e sono di tre tipologie:</p> <ul> <li>I/O programmato con attesa attiva;</li> <li>I/O interrupt driven, che viene innescato dagli interrupt;</li> <li>I/O con DMA, ovvero l'I/O programmato ma viene aggiunto il componente chip   DMA che ha accesso diretto al bus.</li> </ul>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#istruzioni-di-salto-jump","title":"Istruzioni di salto (JUMP)","text":"<p>Il codice \u00e8 scritto mediante l'ausilio di etichette, che definiscono \"sezioni\" del programma. Le istruzioni di salto consentono al programma di passare da una sezione all'altra. Si dividono in:</p> <ul> <li>salti incondizionati: (<code>GOTO</code>) si passa direttamente ad un'altra sezione   del programma;</li> <li>salti condizionati: si verifica una condizione e si passa ad un'altra   sezione del programma a seconda del risultato della verifica (es. pratico \u00e8   l'<code>if</code>). Viene generalmente implementato mediante il calcolo della condizione   e la memorizzazione del risultato in un registro, successivamente viene effettuato   il salto condizionato se il valore del registro \u00e8 \\(0\\) o \\(1\\).</li> </ul> <p>Le istruzioni di ciclo vengono convertite in salti condizionati.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#spaghetti-code","title":"Spaghetti code","text":"<p>Spaghetti code \u00e8 un termine dispregiativo per il codice sorgente di quei programmi per computer che hanno una struttura di controllo del flusso complessa e/o incomprensibile, con uso esagerato ed errato di <code>GOTO</code>, eccezioni, thread e altri costrutti di branching (diramazione del controllo) non strutturati.</p> <p>Il suo nome deriva dal fatto che questi tipi di codice tendono a assomigliare a un piatto di spaghetti, ovvero un mucchio di fili intrecciati ed annodati.<sup>\\(\\dagger\\)</sup></p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#chiamata-a-funzione","title":"Chiamata a funzione","text":"<p>Quando una funzione termina la propria esecuzione, il programma deve riprendere dall'istruzione successiva alla chiamata a funzione. Dunque l'indirizzo di ritorno deve essere memorizzato oppure passato alla funzione chiamata.</p> <p>Il meccanismo cos\u00ec espresso pu\u00f2 essere fallace nei casi di funzione che chiama funzione oppure di ricorsione (ovvero una funzione che invoca s\u00e9 stessa), in quanto potrebbe essere sovrascritto l'indirizzo di ritorno. \u00c8 pertanto necessario che l'indirizzo di ritorno venga memorizzato ogni volta in una locazione differente. Si utilizza infatti lo stack dei record di attivazione (detto anche stack di attivazione oppure, record di attivazione).</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#stack-di-attivazione-fattoriale-ricorsivo","title":"Stack di attivazione: fattoriale ricorsivo","text":"<p>main main fatt(2) main fatt(2) fatt(1) main fatt(2) main</p> <ol> <li>Il main invoca la funzione ricorsiva fattoriale (fatt) con argomento n=2;</li> <li>La funzione fatt invoca s\u00e9 stessa con n=1 e viene generato un nuovo record;</li> <li>fatt(1) restituisce il valore 1 e il Program Counter si sposta all'indirizzo    di ritorno \u2013 viene rimosso il record di fatt(1);</li> <li>fatt(2) riceve il valore di output di fatt(1) e produce il proprio output \u2013    si torna al main tramite il suo indirizzo di ritorno e viene rimosso il record    di fatt(2);</li> <li>Il main riceve il valore di output di fatt(2) e riprende la sua normale    esecuzione;</li> </ol>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#formati-di-istruzione-e-indirizzamento","title":"Formati di istruzione e indirizzamento","text":"<pre><code>flowchart LR\n    subgraph hlng[High-level Language]\n        cJava[\"temp = v[k];\\nv[k] = v[k+1]\\nv[k+1] = temp;\"];\n        fortran[\"TEMP = V(K)\\nV(K) = V(K+1)\\nV(K+1) = TEMP\"];\n    end\n\n    subgraph alng[Assembly Language]\n        assembly[\"lw $to, 0($2)\\nlw $t1, 4($2)\\nsw $t1,  0($2)\\nsw $t0,  4($2)\"];\n    end\n\n    subgraph mlng[Machine Language]\n        machine[\"0000 1001 1100 0110 1010 1111 0101 1000\\n1010 1111 0101 1000 0000 1001 1100 0110\\n1100 0110 1010 1111 0101 1000 0000 1001\\n 0101 1000 0000 1001 1100 0110 1010 1111\"]\n    end\n\n    cJava --&gt;|\"C/Java\\ncompiler\"| assembly;\n    fortran --&gt;|\"FORTRAN\\ncompiler\"| assembly;\n    assembly --&gt;|\"MISC\\nassembler\"| machine;\n\n    classDef mono text-align:left,font-family:Fira Code,font-size:10pt;\n    classDef monomachine text-align:left,font-family:Fira Code,font-size:9.5pt;\n    class cJava,fortran,assembly mono;\n    class machine monomachine;</code></pre> <p>Un'istruzione si compone di:</p> <ul> <li>un OPCODE, che identifica l'istruzione da eseguire;</li> <li>altre informazioni quali la provenienza degli operandi e la destinazione dei   risultati.</li> </ul> <p>L'argomento che tratta la provenienza degli operandi, ovvero la loro residenza in memoria, prende il nome di indirizzamento.</p> <p>Un esempio in MIPS assembler \u00e8 il seguente:</p> Label OPCODE Destinazione \\(\\rm OP_1\\) \\(\\rm OP_1\\) Commento <code>move</code> <code>$a0,</code> <code>$0</code> <code># $a0 = 0</code> <code>li</code> <code>$t0,</code> <code>99</code> <code># $t0 = 99</code> ciclo: <code># definisce un punto chiamato ciclo</code> <code>add</code> <code>$a0,</code> <code>$a0,</code> <code>$t0</code> <code># $a0 = $a0 + $t0</code> <code>addi</code> <code>$t0,</code> <code>$t0,</code> <code>-1</code> <code># $t0 = $t0 \u2013 1</code> <code>bnez</code> <code>$t0,</code> <code>ciclo</code> <code># if ($t0 != zero) vai a ciclo</code> <code>li</code> <code>$v0,</code> <code>1</code> <code># stampa il valore in $a0</code> <code>syscall</code> <code>li</code> <code>$v0,</code> <code>10</code> <code># termina il programma</code> <code>syscall</code>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#formati-di-istruzione","title":"Formati di istruzione","text":"<p>Un esempio di quattro diversi formati di istruzioni (si consideri a parit\u00e0 di dimensione):</p> \\[     \\begin{array}{ r l }         A &amp;             \\begin{array}{ |c| } \\hline                 \\hspace{2.5cm}\\text{OPCODE}\\hspace{2.3cm}                    \\\\ \\hline             \\end{array} \\\\         B &amp;             \\begin{array}{ |c|c| } \\hline                 \\text{OPCODE} &amp; \\hspace{1.6cm} \\text{IND}_1 \\hspace{1.6cm}   \\\\ \\hline             \\end{array} \\\\         C &amp;             \\begin{array}{ |c|c|c| } \\hline                 \\text{OPCODE} &amp; ~~~ \\text{IND}_1 ~~~~ &amp; ~~~ \\text{IND}_2 ~~~ \\\\ \\hline             \\end{array} \\\\         D &amp;             \\begin{array}{ |c|c|c|c| } \\hline                 \\text{OPCODE} &amp; \\text{IND}_1 &amp; \\text{IND}_2 &amp; \\text{IND}_3   \\\\ \\hline             \\end{array}     \\end{array} \\] <p>Rispettivamente:</p> <ul> <li>A \u00e8 un'istruzione senza indirizzi</li> <li>B \u00e8 un'istruzione con un solo operando</li> <li>C \u00e8 un'istruzione con due operandi</li> <li>D \u00e8 un'istruzione con tre operandi</li> </ul>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#alcuni-criteri-progettuali","title":"Alcuni criteri progettuali","text":"<p>A parit\u00e0 di progetto, istruzioni pi\u00f9 corte sono preferibili per vari motivi.</p> <p>Innanzitutto un programma con istruzioni a \\(32 \\bit\\) occupa il doppio dello spazio in memoria dello stesso programma con istruzioni a \\(16 \\bit\\). Tuttavia tale fattore potrebbe risultare sempre meno preminente in futuro, in quanto il costo della memoria va sempre pi\u00f9 diminuendosi. Dall'altro lato, le dimensioni dei software aumentano. Altro fattore da tenere in considerazione, per\u00f2, \u00e8 l'ampiezza delle bande di memoria che trasferiscono i dati.</p> <p>Le istruzioni pi\u00f9 corte sono elaborate pi\u00f9 velocemente.</p> <p>\u00c8 necessario prevedere spazio sufficiente per rappresentare tutte le istruzioni desiderate:</p> <ul> <li>se si richiedono \\(2^n\\) possibili operazioni differenti, vanno rappresentate   con almeno \\(n\\) bit destinati all'OPCODE;</li> <li>\u00e8 necessario considerare degli OPCODE in eccedenza per eventuali evoluzioni   del progetto.</li> </ul> <p>Dimensione degli indirizzi:</p> <ul> <li> <p>la dimensione degli indirizzi dipende dalla dimensione delle parole in memoria.   Siano \\(\\xi\\) un indirizzo, \\(m\\) la memoria e \\(w\\) una parola, si ha:</p> \\[     n_\\xi = \\frac{\\dim m}{\\dim w}     \\qquad     \\dim \\xi = \\ceil{\\log_2 n_\\xi} \\] </li> <li> <p>scegliere la dimensione delle parole tra pi\u00f9 o meno bit comporta vantaggi e   svantaggi in entrambe le scelte, nei quali per\u00f2 questo corso non entra nel   dettaglio.</p> </li> </ul> <p>Si consideri un'istruzione lunga \\(n + k \\bbit\\), dove \\(n\\) \u00e8 il numero di bit destinati all'OPCODE e \\(k\\) il numero di bit destinati a un operando:</p> <ul> <li>si hanno a disposizione \\(2^n\\) istruzioni;</li> <li>si hanno a disposizione \\(2^k\\) parole in memoria da indirizzare.</li> </ul> <p>Lo stesso spazio potrebbe essere diviso in \\((n \u2212 1) \\bbit\\) dedicati all'OPCODE e \\((k + 1) \\bbit\\) dedicati all'operando, dimezzando il set di istruzioni ma raddoppiando la memoria raggiungibile.</p> <p>Allo stesso modo, si potrebbe dividere in \\((n + 1) \\bbit\\) dedicati all'OPCODE e \\((k - 1) \\bbit\\) dedicati all'operando, raddoppiando il set di istruzioni ma dimezzando la memoria raggiungibile.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#codice-operativo-espandibile","title":"Codice operativo espandibile","text":"<p>Con questo schema \u00e8 possibile rappresentare \\(24\\) istruzioni che operano con fino a tre operandi in memoria.</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}       \\\\ \\hline %         \\begin{array}{ c|c|c|c }     ~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~   \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp;  ~~~ &amp; ~~~  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}    \\\\ \\hline %         \\text{OPCODE} &amp; \\text{IND}_1 &amp; \\text{IND}_2 &amp; \\text{IND}_3          \\\\ \\hline     \\end{array} \\] <p>Per aumentare il lotto di istruzioni \u00e8 necessario aumentare i bit destinati all'OPCODE, ma le operazioni che necessitano di meno operandi comportano uno spreco dello spazio destinato agli altri operandi. La soluzione sta nell'utilizzare il codice operativo espandibile, ovvero il codice operativo si espande utilizzando i bit degli operandi.</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}        \\\\ \\hline %         \\begin{array}{ c|c|c|c }     ~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~   \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp;  ~~~ &amp; ~~~  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}     \\\\ \\hline %         \\text{OPCODE (lotto 1)} &amp; \\text{IND}_1 &amp; \\text{IND}_2 &amp; \\text{IND}_3 \\\\ \\hline     \\end{array} \\] <p>La configurazione \\(1111\\) nei bit destinati all'OPCODE indica che l'istruzione \u00e8 nel formato OPCODE + due operandi:</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}       \\\\ \\hline %         \\begin{array}{ c|c|c|c }      1 &amp; ~ 1~ &amp; ~ 1~ &amp;  1   \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp;  ~~~ &amp; ~~~  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}    \\\\ \\hline %         \\text{conf. riservata}             &amp; \\text{OPCODE (lotto 2)} &amp; \\text{IND}_1 &amp; \\text{IND}_2         \\\\ \\hline     \\end{array} \\] <p>Di fatto l'OPCODE passa a \\(8 \\bbit\\) \\((\\bin{1111\\text{xxxx}})\\) nel secondo lotto di istruzioni. Utilizzando questo meccanismo il set delle istruzioni viene espanso a:</p> <ul> <li>\\(2^4 \u2212 1\\) istruzioni con tre operandi e</li> <li>\\(2^4\\) istruzioni con due operandi;</li> </ul> <p>Il meccanismo pu\u00f2 essere ovviamente reiterato, ottenendo, ad esempio, con \\(16 \\bbit\\) di istruzione e indirizzi a \\(4 \\bbit\\).</p> <p>Si ottengono \\(2^4 - 1\\) istruzioni a tre operandi:</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}       \\\\ \\hline %         \\begin{array}{ c|c|c|c }     ~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~   \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp;  ~~~ &amp; ~~~  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}    \\\\ \\hline %         \\text{OPCODE} &amp; \\text{IND}_1 &amp; \\text{IND}_2 &amp; \\text{IND}_3          \\\\ \\hline     \\end{array} \\] <p>\\(2^4 - 1\\) istruzioni a due operandi:</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}       \\\\ \\hline %         \\begin{array}{ c|c|c|c }      1 &amp; ~ 1~ &amp; ~ 1~ &amp;    1 \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp;  ~~~ &amp; ~~~  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}    \\\\ \\hline %         \\text{riservato} &amp; \\text{OPCODE} &amp; \\text{IND}_1 &amp; \\text{IND}_2      \\\\ \\hline     \\end{array} \\] <p>\\(2^4 - 1\\) istruzioni a un operando:</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}       \\\\ \\hline %         \\begin{array}{ c|c|c|c }      1 &amp; ~ 1~ &amp; ~ 1~ &amp;   1  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~ 1 &amp; ~ 1~ &amp; ~ 1  &amp;   1~  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}    \\\\ \\hline %         \\text{riservato} &amp; \\text{riservato} &amp; \\text{OPCODE} &amp; \\text{IND}_1  \\\\ \\hline     \\end{array} \\] <p>\\(2^4\\) istruzioni senza operandi:</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}       \\\\ \\hline %         \\begin{array}{ c|c|c|c }      1 &amp; ~ 1~ &amp; ~ 1~ &amp;  1   \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~ 1 &amp; ~ 1~ &amp; ~ 1  &amp;  1~  \\end{array}         &amp; \\begin{array}{ c|c|c|c }    1 &amp; ~ 1~ &amp; ~ 1~ &amp;  1   \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}    \\\\ \\hline %         \\text{riservato}             &amp; \\text{riservato} &amp; \\text{riservato} &amp; \\text{OPCODE}           \\\\ \\hline     \\end{array} \\] <p>La situazione precedentemente descritta \u00e8 solo un esempio, in quanto si potrebbe scegliere di gestire in maniera differente (in termini numerici) il meccanismo di codice operativo espandibile.</p> <p>Ad esempio, se si desiderano pi\u00f9 istruzioni a due operandi e meno a tre operandi, \u00e8 possibile modificare cos\u00ec:</p> \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c|c }   15 &amp;  14  &amp;  13  &amp; 12  \\end{array}         &amp; \\begin{array}{ c|c|c|c } 11 &amp;  10  &amp;   9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }  7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4  \\end{array}         &amp; \\begin{array}{ c|c|c|c }  3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0  \\end{array}       \\\\ \\hline %         \\begin{array}{ c|c|c|c }     ~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~   \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp;  ~~~ &amp; ~~~  \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~ \\end{array}    \\\\ \\hline %         \\text{OPCODE} &amp; \\text{IND}_1 &amp; \\text{IND}_2 &amp; \\text{IND}_3          \\\\ \\hline     \\end{array} \\] \\[     \\begin{array}{ |c|c|c|c| } \\hline         \\begin{array}{ c|c|c }       15 &amp;  14  &amp;  13              \\end{array}         &amp; \\begin{array}{ c|c|c|c|c } 12 &amp;  11  &amp;  10  &amp;  9~ &amp;  8~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }    7 &amp; ~ 6~ &amp; ~ 5~ &amp;  4        \\end{array}         &amp; \\begin{array}{ c|c|c|c }    3 &amp; ~ 2~ &amp; ~ 1~ &amp;  0        \\end{array}             \\\\ \\hline %         \\begin{array}{ c|c|c }      ~~ 1~ &amp; ~ 1~ &amp; ~~ 1~             \\end{array}         &amp; \\begin{array}{ c|c|c|c|c } ~~~~ &amp; ~~~~ &amp; ~~~~ &amp;  ~~~ &amp; ~~~ \\end{array}         &amp; \\begin{array}{ c|c|c|c }   ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~       \\end{array}         &amp; \\begin{array}{ c|c|c|c }   ~~~~ &amp; ~~~~ &amp; ~~~~ &amp; ~~~~       \\end{array}             \\\\ \\hline %         \\text{riservato} &amp; \\text{OPCODE} &amp; \\text{IND}_1 &amp; \\text{IND}_2    \\\\ \\hline     \\end{array} \\] <p>Il set diventa composto da:</p> <ul> <li>\\(2^4 \u2212 2\\) istruzioni a tre operandi (\\(\u22122\\) sono le configurazioni   \\(\\bin{\\underline{111}0}\\) e \\(\\bin{\\underline{111}1}\\));</li> <li>\\(2^5\\) istruzioni con due operandi.</li> </ul> <p>Questo a meno di ulteriori espansioni.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#indirizzamento","title":"Indirizzamento","text":"<p>Molte istruzioni contengono operandi, si pone quindi il problema di come specificarne la posizione. Si parla dunque di indirizzamento, che pu\u00f2 essere delle seguenti tipologie:</p> <ul> <li>immediato;</li> <li>diretto;</li> <li>a registro;</li> <li>a registro indiretto;</li> <li>indicizzato;</li> <li>indicizzato esteso;</li> <li>a stack.</li> </ul>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#immediato","title":"Immediato","text":"<p>L'indirizzamento immediato prevede che sia specificato nel campo riservato all'indirizzo, l'operando stesso. Ad esempio:</p> \\[     \\begin{array}{ |c|c|c| } \\hline         \\text{MOV} &amp; \\text{R}1 &amp; 4 \\\\ \\hline     \\end{array} \\] <p>ovvero, carica la costante \\(4\\) nel registro \\(\\text{R}1\\).</p> <p>Ha il vantaggio di non richiedere un riferimento supplementare in memoria per effettuare il fetch dell'operando. Naturalmente l'entit\u00e0 del valore \u00e8 limitata alla dimensione del campo dell'indirizzo, infatti viene utilizzato per piccole costanti.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#diretto","title":"Diretto","text":"<p>L'indirizzamento diretto utilizza come operando direttamente ci\u00f2 che \u00e8 indicato nello spazio riservato all'indirizzo. Ha lo svantaggio di accedere sempre alla medesima locazione, quindi il valore contenuto nella cella di memoria pu\u00f2 variare, ma non pu\u00f2 cambiare la locazione referenziata.</p> <p>\u00c8 quindi necessario conoscere in fase di compilazione l'indirizzo che si dovr\u00e0 referenziare (e non pu\u00f2 essere un indirizzo contenuto all'interno di una procedura/funzione, in quanto l'allocazione avverrebbe durante l'invocazione della funzione stessa) Viene dunque utilizzato unicamente in riferimento a variabili globali.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#a-registro","title":"A registro","text":"<p>L'indirizzamento a registro funziona in maniera analoga all'indirizzamento diretto, ma referenzia un registro anzich\u00e9 una locazione nello spazio di indirizzamento. \u00c8 nota anche semplicemente come modalit\u00e0 a registro.</p> <p>Nelle architetture load/store (ovvero le architetture dove si pu\u00f2 operare solo tramite operandi su registri) tutte le istruzioni utilizzano questa modalit\u00e0, a meno delle istruzioni <code>LOAD</code> e <code>STORE</code> che caricano/scaricano dati in memoria da/verso un registro.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#a-registro-indiretto","title":"A registro indiretto","text":"<p>Nell'indirizzamento a registro indiretto l'operando proviene o \u00e8 destinato alla memoria, ma l'indirizzo non \u00e8 contenuto all'interno dell'istruzione. Il campo destinato all'operando contiene un registro che indica la locazione in memoria dell'operando. Quando un indirizzo \u00e8 utilizzato in questo modo, prende il nome di puntatore.</p> <p>Ha il grande vantaggio di non dover indicare in fase di compilazione la locazione della parola in memoria (in quanto potr\u00e0 essere caricato nel registro a runtime), inoltre la stessa istruzione pu\u00f2 essere utilizzata su diverse parole in memoria, semplicemente variando il valore contenuto nel registro.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#indicizzato","title":"Indicizzato","text":"<p>L'indirizzamento indicizzato consente di referenziare una parola in memoria che si trova a un certo spiazzamento rispetto a un registro. L'indirizzamento si ottiene dunque mediante la specifica di:</p> <ul> <li>un registro (in via esplicita o implicita);</li> <li>uno spiazzamento costante.</li> </ul> <p>Tale meccanismo viene utilizzato in alcune occasioni nelle quali \u00e8 nota a priori la distanza tra una variabile e l'altra. Pu\u00f2 essere utilizzato nel caso opposto: mantenere un puntatore in memoria nell'istruzione e il piccolo offset in un registro.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#indicizzato-esteso","title":"Indicizzato esteso","text":"<p>Contenuto in alcune macchine, l'indirizzamento indicizzato esteso consente di referenziare un indirizzo in memoria ottenuto sommando tra loro il contenuto di due registri, pi\u00f9 un eventuale offset aggiuntivo.</p> <p>Disporre di tale possibilit\u00e0 costituisce un grande vantaggio (si immagini di scrivere in linguaggio macchina un ciclo che opera su un vettore). Generalmente le macchine che offrono tale possibilit\u00e0 forniscono anche un offset da \\(8 \\bbit\\) o \\(16 \\bbit\\).</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#a-stack","title":"A stack","text":"<p>Alcune istruzioni possono essere utilizzate in combinazione a una struttura stack. Tale forma di indirizzamento prende il nome di indirizzamento a stack.</p> <p>Uno degli esempi pratici di utilizzo \u00e8 quello legato alla notazione polacca inversa.</p>"},{"location":"Anno_I/AESO/AE5_istruzioni_indirizzamento/#notazione-polacca-inversa","title":"Notazione polacca inversa","text":"<p>Nel mondo reale le operazioni algebriche vengono scritte mediante la notazione infissa. Si parla di notazione infissa in quanto l'operatore \u00e8 posto tra gli operandi:</p> \\[ A + B \\] <p>Esistono, equivalentemente, la notazione prefissa e la notazione postfissa:</p> <ul> <li>notazione prefissa: \\({+}\\,AB\\);</li> <li>notazione postfissa: \\(AB\\,{+}\\).</li> </ul> <p>In tali casi l'operatore \u00e8 posto prima/dopo gli operandi</p> <p>La notazione postfissa prende anche il nome di notazione polacca inversa, dal logico polacco J. Lukasiewicz (1958) che ne ha studiato le propriet\u00e0.</p> <p>Presenta alcuni vantaggi rispetto alla notazione infissa:</p> <ul> <li>ogni operazione pu\u00f2 essere scritta correttamente senza parentesi;</li> <li>la valutazione delle formule in tale notazione si addice particolarmente ai   compilatori con stack</li> <li>gli operatori infissi possiedono un ordine di precedenza, che \u00e8 arbitrario:   ad esempio \\(a + b \\times c\\) corrisponde a \\(a + (b \\times c)\\) e non a   \\((a + b) \\times c\\) perch\u00e9 alla moltiplicazione \u00e8 assegnato un ordine di   priorit\u00e0 pi\u00f9 alto.</li> </ul> <p>Alcuni esempi di notazione polacca inversa:</p> Infissa Polacca inversa \\(A \\times B + C\\) \\(AB\\,{\\times}\\; C\\,{+}\\) \\(A + B \\times C\\) \\(A\\; BC\\,{\\times}\\; {+}\\) \\(A \\times B + C \\times D\\) \\(AB\\,{\\times}\\; CD\\,{\\times}\\; {+}\\) \\((A + B)/(C + D)\\) \\(AB\\,{+}\\; CD\\,{-}\\; {/}\\) \\(((A + B) \\times C + D)/(E + F + G)\\) \\(AB\\,{+}\\; C\\,{\\times}\\; D\\,{+}\\; EF\\,{+}\\; G\\,{+}\\; {/}\\) <p>(nella parte relativa alla notazione infissa si considera, ovviamente, la moltiplicazione prioritaria rispetto ad addizione e sottrazione).</p> <p>Come si valuta una formula in notazione polacca inversa?</p> <ul> <li>quando trovo un valore, lo aggiungo in cima allo stack</li> <li>quando trovo un operando, prendo i due valori in cima allo stack, effettuo   l'operazione tra questi due ed inserisco il risultato in cima allo stack.</li> </ul> \\[     \\begin{align}         \\underbrace{5\\,6\\,{\\times}}_{30}\\; 3\\,6\\,{\\times}\\; -             &amp;\\implies 30\\; \\underbrace{3\\,6\\,{\\times}}_{18}\\; - \\\\             &amp;\\implies 30\\,18\\,{-}                               \\\\             &amp;\\implies 12     \\end{align} \\] <p>Un esempio pi\u00f9 complesso che mostra i vantaggi per l'elaboratore:</p> \\[ (8 + 2 \\times 5)/(1 + 3 \\times 2 \u2212 4) \\] Stringa rimanente Istruzione Stack \\(8\\; 2\\,5\\,{\\times}\\,{+}\\; 1\\; 3\\,2\\,{\\times}\\,{+}\\; 4\\,{\u2212}\\; {/}\\) BIPUSH \\(8\\) \\(8\\) \\(2\\,5\\,{\\times}\\,{+}\\; 1\\; 3\\,2\\,{\\times}\\, {+}\\; 4\\,{\u2212}\\; {/}\\) BIPUSH \\(2\\) \\(8, 2\\) \\(5\\,{\\times}\\,{+}\\; 1\\; 3\\,2\\,{\\times}\\, {+}\\; 4\\,{\u2212}\\; {/}\\) BIPUSH \\(5\\) \\(8, 2, 5\\) \\({\\times}\\,{+}\\; 1\\; 3\\,2\\,{\\times}\\, {+}\\; 4\\,{\u2212}\\; {/}\\) IMUL \\(8, 10\\) \\({+}\\; 1\\; 3\\,2\\,{\\times}\\, {+}\\; 4\\,{\u2212}\\; {/}\\) IADD \\(18\\) \\(1\\; 3\\,2\\,{\\times}\\, {+}\\; 4\\,{\u2212}\\; {/}\\) BIPUSH \\(1\\) \\(18, 1\\) \\(3\\,2\\,{\\times}\\, {+}\\; 4\\,{\u2212}\\; {/}\\) BIPUSH \\(3\\) \\(18, 1, 3\\) \\(2\\,{\\times}\\, {+}\\; 4\\,{\u2212}\\; {/}\\) BIPUSH \\(2\\) \\(18, 1, 3, 2\\) \\({\\times}\\; {+}\\; 4\\,{-}\\; {/}\\) IMUL \\(18, 1, 6\\) \\({+}\\; 4\\,{-}\\; {/}\\) IADD \\(18, 7\\) \\(4\\,{-}\\; {/}\\) BIPUSH \\(4\\) \\(18, 7, 4\\) \\({-}\\; {/}\\) ISUB \\(18, 3\\) \\({/}\\) IDIV \\(6\\) <p>Per passare dalla notazione infissa alla notazione polacca inversa si usa l'algoritmo di scalo di manovra (Shunting-yard algorithm), detto anche algoritmo di smistamento, inventato dal noto informatico olandese Edsger Dijkstra. L'algoritmo consiste nell'analizzare l'espressione e trasferire gli operatori in uno stack apposito, che seleziona se inserire l'operatore o tenerlo in memoria sulla base della priorit\u00e0 dell'operazione.</p> <ol> <li> <p>Come \u00e8 possibile confermare qui il simbolo \\(\\lxor\\) rappresenta lo XOR logico.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/","title":"Sistema operativo, gestione dei processi e scheduling","text":""},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#obiettivi-di-un-sistema-operativo","title":"Obiettivi di un sistema operativo","text":"<p>Un sistema operativo ha principalmente tre obiettivi:</p> <ul> <li>convenienza nell'uso del calcolatore rispetto ai potenziali utenti;</li> <li>efficienza nell'utilizzo del calcolatore e delle sue parti costitutive;</li> <li>capacit\u00e0 di evolversi rispetto a evoluzioni hardware, esigenze degli   utenti e bug.</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#sistema-operativo-come-interfaccia","title":"Sistema operativo come interfaccia","text":"<pre><code>flowchart LR\n  subgraph PC\n    App(Application Program)\n    Utilities\n    OS(Operating System)\n    HW(Computer Hardware)\n  end\n\n  App --&gt; User(End User)\n  Utilities &amp; OS --&gt; Programmer\n  HW --&gt; Dev(Operating System Developer)</code></pre> <p>Il sistema operativo:</p> <ul> <li>nasconde i dettagli hardware al programmatore;</li> <li>fornisce un'interfaccia per utilizzare il sistema.</li> </ul> <p>Il sistema operativo agisce quindi in maniera trasparente.</p> <p>Un'interfaccia \u00e8 un componente fisico o logico che permette a due o pi\u00f9 sistemi elettronici di comunicare e interagire.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#servizi-offerti-dal-sistema-operativo","title":"Servizi offerti dal sistema operativo","text":"<p>Il sistema operativo offre vari servizi:</p> <ul> <li>creazione dei programmi: compilatore, debugger come utilit\u00e0 offerte al   programmatore. Non sono parte del sistema operativo ma sono accessibili   tramite esso;</li> <li>esecuzione dei programmi: caricamento in memoria dei programmi,   inizializzazione dei dispositivi I/O, ecc;</li> <li>accesso ai dispositivi di I/O: l'utente/programmatore ignora il set di   istruzioni e i segnali dei dispositivi;</li> <li>accesso controllato ai file: comprensione del formato, meccanismi di   protezione, associazione file indirizzi di memoria;</li> <li>accesso al sistema (inteso in senso lato);</li> <li>rilevazione e correzione degli errori hardware o generati da programmi in   esecuzione;</li> <li>contabilit\u00e0 e statistiche d'uso delle risorse, dei tempi di risposta (al   fine di migliorare le prestazioni).</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#sistema-operativo-come-gestore-delle-risorse","title":"Sistema operativo come gestore delle risorse","text":"<pre><code>flowchart LR\n  subgraph PC[\" \"]\n  Controller1[I/O Controller]\n  Controller2[I/O Controller]\n  Processore\n  subgraph Memoria\n    subgraph OS[Sistema Operativo]\n      Kernel(Kernel)\n    end\n    Programmi\n    Dati\n    end\n  end\n  Dispositivo1([Dispositivo I/O]) &lt;--&gt; Controller1\n  Dispositivo2([Dispositivo I/O]) &lt;--&gt; Controller2</code></pre> <p>Il sistema operativo:</p> <ul> <li>dirige la CPU nell'utilizzo delle altre risorse del sistema e nella   temporizzazione dell'esecuzione dei programmi;</li> <li>decide quando un programma in esecuzione pu\u00f2 utilizzare una risorsa. Il   processore stesso \u00e8 una risorsa.</li> </ul> <p>Il Kernel \u00e8 Parte del sistema operativo risiedente in memoria centrale, contiene le funzioni del sistema operativo usate pi\u00f9 frequentemente.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#batch-multiprogrammati","title":"Batch multiprogrammati","text":"<p>Con batch multiprogrammati si intende sistemi dove \u00e8 consentita la multiprogrammazione, ovvero l'esecuzione di pi\u00f9 programmi in contemporanea.</p> Mono-programmazioneMulti-programmazione <p>Ad esempio:</p> <ul> <li>Lettura di un record: \\(0.0015 \\second\\);</li> <li>Esecuzione di \\(100\\) istruzioni: \\(0.0001 \\second\\);</li> <li>Scrittura di un record: \\(0.0015 \\second\\);</li> <li>Totale \\(0.0031 \\second\\).</li> </ul> <p>Percentuale di utilizzo della CPU:</p> \\[     \\frac{0.0001 \\cancel{\\second}}{0.0031 \\cancel{\\second}} = 0.032                                                             = 3.2 \\% \\] <ul> <li>Presenza di pi\u00f9 programmi in memoria;</li> <li>Obiettivo: limitare l'inattivit\u00e0 del processore, quando un job effettua   un'operazione di I/O la CPU pu\u00f2 essere impegnata da un altro processo;</li> <li>Elaborazione seriale dei task.</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#multi-programmazione","title":"Multi-programmazione","text":"<p>Le difficolt\u00e0 della multi-programmazione sono le seguenti:</p> <ul> <li>Gestione della memoria;</li> <li>Decidere quale Job mandare in esecuzione (schedulazione).</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#processo-job-task","title":"Processo = Job = Task","text":"<p>Processo</p> <p>Un'attivit\u00e0 caratterizzata dall'esecuzione di una sequenza di istruzioni, uno stato corrente e un set di istruzioni di sistema</p> <p>Le componenti di un processo sono le seguenti:</p> <ul> <li>Programma, che comprende il codice eseguibile;</li> <li>Dati, che comprendono: variabili, spazio di lavoro, buffer</li> <li>Contesto di esecuzione, ovvero le informazioni necessarie al sistema   operativo per gestire il processo:<ul> <li>Contenuto dei registri della CPU</li> <li>Priorit\u00e0</li> <li>Stato di esecuzione</li> <li>Stato di attesa su un dispositivo di I/O</li> </ul> </li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#implementazione-di-un-processo","title":"Implementazione di un processo","text":"<p>L'immagine \u00e8 veramente troppo complicata per ricrearla.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#gestione-della-memoria","title":"Gestione della memoria","text":"<p>Il sistema operativo deve assolvere cinque compiti</p> <ol> <li>isolamento dei processi;</li> <li>allocazione e gestione automatica della memoria: la gerarchia delle memorie    deve essere trasparente all'utente;</li> <li>supporto alla programmazione modulare: variazione di dimensione dei programmi;</li> <li>protezione e controllo dell'accesso: gestione di aree di memoria condivise    tra i processi;</li> <li>memorizzazione a lungo termine.</li> </ol> <p>Queste necessit\u00e0 sono soddisfatte da:</p> <ul> <li>memoria virtuale: i programmi indirizzano la memoria con riferimenti   logici ignorando gli aspetti fisici, quando un programma \u00e8 in esecuzione solo   una sua parte risiede effettivamente in memoria centrale;</li> <li>file system: implementa la memorizzazione a lungo termine.</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#stati-dei-processi","title":"Stati dei processi","text":"<p>Il compito principale di un sistema operativo \u00e8 il controllo dell'esecuzione dei processi. In particolare, \u00e8 possibile classificare lo stato attuale di un processo mediante, appunto, uno stato. Tale classificazione consente di gestire in maniera differente processi in stato differente.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#descrizione-dei-processi","title":"Descrizione dei Processi","text":"<p>Il sistema operativo necessita di uno strumento per gestire i processi, che tenga traccia di tutte le informazioni disponibili. Esso prende il nome di Descrittore di Processo, oppure Process Control Block (PCB).</p> <pre><code>flowchart TB\n  subgraph VirtualMemory[Virtual Memory]; P1; P2; Pn; end\n  subgraph ComputerResources[Computer Resources]\n    Processor; I/O; I/O1; MainMemory\n  end\n  P1 --&gt; Processor &amp; I/O &amp; I/O1[I/O]\n  P2 -.-&gt; I/O\n  P1 &amp; P2 --&gt;  MainMemory[Main Memory]\n  Pn -.-&gt; MainMemory</code></pre>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#process-control-block-pcb","title":"Process Control Block (PCB)","text":"<p>\u00c8 costituito da:</p> <ol> <li>un identificatore di processo, detto anche Process IDentification (PID),    \u00e8 un valore numerico univoco;</li> <li>le informazioni sullo stato del processore, queste contengono:<ul> <li>registri dati visibili all'utente, questi dipendono dall'architettura     del calcolatore;</li> <li>registri di controllo e di stato, che a loro volta contengono:<ul> <li>Program Counter: indirizzo della prossima istruzione da eseguire;</li> <li>Registri di stato: includono i flag per l'abilitazione degli      interrupt;</li> <li>Registri che contengono codici relativi alla condizione, come:      segno, overflow, etc.</li> </ul> </li> <li>Puntatori allo stack, che vengono usati per procedure e funzioni.</li> </ul> </li> <li>le informazioni di controllo del processo, queste contengono:<ul> <li>schedulazione e informazioni di stato:<ul> <li>stato del processo (Running, Ready, etc.);</li> <li>priorit\u00e0 nelle code di scheduling;</li> <li>informazioni correlate alla schedulazione (tempo di attesa, tempo     di esecuzione, etc);</li> <li>evento del quale \u00e8 in attesa (se \u00e8 in attesa).</li> </ul> </li> <li>Strutturazione dati, ovvero puntatori ad altri processi che siano     figli/padre o che siano per l'implementazione di code.</li> <li>Comunicazione tra processi, avviene mediante flag, segnali e messaggi     per la comunicazione.</li> <li>privilegi, in relazione all'uso della memoria, dei dispositivi, etc.</li> <li>gestione della memoria, sono presenti dei limiti di memoria, ovvero un     insieme degli indirizzi accessibili (base, limite).</li> <li>Contabilizzazione delle risorse, ovvero le risorse controllate dal     processo, come lista dei file aperti, lista dei dispositivi I/O, e la     loro storia.</li> </ul> </li> </ol>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#immagine-dei-processi-in-memoria","title":"Immagine dei processi in memoria","text":"<p>Nell'esempio le immagini occupano locazioni contigue di memoria, in una implementazione reale ci\u00f2 pu\u00f2 non essere vero. Dipende dalla politica di gestione della memoria.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#creazione-e-terminazione-dei-processi","title":"Creazione e terminazione dei processi","text":"<p>Eventi che portano alla creazione dei processi:</p> <ol> <li>richiesta da terminale (un utente accede al sistema);</li> <li>il sistema operativo genera un processo sulla base della richiesta di un    processo utente (es. stampa: il processo generatore continua la sua    esecuzione);</li> <li>un processo utente genera un nuovo processo, processo padre e processo figlio    (es. sfruttare il parallelismo: un processo server genera diverse istanze per    gestire diverse richieste).</li> </ol> <p>Eventi che portano alla terminazione dei processi:</p> <ol> <li>terminazione normale (end);</li> <li>uscita dell'utente dall'applicazione;</li> <li>superamento del tempo massimo;</li> <li>memoria non disponibile;</li> <li>violazione dei limiti di memoria;</li> <li>fallimento di un'operazione, che sia aritmetica o di I/O, etc.;</li> <li>terminazione del genitore;</li> <li>richiesta del genitore.</li> </ol>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#modello-a-due-stati","title":"Modello a due stati","text":"<pre><code>stateDiagram-v2\n    direction LR\n    NotRunning: Not-Running\n\n    [*] --&gt; NotRunning: Ingresso\n    NotRunning --&gt; Running: Alloca\n    Running --&gt; NotRunning: Pausa\n    Running --&gt; [*]: Uscita</code></pre> <p>Nel modello a due stati, lo stato Not-Running include due possibilit\u00e0:</p> <ol> <li>il processo \u00e8 pronto per essere eseguito</li> <li>il processo \u00e8 in attesa di un evento o di un dispositivo I/O</li> </ol> <p>Il dispatcher (scheduler) non pu\u00f2 semplicemente scegliere il processo da pi\u00f9 tempo in attesa, poich\u00e9 esso potrebbe essere in attesa di un trasferimento I/O</p> <p>Si giunge dunque al modello a cinque stati:</p> <ul> <li>vengono introdotti gli stati New e Exit (anche Terminated);</li> <li>lo stato di Not-Running viene diviso negli stati Ready (pronto   all'esecuzione) e Blocked (in attesa di un evento, una risorsa, etc).</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#modello-a-cinque-stati","title":"Modello a cinque stati","text":"<pre><code>stateDiagram-v2\n  direction LR\n\n  [*] --&gt; New\n  New --&gt; Ready: Admit\n  Ready --&gt; Running: Dispatch\n  Ready --&gt; Exit: Kill\n\n  Running --&gt; Exit: Release\n  Running --&gt; Ready: Timeout\n  Running --&gt; Blocked: Event Wait\n\n  Blocked --&gt; Ready: Event Occurs\n  Blocked --&gt; Exit: Kill\n\n  Exit --&gt; [*]</code></pre> <p>Le transizioni Ready\u2192Exit e Blocked\u2192Exit si hanno nel caso in cui un processo genitore termina il processo figlio.</p> <p>I nuovi stati New e Exit:</p> <ul> <li>New: il sistema operativo associa al processo il PID, alloca e costruisce   le tabelle per la gestione del processo. Il processo non \u00e8 caricato   in memoria;</li> <li>Exit: rilascio delle risorse. Il sistema operativo pu\u00f2 mantenere alcune   informazioni (es. contabilit\u00e0).</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#strategie-di-accodamento","title":"Strategie di accodamento","text":"<p>La prima strategia \u00e8 quella della coda di Blocked singola:</p> <pre><code>stateDiagram-v2\n  direction LR\n  state Admit &lt;&lt;join&gt;&gt;\n    RQ: Coda di Ready\n    BQ: Coda di Blocked\n    [*] --&gt; Admit\n    Admit --&gt; RQ: Admit\n    BQ --&gt; Admit: Event Occurs\n    RQ --&gt; Processor: Dispatch\n\n  Processor --&gt; [*]: Release\n  Processor --&gt; Admit: Timeout\n  Processor --&gt; BQ: Event Wait</code></pre> <p>L'altra strategia di accodamento fa uso di pi\u00f9 code di Blocked:</p> <pre><code>stateDiagram-v2\n  direction LR\n  state Admit &lt;&lt;join&gt;&gt;\n    ReadyQueue: Coda di Ready\n    [*] --&gt; Admit\n    Admit --&gt; ReadyQueue: Admit\n    ReadyQueue --&gt; Processor: Dispatch\n\n  state EventWait &lt;&lt;fork&gt;&gt;\n    BlockedQueues: Code di Blocked\n    state BlockedQueues {\n      direction LR\n      BlockedQueue1: Coda di Blocked #1\n      BlockedQueue2: Coda di Blocked #2\n      BlockedQueue3: Coda di Blocked #3\n      BlockedQueuen: Coda di Blocked #n\n    }\n    EventWait --&gt; BlockedQueue1: Event #1 Wait\n    EventWait --&gt; BlockedQueue2: Event #2 Wait\n    EventWait --&gt; BlockedQueue3: Event #3 Wait\n    EventWait --&gt; BlockedQueuen: Event #n Wait\n\n  state EventOccurs &lt;&lt;join&gt;&gt;\n    BlockedQueue1 --&gt; EventOccurs: Event #1 Occurs\n    BlockedQueue2 --&gt; EventOccurs: Event #2 Occurs\n    BlockedQueue3 --&gt; EventOccurs: Event #3 Occurs\n    BlockedQueuen --&gt; EventOccurs: Event #n Occurs\n    EventOccurs --&gt; Admit\n\n  state ProcessorFork &lt;&lt;fork&gt;&gt;\n    Processor --&gt; ProcessorFork\n    ProcessorFork --&gt; Admit: Timeout\n    ProcessorFork --&gt; EventWait: Event Wait\n    ProcessorFork --&gt; [*]: Release</code></pre>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#context-switch","title":"Context Switch","text":"<p>Il context-switch avviene quando c'\u00e8 passaggio della CPU a un nuovo processo. Le cause principali sono:</p> <ul> <li>clock interrupt: il processo termina il tempo a sua disposizione e torna nella   coda di ready;</li> <li>I/O interrupt: un'operazione di I/O termina, il sistema operativo sposta il   processo in attesa di tale evento da Blocked a Ready e decide se far   riprendere l'esecuzione del processo precedente.</li> <li>memory fault: l'indirizzo di memoria generato \u00e8 sul disco (memoria virtuale) e   deve essere portato in RAM. Il sistema operativo carica il blocco, nel   frattempo il processo che ha generato la richiesta \u00e8 in Blocked, al termine   del trasferimento andr\u00e0 in Ready;</li> <li>trap: errore di esecuzione, il processo potrebbe andare in Exit;</li> <li>supervisor call (es. file open, il processo utente va in Blocked).</li> </ul> <p>Le operazioni svolte dal sistema operativo in modalit\u00e0 supervisor al momento del cambio di processo in stato di Running sono le seguenti:</p> <ul> <li>salvataggio del contesto del processo che abbandona la CPU, ovvero dei valori   dei registri della CPU, quali: pc, psw, reg, etc;</li> <li>cambio del valore di stato nel PCB, da Running si passa a Ready o   Blocked o Exit;</li> <li>spostamento del PCB in nuova coda (Ready o Blocked) o deallocare le sue   risorse (Exit);</li> <li>aggiornamento delle strutture dati gestione memoria (area dello stack);</li> <li>selezione di nuovo processo per lo stato running (dispatcher);</li> <li>aggiornamento del suo stato nel PCB;</li> <li>ripristino del contesto.</li> </ul> <p>Il context-switch time \u00e8 overhead, ovvero il sistema operativo non svolge alcun compito che sia utile all'utente. Il tempo dipende dalla complessit\u00e0 del sistema operativo e dall'hardware.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#modalita-di-esecuzione-dei-processi","title":"Modalit\u00e0 di esecuzione dei processi","text":"<p>Le modalit\u00e0 di esecuzione sono due: modalit\u00e0 utente, ovvero l'esecuzione di processi utente e modalit\u00e0 sistema o Kernel o Controllo, ovvero l'esecuzione di istruzioni che hanno come scopo:</p> <ul> <li>la gestione dei processi, ovvero creazione e terminazione, schedulazione,   cambio di contesto, sincronizzazione e PCB;</li> <li>la gestione della memoria, ovvero allocazione, trasferimento da disco a RAM   e viceversa, gestione della paginazione, della segmentazione, etc;</li> <li>la gestione I/O, ovvero la gestione dei buffer, l'allocazione a canali I/O;</li> <li>il supporto, ovvero la gestione delle interruzioni, la contabilit\u00e0.</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#creazione-dei-processi","title":"Creazione dei Processi","text":"<p>Per creare un processo si seguono i seguenti passi:</p> <ol> <li>assegnare al processo un PID unico, dunque aggiungere una entry level alla    tabella dei processi;</li> <li>allocare lo spazio per il processo e per tutti gli elementi della sua    immagine (PCB, User Stack, area di memoria dati e istruzioni, aree condivise);</li> <li> <p>inizializzazione del PCB, ovvero (in pseudocodice):</p> Text Only<pre><code>stato del processore := 0\nprocess counter := prossima istruzione\npuntatori allo stack\nstato := ready\n</code></pre> </li> <li> <p>inserimenti nella coda di ready;</p> </li> <li>estende le strutture al fine della fatturazione o delle statistiche.</li> </ol>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#evoluzione-del-modello-a-cinque-stati","title":"Evoluzione del modello a cinque stati","text":"<p>Nonostante la memoria virtuale, un programma per essere eseguito deve essere in RAM. Con elevata probabilit\u00e0 tutti i processi in memoria restano in attesa di operazioni di I/O. Questo significa che il processore resta inattivo poich\u00e9 \u00e8 molto pi\u00f9 veloce dei dispositivi I/O. Le soluzioni applicabili sono le seguenti:</p> <ul> <li>espandere la memoria, risulta essere costoso e poco efficiente dato che i   programmi sono sempre pi\u00f9 grandi;</li> <li>effettuare lo swapping, ovvero spostare un processo dalla RAM alla memoria   secondaria. Questo porta all'introduzione dello stato di Suspend. Lo   swapping \u00e8 anch'esso un'operazione di I/O, ma in generale \u00e8 la pi\u00f9 rapida tra   queste.</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#modello-a-sei-stati","title":"Modello a sei stati","text":"<pre><code>stateDiagram-v2\n  direction LR\n\n  [*] --&gt; New\n  New --&gt; Ready: Admit\n\n  Ready --&gt; Suspended: Suspend\n  Ready --&gt; Running: Dispatch\n  Ready --&gt; Exit\n\n  Running --&gt; Ready: Timeout\n  Running --&gt; Blocked: Event wait\n  Running --&gt; Exit: Release\n\n  Suspended --&gt; Ready: Activate\n  Suspended --&gt; Blocked: Activate\n\n  Blocked --&gt; Suspended: Suspend\n  Blocked --&gt; Ready: Event occurs\n  Blocked --&gt; Exit\n\n  Exit --&gt; [*]</code></pre> <p>Con swap out si intende lo scaricamento del processo sul disco, ovvero la transizione da blocked a suspended. Invece con swap in si intende l'operazione inversa allo swap out.</p> <p>Il modello a sei stati pone un problema analogo a quello a due stati: va quindi scisso lo stato di Suspended in Ready/Suspended e Blocked/Suspended.</p> <p>Ci\u00f2 consente al sistema operativo di scegliere tra i processi in New e in Suspended, per essere portati in Ready.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#modello-a-sette-stati","title":"Modello a sette stati","text":"<pre><code>stateDiagram-v2\n  direction LR\n  ReadySuspended: Ready/Suspended\n  BlockedSuspended: Blocked/Suspended\n\n  [*] --&gt; New\n  New --&gt; Ready: Admit\n  New --&gt; ReadySuspended: Admit\n\n  Ready --&gt; ReadySuspended: Suspend\n  Ready --&gt; Running: Dispatch\n  Ready --&gt; Exit\n\n  Running --&gt; Ready: Timeout\n  Running --&gt; ReadySuspended: Suspend\n  Running --&gt; Blocked: Event Wait\n  Running --&gt; Exit: Release\n\n  Blocked --&gt; BlockedSuspended: Suspend\n  Blocked --&gt; Exit\n\n  BlockedSuspended --&gt; Blocked: Activate\n  BlockedSuspended --&gt; ReadySuspended: Event Occurs\n  BlockedSuspended --&gt; Exit\n\n  ReadySuspended --&gt; Ready: Activate\n  ReadySuspended --&gt; Exit\n\n  Exit --&gt; [*]</code></pre> <p>\u00c8 simile al modello a cinque stati di sospensione. \u00c8 presente un parallelismo tra i processi in memoria principale e quelli in memoria secondaria.</p> <p>Esiste uno schema di gestione della memoria noto come memoria virtuale, nel quale un processo pu\u00f2 trovarsi solo parzialmente in RAM. Quando si fa riferimento a un indirizzo su disco questo viene caricato. Dunque gli stati di sospensione in quel caso sono inutili.</p> <p>La transizione da Ready a Ready/Suspended avviene laddove vi sia la necessit\u00e0 di maggiore memoria per allocare un processo pi\u00f9 grande o a maggiore priorit\u00e0.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#schedulazione","title":"Schedulazione","text":"<p>La schedulazione, ossia la scelta dell'ordine di esecuzione dei processi, e la relativa politica di allocazione deve tenere in considerazione i seguenti fattori:</p> <ul> <li>equit\u00e0, ovvero tutti i processi che appartengono alla stessa classe o che   hanno richieste simili o che hanno lo stesso costo devono avere la stessa   possibilit\u00e0 di accesso alle risorse;</li> <li>tempo di risposta differenziale, ovvero il sistema operativo discrimina   tra classi che hanno bisogno di risorse diverse e di tempi diversi (es. i   processi I/O-bound che fanno forte uso di I/O vengono schedulati per primi);</li> <li>efficienza, \u00e8 necessario massimizzare il throughput, ovvero la quantit\u00e0   di dati trasmessi, e minimizzare il tempo di risposta.</li> </ul> <p>Con scheduling si intende un insieme di tecniche e meccanismi interni del sistema operativo che amministrano l'ordine in cui il lavoro viene svolto. L'obiettivo primario dello scheduling \u00e8 l'ottimizzazione delle prestazioni del sistema.</p> <p>Il sistema operativo pu\u00f2 prevedere fino a tre tipi di scheduler:</p> <ul> <li>Scheduler di lungo termine (SLT);</li> <li>Scheduler di medio termine (SMT);</li> <li>Scheduler di breve termine (SBT).</li> </ul> <p>Gli scheduler intervengono secondo il seguente schema:</p> <pre><code>stateDiagram-v2\n  direction LR\n  ReadySuspended: Ready/Suspended\n\n  New --&gt; Ready: SLT\n  New --&gt; ReadySuspended: SLT\n  ReadySuspended --&gt; Ready: SMT\n  Ready --&gt; Running: SBT\n\n  BlockedSuspended: Blocked/Suspended\n  BlockedSuspended --&gt; Blocked: SMT</code></pre>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#scheduler-di-lungo-termine","title":"Scheduler di lungo termine","text":"<p>Determina quali programmi sono ammessi nel sistema per essere processati, quindi controlla le transizioni da New a Ready e da New a Ready/Suspended. Controlla, inoltre, il grado di multiprogrammazione (New\u2192Ready), avere pi\u00f9 processi significa avere minor tempo percentuale di esecuzione per ciascuno di questi.</p> <p>Le stime effettuate dal programmatore o dal sistema forniscono informazioni sulle risorse necessarie all'esecuzione, come le dimensioni della memoria, il tempo di esecuzione totale, etc.</p> <p>Il lavoro dello scheduler di lungo termine si basa quindi sulla stima del comportamento globale dei job.</p> <p>Le strategie principali dello scheduler sono:</p> <ol> <li>fornire alla coda dei processi pronti, quindi allo scheduler di breve termine,    gruppi di processi che siano bilanciati tra loro nello sfruttamento della CPU    e dell'I/O;</li> <li>aumentare il numero di processi provenienti dalla coda batch quando il    carico della CPU diminuisce;</li> <li>diminuire, fino anche a bloccare, i lavori provenienti dalla coda batch    quando il carico aumenta e/o i tempi di risposta del sistema diminuiscono.</li> </ol> <p>La frequenza di chiamata dello scheduler a lungo termine \u00e8 bassa e consente di implementare strategie anche complesse di selezione dei lavori e di dimensionamento del carico dei processi da inviare alla coda di Ready.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#scheduler-di-medio-termine","title":"Scheduler di medio termine","text":"<p>Si occupa di gestire la schedulazione delle transizioni:</p> <ul> <li>Ready/Suspended\u2192Ready;</li> <li>Blocked/Suspended\u2192Blocked.</li> </ul> <p>Si basa sulla necessit\u00e0 di gestire il livello di multiprogrammazione. La presenza di molti processi sospesi in memoria riduce la disponibilit\u00e0 per nuovi processi pronti. In questo caso lo scheduler di breve termine \u00e8 obbligato a scegliere tra i pochi processi pronti, dunque:</p> <ul> <li>utilizza le informazioni del Descrittore di Processo (PCB) per stabilire   la richiesta di memoria del processo;</li> <li>tenta di allocare spazio in memoria centrale;</li> <li>riposiziona il processo in memoria nella coda di Ready.</li> </ul> <p>Viene attivato quando:</p> <ul> <li>si rende disponibile lo spazio in memoria;</li> <li>l'arrivo di processi pronti scende al di sotto di una soglia specificata.</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#scheduler-di-breve-termine","title":"Scheduler di breve termine","text":"<p>Prende anche il nome di dispatcher. Si occupa di gestire la transizione da Ready a Run e viene eseguito molto frequentemente. Viene invocato quando si verifica un evento:</p> <ul> <li>clock interrupts;</li> <li>I/O interrupts;</li> <li>chiamate del sistema operativo;</li> <li>signals.</li> </ul> <p>La sua principale strategia \u00e8 orientata alla massimizzazione delle prestazioni del sistema secondo un specifico insieme di obiettivi.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#scheduling-della-cpu-nel-dispatcher","title":"Scheduling della CPU nel Dispatcher","text":"<p>Esecuzione di un processo:</p> <ol> <li>Ciclo di elaborazione (CPU);</li> <li>Attesa di completamento di I/O.</li> </ol> <p>Lo scheduling della CPU riguarda la distribuzione delle sequenze di elaborazione della CPU.</p> <p>Un processo si dice I/O-bound quando presenta molte operazioni di I/O, al contrario si dice CPU-bound quando presenta poche operazioni di I/O.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#algoritmi-di-schedulazione","title":"Algoritmi di schedulazione","text":"<p>Innanzitutto, si definiscano:</p> <ul> <li>il tempo di ricircolo come il tempo trascorso tra l'avvio di un processo,   ovvero la sua immissione nel sistema, e la terminazione dello stesso;</li> <li>il tempo di attesa come il tempo che un processo trascorre in attesa delle   risorse a causa di conflitti con altri processi. Si pu\u00f2 calcolare come la   differenza tra il tempo di ricircolo e il tempo di esecuzione. Sostanzialmente   valuta la sorgente di inefficienza, essendo il prezzo da pagare per condividere   delle risorse.</li> </ul> <p>L'efficienza degli algoritmi di schedulazione \u00e8 misurabile utilizzando i tempi sopracitati. Un buon algoritmo di scheduling cerca di bilanciare l'esecuzione dei processi al meglio, massimizzando l'uso del processore e riducendo i tempi di attesa.</p> <p>Decision mode</p> <p>Pu\u00f2 essere di due tipi.</p> Non-Preemptive (non-interrompibile)Preemptive (interrompibile) <p>Un processo in Running abbandoner\u00e0 tale stato solo se termina l'esecuzione o si blocca per un'operazione di I/O.</p> <p>Un processo in Running pu\u00f2 essere interrotto e spostato in Ready del sistema operativo (es. se giunge un processo \"pi\u00f9 importante\" in Ready).</p> <p>Il pro \u00e8 che nessun processo pu\u00f2 monopolizzare il processore, il contro \u00e8 che crea problemi dove vi sono processi che condividono dati e dunque richiedono meccanismi di sincronizzazione.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#first-come-first-served-fcfs","title":"First Come First Served (FCFS)","text":"<pre><code>gantt\n  title First Come First Served\n  dateFormat  ss\n  axisFormat  %S\n\n  section A\n    Running     :A, 0, 3s\n  section B\n    Running     :B, after A, 9s\n  section C\n    Running     :C, after B, 3s\n  section D\n    Running     :D, after C, 3s\n  section E\n    Running     :E, after D, 2s</code></pre> <p>Applica il principio della coda:</p> <ul> <li>Ogni processo entra in coda di Ready;</li> <li>Quando un processo abbandona lo stato di Running si seleziona il processo   che da pi\u00f9 tempo \u00e8 in stato di Ready.</li> </ul> <p>Favorisce i processi CPU-bound. Un processo I/O-bound che richiede poco tempo di esecuzione potrebbe attendere molto tempo prima che gli venga assegnata la CPU. Genera l'effetto convoglio: tutti i processi in coda attendono che un processo CPU-bound termini. \u00c8 senza prelazione, ovvero con basso sfruttamento delle componenti e con un basso lavoro utile del sistema.</p> <p>Le prestazioni dipendono unicamente dall'ordine di arrivo dei Jobs. Ad esempio, siano \\(p_1\\) e \\(p_2\\) due processi con tempo di esecuzione totale di \\(20\\second\\) e \\(2\\second\\) rispettivamente.</p> \\(p_1\\) prima di \\(p_2\\)\\(p_2\\) prima di \\(p_1\\) <pre><code>stateDiagram-v2\n    direction LR\n    state Ordine {\n        direction LR\n        p2 --&gt; p1\n    }\n    Ordine --&gt; FCFS</code></pre> <p>Tempi di riciclo:</p> <ul> <li>\\(p_1 = 20 \\second\\);</li> <li>\\(p_2 = 22 \\second\\);</li> <li>\\(t_{\\rm medio} = 21 \\second\\).</li> </ul> <p>Tempo di attesa:</p> <ul> <li>\\(p_1 = 0 \\second\\);</li> <li>\\(p_2 = 20 \\second\\);</li> <li>\\(t_{\\rm medio} = 10 \\second\\).</li> </ul> <pre><code>stateDiagram-v2\n    direction LR\n    state Ordine {\n        direction LR\n        p1 --&gt; p2\n    }\n    Ordine --&gt; FCFS</code></pre> <p>Tempi di riciclo:</p> <ul> <li>\\(p_1 = 2 \\second\\);</li> <li>\\(p_2 = 22 \\second\\);</li> <li>\\(t_{\\rm medio} = 12 \\second\\).</li> </ul> <p>Tempo di attesa:</p> <ul> <li>\\(p_1 = 0 \\second\\);</li> <li>\\(p_2 = 2 \\second\\);</li> <li>\\(t_{\\rm medio} = 1 \\second\\).</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#event-driven","title":"Event Driven","text":"<pre><code>stateDiagram-v2\n  direction LR\n  state Admit &lt;&lt;fork&gt;&gt;\n    [*] --&gt; Admit: Admit\n    Admit --&gt; RQ0\n    Admit --&gt; RQ1\n    Admit --&gt; RQ2\n    Admit --&gt; RQ3\n    Admit --&gt; RQn\n\n  Code: Code di Ready\n  state Code {\n    RQ0: Coda di Ready #0\n    RQ1: Coda di Ready #1\n    RQ2: Coda di Ready #2\n    RQ3: Coda di Ready #3\n    RQn: Coda di Ready #n\n  }\n\n  BQ: Coda Blocked\n  BQ --&gt; Admit: Event Occurs\n\n  state Dispatch &lt;&lt;join&gt;&gt;\n    RQ0 --&gt; Dispatch\n    RQ1 --&gt; Dispatch\n    RQ2 --&gt; Dispatch\n    RQ3 --&gt; Dispatch\n    RQn --&gt; Dispatch\n    Dispatch --&gt; Processor: Dispatch\n\n  Processor --&gt; [*]: Release\n  Processor --&gt; BQ: Event Wait\n  Processor --&gt; Admit: Preemption</code></pre> <p>\u00c8 uno schema che ragiona secondo un valore di priorit\u00e0 assegnato a ciascun processo: lo scheduler sceglier\u00e0 sempre il processo pronto con priorit\u00e0 maggiore. La priorit\u00e0 pu\u00f2 essere assegnata dall'utente o dal sistema e pu\u00f2 essere di tipo statico o dinamico. La priorit\u00e0 dinamica varia in base a:</p> <ul> <li>valore iniziale;</li> <li>caratteristiche del processo;</li> <li>richiesta di risorse;</li> <li>comportamento durante l'esecuzione.</li> </ul> <p>Tale modello \u00e8 generalmente applicato nei sistemi dove il tempo di risposta, soprattutto ad eventi esterni, \u00e8 critico.</p> <p>Il sistemista pu\u00f2 influire sull'ordine in cui uno scheduler serve gli eventi esterni modificando le priorit\u00e0 assegnate ai processi. Le prestazioni sono dipendenti da una accurata pianificazione nell'assegnazione delle priorit\u00e0. Le priorit\u00e0 possono essere definite:</p> <ul> <li>internamente al sistema operativo, utilizzando grandezze misurabili quali   l'uso di memoria, file aperti, rapporto tra picchi medi di I/O e di CPU;</li> <li>esternamente al sistema operativo, utilizzando la rilevanza del processo,   la sua criticit\u00e0.</li> </ul> <p>Il problema sta nel fatto che non \u00e8 in grado di garantire il completamento di un processo in un intervallo di tempo finito dalla sua creazione. Questo perch\u00e9 potrebbe essere continuamente sorpassato da processi a priorit\u00e0 pi\u00f9 alta. Tale situazione prende il nome di starvation.</p> <p>La soluzione soluzione sta nell'usare l'aging, ovvero al passare del tempo in stato di Ready, la priorit\u00e0 del processo aumenta.</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#round-robin-rr","title":"Round Robin (RR)","text":"<pre><code>gantt\n  title Round Robin (RR)\n  dateFormat  ss\n  axisFormat  %S\n\n  section A\n    Running     :A1,       0, 2s\n    Running     :A2, after B1, 1s\n\n  section B\n    Running     :B1, after A1, 1s\n    Running     :B2, after A2, 1s\n    Running     :B3, after C1, 1s\n    Running     :B4, after C2, 1s\n    Running     :B5, after C3, 1s\n    Running     :B6, after C4, 1s\n\n  section C\n    Running     :C1, after B2, 1s\n    Running     :C2, after D1, 1s\n    Running     :C3, after D2, 1s\n    Running     :C4, after D3, 1s\n\n  section D\n    Running     :D1, after B3, 1s\n    Running     :D2, after E1, 1s\n    Running     :D3, after E2, 1s\n    Running     :D4, after B6, 2s\n\n  section E\n    Running     :E1, after B4, 1s\n    Running     :E2, after B5, 1s</code></pre> <p>Utilizza come principio il time slice, ovvero una preemption basata sul clock (clock interrupt). Ogni processo utilizza il processore per un dato intervallo di tempo, i valori tipici sono \\(10\\)\u2013\\(100 \\millisecond\\).</p> <p>Al verificarsi dell'interrupt il processo in esecuzione viene portato nella coda di Ready, che \u00e8 gestita First In First Out (FIFO).</p> <p>Con \\(n\\) processi in Ready e un time quantum \\(q\\), ogni processo ottiene \\(\\ifrac{1}{n}\\) del tempo di CPU, con frazioni di tempo al pi\u00f9 pari a \\(q\\). Il tempo massimo di attesa in Ready \u00e8 pari a \\(q \\cdot (n \u2212 1)\\). Le prestazioni sono dipendenti dal time quantum, infatti:</p> <ul> <li>se \\(q\\) \u00e8 troppo grande, degenera in First Come First Served;</li> <li>se \\(q\\) troppo piccolo, il numero di context switch aumenta, causando un   consumo di risorse.</li> </ul> <p>La schedulazione Round Robin fornisce una buona condivisione delle risorse del sistema, perch\u00e9:</p> <ul> <li>i processi pi\u00f9 brevi possono completare l'operazione in un \\(q\\), il che   equivale ad un buon tempo di risposta;</li> <li>i processi pi\u00f9 lunghi sono forzati a passare pi\u00f9 volte per la coda dei   processi pronti, il tempo \u00e8 proporzionale alle loro richieste di risorse;</li> <li>per i processi interattivi lunghi, se l'esecuzione tra due fasi interattive   riesce a completarsi in un \\(q\\), il tempo di risposta \u00e8 buono.</li> </ul> <p>La realizzazione di uno scheduler Round Robin richiede il supporto di un Timer che invia un'interruzione alla scadenza di ogni \\(q\\), forzando lo scheduler a sostituire il processo in esecuzione. Il timer viene riazzerato se un processo cede il controllo al sistema operativo prima della scadenza del suo \\(q\\).</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#highest-response-ratio-next-hrrn","title":"Highest Response Ratio Next (HRRN)","text":"<p>Siano:</p> <ul> <li>\\(w\\) il tempo speso in coda di Ready, quindi in attesa della disponibilit\u00e0   del processore;</li> <li>\\(s\\) il tempo di servizio previsto.</li> </ul> <p>Si definisce il response ratio come:</p> \\[ \\text{response ratio} = \\frac{w + s}{s} = 1 + \\frac{w}{s} \\] <p>L'algoritmo Highest Response Ratio Next manda in esecuzione il processo con il pi\u00f9 alto valore di response ration. Osservazioni:</p> <ul> <li>quando un processo entra in coda per la prima volta ha un response ratio pari   a \\(1\\);</li> <li>tiene in considerazione l'et\u00e0 del processo, applica quindi un meccanismo di   aging, \u00e8 proprio \\(w\\).</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#shortest-process-next-spn","title":"Shortest Process Next (SPN)","text":"<pre><code>gantt\n  title Shortest Process Next (SPN)\n  dateFormat  ss\n  axisFormat  %S\n\n  section A\n    Running     :A,     0, 3s\n\n  section B\n    Running     :B, after A, 6s\n\n  section C\n    Running     :C, after E, 4s\n\n  section D\n    Running     :D, after C, 2s\n\n  section E\n    Running     :E, after B, 2s</code></pre> <p>Il processo scelto dalla coda di Ready \u00e8 quello con il pi\u00f9 breve tempo di esecuzione stimato, ovvero la pi\u00f9 breve sequenza di operazioni svolte dal processore.</p> <p>Il pro \u00e8 che il Shortest Process Next \u00e8 ottimale nel fornire il tempo di attesa minimo per un dato insieme di processi. Il contro \u00e8 che \u00e8 sia difficile stimare la durata della prossima sequenza di CPU che oneroso, \u00e8 inoltre possibile la starvation per processi fortemente CPU-bound.</p> <p>Ha una versione preemptive: se arriva nuovo processo con una sequenza di CPU minore del tempo necessario per la conclusione della sequenza di CPU del processo attualmente in esecuzione, si ha il prerilascio della CPU a favore del processo appena arrivato. Questo schema \u00e8 anche noto come Shortest Remaining Time First (SRTF) oppure Shortest Remaining Time Next (SRTN).</p>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#schedulazione-a-code-multiple","title":"Schedulazione a code multiple","text":"<pre><code>stateDiagram-v2\n  direction LR\n  system: System Processes\n  interactive: Interactive Processes\n  interactiveEditing: Interactive Editing Processes\n  batch: Batch Processes\n  student: Student Processes\n\n  state ready &lt;&lt;fork&gt;&gt;\n    [*] --&gt; ready\n    ready --&gt; system: Hi Priority\n    ready --&gt; interactive\n    ready --&gt; interactiveEditing\n    ready --&gt; batch\n    ready --&gt; student: Lo Priority\n\n  state stop &lt;&lt;join&gt;&gt;\n    system --&gt; stop\n    interactive --&gt; stop\n    interactiveEditing --&gt; stop\n    batch --&gt; stop\n    student --&gt; stop\n    stop --&gt;  [*]</code></pre> <p>La coda di Ready viene divisa in sotto-code:</p> <ul> <li>Foreground, per processi interattivi;</li> <li>Background, per processi batch.</li> </ul> <p>Ogni coda ha un proprio algoritmo di schedulazione (es. Foreground con Round Robin, Background con First Come First Served). Vi \u00e8 necessita di uno scheduling tra le code:</p> <ul> <li>a priorit\u00e0 fissa e con prelazione (es. serve prima la coda Foreground e   poi quella di Background);</li> <li>time slice, a ogni coda \u00e8 associato un certo ammontare di tempo di CPU (es.   \\(80\\%\\) alla Foreground con Round Robin, \\(20\\%\\) alla Background con FCFS).</li> </ul>"},{"location":"Anno_I/AESO/SO1_so_processi_scheduling/#schedulazione-a-code-multiple-con-feedback","title":"Schedulazione a code multiple con feedback","text":"<pre><code>stateDiagram-v2\n  direction LR\n  q8: Round Robin, q = 8s\n  q16: Round Robin, q = 16s\n  fcfs: First Come First Served\n\n  [*] --&gt; q8: Ingresso\n  q8 --&gt; q16: Timeout\n  q16 --&gt; fcfs: Timeout\n  fcfs --&gt; [*]: Release\n  q16 --&gt; [*]: Release\n  q8 --&gt; [*]: Release</code></pre> <p>Implementa l'aging: un processo pu\u00f2 essere spostato da una coda all'altra.</p> <p>Le code Multilevel-Feedback sono definite dai seguenti parametri:</p> <ul> <li>Numero di code;</li> <li>Algoritmo di scheduling per ogni coda;</li> <li>Metodi usati per l'upgrading e il downgrading di ogni processo.</li> </ul> <p>Esempio</p> <p>Tre code:</p> <ul> <li>\\(Q_0\\) con Round Robin con \\(q = 8 \\millisecond\\);</li> <li>\\(Q_1\\) con Round Robin con \\(q = 16 \\millisecond\\);</li> <li>\\(Q_2\\) con First Come First Served.</li> </ul> <p>Scheduling:</p> <ul> <li>Un nuovo processo entra nella coda \\(Q_0\\)</li> <li>Quando ottiene la CPU, la impegna per \\(8 \\millisecond\\). Se non termina   entro gli \\(8 \\millisecond\\) viene spostato in \\(Q_1\\);</li> <li>Il processo in \\(Q_1\\) viene nuovamente servito con politica Round Robin   e riceve la CPU per ulteriori \\(16 \\millisecond\\);</li> <li>Se ancora non termina viene spostato in \\(Q_2\\) e servito con First Come   First Served.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/","title":"Thread, SMP e Microkernel","text":""},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#thread","title":"Thread","text":"<p>Un thread \u00e8 un flusso di esecuzione indipendente (traccia) all'interno di un processo. Un processo pu\u00f2 essere diviso in pi\u00f9 thread per:</p> <ul> <li>ottenere un parallelismo dei flussi di esecuzione all'interno del processo;</li> <li>gestire chiamate bloccanti o situazioni di risposta asincrona.</li> </ul> <pre><code>stateDiagram-v2\n  state Processo {\n    Thread1: Thread #1\n    state Thread1 { [*] --&gt; [*] }\n    Thread2: Thread #2\n    state Thread2 { [*] --&gt; [*] }\n  }</code></pre> <p>Esempio</p> <p>Si desidera implementare un web server. Se lo si implementasse come un processo mono-thread, potrebbe gestire solamente un client alla volta. Le altre richieste verrebbero completamente ignorate, neanche poste in coda.</p> <p>Se il server venisse implementato come un processo che resta in attesa delle richieste, vi sono due possibili soluzioni:</p> <ul> <li>Avviare un nuovo processo che processi la singola richiesta;</li> <li>Avviare un nuovo thread che processi la singola richiesta.</li> </ul> <p>Avviare un nuovo processo \u00e8 molto pi\u00f9 oneroso rispetto all'avviare un nuovo thread. Allo stesso modo, effettuare il context-switch di un processo \u00e8 molto pi\u00f9 oneroso rispetto a quello di un thread.</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#multithreading","title":"Multithreading","text":"<p>Il multithreading \u00e8 la capacit\u00e0 di un sistema operativo di supportare pi\u00f9 thread per ogni processo.</p> <pre><code>stateDiagram-v2\n  SingleProcess1: Processo Singolo\n  state SingleProcess1 {\n    SingleThread1: Thread Singolo\n    state SingleThread1 { Inizio --&gt; Fine }\n  }\n\n  SingleProcess2: Processo Singolo\n  state SingleProcess2 {\n    MultipleThreads1: Thread Multipli\n    state MultipleThreads1 {\n      Inizio1: Inizio\n      Inizio2: Inizio\n      Fine1: Fine\n      Fine2: Fine\n      Inizio1 --&gt; Fine1\n      Inizio2 --&gt; Fine2\n    }\n  }</code></pre> <pre><code>stateDiagram-v2\n  MultipleProcesses1: Processi Multipli\n  state MultipleProcesses1 {\n    SingleProcess3: Processo Singolo #1\n    state SingleProcess3 {\n      SingleThread2: Thread Singolo\n      state SingleThread2 {\n        Inizio3: Inizio\n        Fine3: Fine\n        Inizio3 --&gt; Fine3\n      }\n    }\n    SingleProcess4: Processo Singolo #2\n    state SingleProcess4 {\n      SingleThread3: Thread Singolo\n      state SingleThread3 {\n        Inizio4: Inizio\n        Fine4: Fine\n        Inizio4 --&gt; Fine4\n       }\n    }\n  }\n\n  MultipleProcesses2: Processi Multipli\n  state MultipleProcesses2 {\n    SingleProcess5: Processo Singolo #1\n    state SingleProcess5 {\n      MultipleThreads2: Thread Multipli\n      state MultipleThreads2 {\n        Inizio5: Inizio\n        Inizio6: Inizio\n        Fine5: Fine\n        Fine6: Fine\n        Inizio5 --&gt; Fine5\n        Inizio6 --&gt; Fine6\n      }\n    }\n    SingleProcess6: Processo Singolo #1\n    state SingleProcess6 {\n      MultipleThreads3: Thread Multipli\n      state MultipleThreads3 {\n        Inizio7: Inizio\n        Inizio8: Inizio\n        Fine7: Fine\n        Fine8: Fine\n        Inizio7 --&gt; Fine7\n        Inizio8 --&gt; Fine8\n      }\n    }\n  }</code></pre> <p>Un sistema operativo con singolo processo a singolo thread \u00e8 ad esempio MS-DOS, il thread esiste all'interno nel processo.</p> <p>Un sistema operativo con processi multipli a singolo thread \u00e8 lo UNIX.</p> <p>Sistemi operativi multithread sono ad esempio:</p> <ul> <li>Windows</li> <li>Solaris</li> <li>MAC</li> <li>OS/2</li> </ul> ProcessoThread <p>Un processo possiede delle risorse, dunque ha uno spazio di indirizzamento virtuale che contiene l'immagine del processo. Pu\u00f2 inoltre chiedere:</p> <ul> <li>ulteriore memoria;</li> <li>il controllo di canali di I/O;</li> <li>il controllo di dispositivi;</li> <li>files.</li> </ul> <p>Possiede inoltre: uno stato (Ready, Running, Blocked, Suspended) e una priorit\u00e0. Deve essere schedulato.</p> <p>Le informazioni del processo sono contenute nel Process Control Block (PCB).</p> <p>Un thread non possiede risorse in quanto utilizza quelle del processo. Viene anche chiamato Light Weight Process.</p> <p>Il thread possiede un proprio stato, una propria priorit\u00e0 e deve essere schedulato tra gli stessi thread, sottostando per\u00f2 alla schedulazione del processo. I thread inoltre:</p> <ul> <li>Condividono lo stato e le risorse del processo a cui appartengono;</li> <li>Risiedono nello stesso spazio di indirizzamento;</li> <li>Hanno accesso agli stessi dati.</li> </ul> <p>Le informazioni del thread sono contenute nel Thread Control Block.</p> <p>Dunque \u00e8 pi\u00f9 facile condividere le informazioni tra i thread.</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#vantaggi-dei-thread","title":"Vantaggi dei thread","text":"<p>I thread posseggono vari vantaggi rispetto ai processi:</p> <ul> <li>il tempo di creazione di un nuovo thread \u00e8 minore di quello di creazione di   un nuovo processo;</li> <li>il tempo di terminazione di un thread \u00e8 minore di quello di terminazione di   un processo;</li> <li>il tempo necessario allo switch tra threads all'interno dello stesso processo   \u00e8 minore rispetto al tempo di switch tra processi;</li> </ul> <p>I thread all'interno di uno stesso processo condividono sia memoria che files: lo scambio dei dati avviene senza la richiesta di intervento del kernel. Vi \u00e8 per\u00f2 la necessit\u00e0 di sincronizzare le attivit\u00e0 dei threads.</p> <p>Alcuni esempi:</p> <ul> <li>l'esecuzione foreground e background, es. il foglio di calcolo: un thread   gestisce il men\u00f9 e legge i comandi, un altro li esegue e aggiorna il foglio;</li> <li>l'elaborazione asincrona, es. elaboratore di testo: un thread di scarico su   disco ad ogni minuto evita delle perdite per cadute di tensione;</li> <li>la velocit\u00e0 di esecuzione: la lettura e il calcolo effettuati da thread   diversi aumentano la velocit\u00e0.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#svantaggi-dei-thread","title":"Svantaggi dei thread","text":"<p>I thread presentano due svantaggi principali:</p> <ul> <li>la sospensione di un processo richiede la sospensione contemporanea di tutti   i thread contenuti nello stesso. Questo poich\u00e9 bisogna liberare lo spazio   in memoria e i thread utilizzano lo stesso spazio di memoria condivisa;</li> <li>la terminazione di un processo richiede che tutti i threads siano terminati.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#stati-dei-thread","title":"Stati dei thread","text":"<p>Posseggono tre stati: Ready, Running e Blocked.</p> <p>Lo stato Suspended non \u00e8 presente poich\u00e9 non ha senso per un thread, \u00e8 gi\u00e0 presente a livello di processo. Se un processo viene swappato, lo stesso avviene per tutti i suoi thread.</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#operazioni-di-base","title":"Operazioni di base","text":"<p>Un thread ha quattro operazioni di base:</p> <ol> <li>creazione:<ul> <li>la creazione di un processo implica la creazione di un thread;</li> <li>un thread pu\u00f2 creare altri thread.</li> </ul> </li> <li>Blocco (attesa di un evento):<ul> <li>salvataggio del contesto per il thread: PC, Stack pointer, registri CPU</li> </ul> </li> <li>Sblocco:<ul> <li>lo stato nelTCB viene modificato (Blocked -&gt; Ready)</li> <li>il thread viene accodato a quelli in attesa di processore</li> </ul> </li> <li>Terminazione:<ul> <li>deallocazione del contesto registri, deallocazione stack</li> </ul> </li> </ol> <p>Il blocco di un thread blocca l'intero processo? no (?).</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#esempi-di-multithreading","title":"Esempi di multithreading","text":"<p>Un esempio di multithreading \u00e8 il Remote Procedure Call, ovvero la chiamata da parte di un processo a una procedura attiva su un elaboratore diverso dal chiamante. Vediamo il caso di due chiamate RPC diverse a diversi host:</p> <pre><code>gantt\n  title RCP utilizzando un Thread singolo\n  dateFormat  ss\n  axisFormat  %L\n  section Process 1\n    RCP req.        :milestone, m1, after run, 0ms\n    Running         :run, 0, 1ms\n    Blocked         :crit, block, after run, 2ms\n\n    RCP req. start  :milestone, m1, after run1, 0s\n    Running         :run1, after block, 1ms\n    Blocked         :crit, block1, after run1, 2ms\n\n    Running         :run2, after block1, 3ms</code></pre> <p>Il questo caso, dopo la RPC, il processo resta in attesa di risposta del server, senza effettuare alcuna operazione.</p> <pre><code>gantt\n  title RCP utilizzando un Thread per server\n  dateFormat  ss\n  axisFormat  %L\n  section Thread A\n    RCP request             :milestone, RCP1, after runA, 0ms\n    Running                 :runA, 0, 1ms\n    Blocked                 :crit, blockA, after runA, 2ms\n    Running                 :runA1, after blockA, 2ms\n    Wait for processor      :crit, blockA1, after runA1, 1ms\n    Running                 :runA2, after blockA1, 2ms\n\n  section Thread B\n    RCP request       :milestone, RCP2, after runB, 0ms\n    Running           :runB, after runA, 1ms\n    Blocked           :crit, blockB, after runB, 2ms\n    Running           :runB1, after blockB, 2ms</code></pre> <p>In questo caso, invece, quando viene effettuata una richiesta RPC, il processo si sposta su un altro thread. In questo modo il tempo di attesa viene ridotto.</p> <p>Un altro esempio di multithreading \u00e8 un programma di video-scrittura, gestione e pubblicazione di pagine su desktop. Questo possiede tre thread sempre attivi:</p> <ol> <li>gestione degli eventi;</li> <li>gestione dei servizi (stampa, lettura dati, disposizione testo, attivazione    di altri thread);</li> <li>disegno dello schermo.</li> </ol> <p>Un altro esempio ancora \u00e8 quello dello scorrimento pagina con barra laterale. In questo caso il thread eventi controlla la barra di scorrimento, il thread di ridisegno dello schermo ridisegna la pagina in base allo spostamento. Vi \u00e8 ovviamente la necessit\u00e0 di sincronizzare i due threads.</p> <p>Attenzione</p> <p>Esistono delle attivit\u00e0 che sono bloccanti per tutti i thread. Quando accade compare il cursore \"busy\".</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#categorie-di-thread","title":"Categorie di Thread","text":"User Level ThreadKernel Level Thread <p>I thread a livello utente sono:</p> <ul> <li>realizzati tramite librerie senza l'intervento del kernel (es. di librerie:   Posix Pthread, Mach C-threads, UI-threads Solaris2);</li> <li>trasparenti al Kernel.</li> </ul> <p>Lo svantaggio \u00e8 che se il Kernel \u00e8 a singolo thread il blocco del thread a livello utente blocca l'intero processo (il sistema operativo continua a schedulare i processi).</p> <p>Nei thread a livello di kernel:</p> <ul> <li>lo stesso kernel si occupa della creazione, scheduling e gestione;</li> <li>i thread possono essere eseguiti su diversi processori;</li> <li>la gestione \u00e8 per\u00f2 pi\u00f9 lenta degli ULT.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#user-level-thread","title":"User Level Thread","text":"<pre><code>stateDiagram-v2\n  direction BT\n\n  UserSpace: Spazio Utente\n  state UserSpace {\n    Thread1: Thread #1\n    Thread2: Thread #2\n    Thread3: Thread #3\n    ThreadsLibrary: Libreria Utente\n    state ThreadsLibrary {\n      state ProcessFork &lt;&lt;fork&gt;&gt;\n    }\n  }\n\n  KernelSpace: Spazio Kernel\n  state KernelSpace { Process }\n  Process --&gt; ProcessFork\n  ProcessFork --&gt; Thread1\n  ProcessFork --&gt; Thread2\n  ProcessFork --&gt; Thread3</code></pre> <p>Il lavoro di gestione dei threads \u00e8 svolto dalla libreria utente. Per questo il kernel ignora l'esistenza dei threads. Gli ULT utilizzano il modello molti a uno.</p> <p>La libreria permette di:</p> <ul> <li>creare e distruggere i threads;</li> <li>scambiare messaggi tra threads;</li> <li>schedulare;</li> <li>salvare e caricare i contesti dei thread.</li> </ul> <p>Tali attivit\u00e0 sono svolte all'interno del processo utente, pertanto il kernel continua a schedulare i processi come unit\u00e0 a s\u00e8 stanti.</p> <p>I vantaggi dell'ULT sono i seguenti:</p> <ul> <li>risparmio di sovraccarico, questo avviene perch\u00e9 il cambio di thread avviene   all'interno dello spazio di indirizzamento utente e non viene richiesto   l'intervento del kernel;</li> <li>schedulazione differente per ogni applicazione, c'\u00e8 un'ottimizzazione in base   al tipo di applicazione;</li> <li>viene eseguito da qualsiasi sistema operativo, la libreria a livello utente   \u00e8 condivisa dalle applicazioni.</li> </ul> <p>Gli svantaggi dell'ULT sono i seguenti:</p> <ul> <li>la chiamata a sistema da parte di un thread blocca tutti i thread del processo;</li> <li>il kernel assegna un processo a un singolo processore, quindi non \u00e8 possibile   avere multiprocessing a livello di thread (thread dello stesso processo su pi\u00f9   processori);</li> </ul> <p>Delle soluzioni parziali sono:</p> <ul> <li>sviluppare l'applicazione a livello di processi, andando a perdere i vantaggi   dei threads;</li> <li>fare uso del jacketing, ovvero convertire una chiamata bloccante in una   non bloccante. Nel caso di I/O si invoca una procedura di jacketing che   verifica se il dispositivo \u00e8 occupato, se s\u00ec il thread passa in Ready e un   altro thread va in Running.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#kernel-level-thread-puro","title":"Kernel Level Thread puro","text":"<pre><code>stateDiagram-v2\n  direction BT\n\n  UserSpace: Spazio Utente\n  state UserSpace {\n    Thread1: Thread #1\n    Thread2: Thread #2\n    Thread3: Thread #3\n  }\n\n  KernelSpace: Spazio Kernel\n  note left of KernelSpace\n    La gestione dei thread\n    avviene nello Spazio Kernel\n  end note\n  state KernelSpace {\n    state ProcessFork &lt;&lt;fork&gt;&gt;\n    Process --&gt; ProcessFork\n  }\n  ProcessFork --&gt; Thread1\n  ProcessFork --&gt; Thread2\n  ProcessFork --&gt; Thread3</code></pre> <p>Il lavoro di gestione dei threads \u00e8 svolto dal kernel e fa uso del modello uno a uno. A livello utente una API consente l'accesso alla parte del kernel che gestisce.</p> <p>Il kernel mantiene informazioni su:</p> <ul> <li>contesto del processo;</li> <li>contesto dei threads;</li> <li>scambio messaggi tra threads.</li> </ul> <p>La schedulazione viene effettuata a livello di thread:</p> <ul> <li>se un thread di un processo \u00e8 bloccato, una altro thread dello stesso processo   pu\u00e0 essere eseguito;</li> <li>i thread di uno stesso processo possono essere schedulati su diversi processori.</li> </ul> <p>Lo svantaggio del KLT \u00e8 che il trasferimento del controllo da un thread a un altro richiede l'intervento del kernel (overhead).</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#approcci-misti","title":"Approcci misti","text":"<pre><code>stateDiagram-v2\n  direction BT\n\n  UserSpace: Spazio Utente\n  state UserSpace {\n    ThreadsLibrary: Libreria Utente\n    state ThreadsLibrary {\n      state ThreadsLibFork &lt;&lt;fork&gt;&gt;\n    }\n    UserThread1: Thread Utente #1\n    UserThread2: Thread Utente #2\n    UserThread3: Thread Utente #3\n    UserThread4: Thread Utente #4\n  }\n\n  KernelSpace: Spazio Kernel\n  state KernelSpace {\n    Process1: Processo #1\n    Process2: Processo #2\n    KernelThread1: Thread Kernel #1\\n (processo #1)\n    KernelThread2: Thread Kernel #2\\n (processo #1)\n    KernelThread3: Thread Kernel #1\\n (processo #2)\n  }\n\n  Process1 --&gt; KernelThread1\n  Process1 --&gt; KernelThread2\n  Process2 --&gt; KernelThread3\n  ThreadsLibFork --&gt; UserThread1\n  ThreadsLibFork --&gt; UserThread2\n  ThreadsLibFork --&gt; UserThread3\n\n  KernelThread1 --&gt; ThreadsLibFork\n  KernelThread2 --&gt; ThreadsLibFork\n  KernelThread3 --&gt; UserThread4</code></pre> <p>Fa uso del modello molti a molti, ovvero pi\u00f9 thread di livello utente sono in corrispondenza con pi\u00f9 thread di livello kernel.</p> <p>I thread sono creati nello spazio utente, vari thread di uno stesso processo possono essere eseguiti contemporaneamente su pi\u00f9 processori, inoltre una chiamata bloccante non blocca necessariamente l'intero processo. Vi \u00e8 la necessit\u00e0 di comunicazione fra kernel e libreria di thread per mantenere un appropriato numero di thread kernel allocati all'applicazione.</p> <p>Con LWP si intende una struttura intermedia che appare alla libreria dei thread utente come un processore virtuale sul quale schedulare l'esecuzione. As esempio una applicazione CPU-bound su un sistema monoprocessore implica| che un solo thread per volta possa essere eseguito, quindi per essa sar\u00e0 sufficiente un unico LWP per thread.</p> <p>Una applicazione I/O-bound tipicamente richiede un LWP per ciascuna chiamata di sistema bloccante.</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#relazione-tra-thread-e-processi","title":"Relazione tra Thread e Processi","text":"Thread a processi Descrizione Sistemi uno a uno Ogni thread di esecuzione \u00e8 unprocesso unico con il proprio spaziodi indirizzamento e le proprie risorse Molte implementazioni di UNIX molti a uno Ogni processo ha associato un propriospazio di indirizzamento e delle risorse.In ogni processo si possono creare edeseguire molti thread WindowsNTSolarisOS/2MACH uno a molti Un thread pu\u00f2 spostarsi da un processoall\u2019altro: ci\u00f2 permette di spostarefacilmente i thread tra sistemi diversi Ra(clouds)Emerald molti a molti Combina le propriet\u00e0 degli approcci molti a uno e uno a molti TRIX <p>Gli ultimi due punti (uno a molti e molti a molti), sono ambienti distribuiti: i thread possono spostarsi tra pi\u00f9 calcolatori.</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#symmetric-multi-processing","title":"Symmetric Multi Processing","text":"<p>\u00c8 un sistema multiprocessore con una memoria centralizzata condivisa chiamata memoria principale, operante sotto un unico sistema operativo con due o pi\u00f9 processori omogenei. Nel SMP:</p> <ul> <li>i processori condividono le stesse risorse;</li> <li>tutti i processori possono effettuare le stesse funzioni;</li> <li>ogni processore esegue una stessa copia del sistema operativo;</li> <li>ogni processore gestisce la schedulazione dei processi o thread disponibili.</li> </ul> <p>Le difficolt\u00e0 del SMP sono le seguenti:</p> <ul> <li>i processori non devono schedulare lo stesso processo;</li> <li>la comunicazione tra processori: memoria condivisa (possibilit\u00e0 di effettuare   accessi simultanei alla memoria \u2013 memoria multiporta);</li> <li>coerenza della cache: RAW, WAR, RAR, WAW (risolto a livello hardware).</li> </ul> <p>il multiprocessore deve essere trasparente all'utente: il programmatore deve operare come se fosse in multiprogrammazione su monoprocessore.</p> <p>I punti critici della progettazione di un sistema operativo per SMP sono i seguenti:</p> <ul> <li>processi e thread del Kernel concorrenti: l'esecuzione contemporanea su   diversi processori non deve compromettere le strutture di gestione del sistema   operativo (tabelle, etc);</li> <li>schedulazione: vi \u00e8 necessit\u00e0 di evitare conflitti;</li> <li>sincronizzazione: mutua esclusione e ordinamento degli eventi;</li> <li>gestione della memoria condivisa;</li> <li>tolleranza ai guasti: in caso di \"perdita di un processore\" devono essere   aggiornate le strutture di controllo del sistema operativo.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#stati-dei-thread-in-windows","title":"Stati dei Thread in Windows","text":"<pre><code>stateDiagram-v2\n  direction LR\n  state Eseguibile {\n    direction LR\n    Ready --&gt; Standby: Scelta processo\\n da eseguire\n    Running --&gt; Ready: Interrotto\n    Standby --&gt; Running: Scambio\n  }\n  NonEseguibile: Non Eseguibile\n  state NonEseguibile {\n    direction LR\n    Waiting --&gt; Transition: Sblocca risorsa\\n non disponibile\n    Terminated\n  }\n  Running --&gt; Terminated: Termina\n  Running --&gt; Waiting: Blocca/Sospendi\n  Waiting --&gt; Ready: Sblocca/Ripristina\\n risorsa disponibile\n  Transition --&gt; Ready: Risorsa disponibile</code></pre> <p>Lo stato Standby \u00e8 legato alla disponibilit\u00e0 del processore (SMP) richiesto per il thread. Se la priorit\u00e0 \u00e8 sufficientemente alta, il processo in Running pu\u00f2 essere interrotto. Lo stato di Waiting \u00e8 legato all'I/O e all'attesa per la sincronizzazione. Lo stato Transition si ha quando il thread \u00e8 pronto per l'esecuzione ma le risorse non sono disponibili (es. lo stack pu\u00f2 essere stato spostato su disco mentre era in waiting).</p> <p>Supporto di SMP:</p> <ul> <li>i thread (inclusi quelli del kernel) possono essere eseguiti su ogni   processore;</li> <li>il primo thread in Ready viene assegnato al primo processore disponibile;</li> <li>i thread appartenenti allo stesso processo possono essere eseguiti   contemporaneamente) su diversi processori;</li> <li>l'esecuzione di un thread sempre sullo stesso processore porta ad avere i   dati ancora in cache.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#microkernel","title":"MicroKernel","text":"<p>\u00c8 un piccolo nucleo del sistema operativo e contiene le funzioni essenziali di quest'ultimo. I servizi tradizionalmente inclusi nel sistema operativo sono sottosistemi esterni al microkernel ed eseguiti in modalit\u00e0 utente, quali:</p> <ul> <li>device drivers</li> <li>file systems</li> <li>virtual memory manager</li> <li>windowing system</li> <li>security services</li> </ul> <p>L'interazione in un Kernel a livelli avviene solo tra strati adiacenti, mentre nel Microkernel la comunicazione avviene attraverso quest'ultimo, che ridireziona i messaggi.</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#vantaggi-del-microkernel","title":"Vantaggi del MicroKernel","text":"<p>I vantaggi del microKernel sono i seguenti:</p> <ul> <li>interfaccia uniforme: i moduli usano le stesse interfacce per le richieste   al microKernel;</li> <li>estensibilit\u00e0: l'introduzione di nuovi servizi o modifiche non richiede   modifiche del microKernel;</li> <li>flessibilit\u00e0: a seconda delle applicazioni certe caratteristiche possono   essere ridotte o potenziate per soddisfare al meglio le richieste dei clienti   (es. Windows Home/Professional/Ultimate);</li> <li>portabilit\u00e0: il cambio dell'hardware comporter\u00e0 unicamente la modifica del   microkernel.</li> <li>affidabilit\u00e0: lo sviluppo di piccole porzioni di codice ne permette una   migliore ottimizzazione e test.</li> <li>supporto ai sistemi distribuiti: ogni servizio \u00e8 identificato da un numero   nel microkernel e una richiesta da client non \u00e8 necessario che sappia dove si   trova il server in grado di soddisfare la stessa. La messaggistica viene   gestita dal microkernel.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#design-del-microkernel","title":"Design del MicroKernel","text":"<p>Il microKernel deve contenere:</p> <ul> <li>le funzioni che dipendono direttamente dall'hardware (gestione degli interrupt   e I/O);</li> <li>le funzioni per la comunicazione tra processi (IPC);</li> <li>gestione primitiva della memoria;</li> </ul> <p>I sistemi con microKernel presentano un problema a livello di prestazioni: Costruire, inviare, accettare, decodificare un messaggio costa pi\u00f9 che una chiamata al sistema operativo. Le possibili soluzioni sono:</p> <ul> <li>aggiungere funzionalit\u00e0 al microkernel riduce il numero di cambiamenti di   stato (utente/kernel). Vi \u00e8 per\u00f2 una riduzione di flessibilit\u00e0, interfacce   minime, etc;</li> <li>ridurre ulteriormente il microkernel.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#funzioni-minime-del-microkernel","title":"Funzioni minime del MicroKernel","text":""},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#gestione-primitiva-della-memoria","title":"Gestione primitiva della memoria","text":"<p>Un modulo esterno al microkernel mappa pagine virtuali in pagine fisiche, il mapping \u00e8 conservato in memoria principale.</p> <ul> <li>un'applicazione che accede ad una pagina che non si trova in memoria genera   un page fault;</li> <li>l'esecuzione passa al microKernel che invia un messaggio al paginatore   comunicando la pagina richiesta;</li> <li>la pagina viene caricata: il paginatore e il kernel collaborano per il mapping   memoria reale-virtuale;</li> <li>quando viene caricata la pagina il pager invia un messaggio all'applicazione.</li> </ul>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#comunicazione-tra-processi","title":"Comunicazione tra processi","text":"<p>Il messaggio \u00e8 composto nel seguente modo:</p> \\[ \\bnf{messaggio} \\Coloneqq \\bnf{intestazione} + \\bnf{corpo} + \\bnf{puntatore} \\] <p>dove l'intestazione \u00e8 composta da mittente e ricevente, il corpo contiene i dati del messaggio e il puntatore contiene le informazioni di controllo del processo e il blocco dati.</p> <p>Associata ad ogni processo c'\u00e8 una porta: una capability list indica chi pu\u00f2 inviare messaggi. Tale porta \u00e8 amministrata dal Kernel.</p>"},{"location":"Anno_I/AESO/SO2_thread_smp_microkernel/#gestione-degli-interrupt-e-dellio","title":"Gestione degli Interrupt e dell'I/O","text":"<p>Il microkernel riconosce gli interrupt ma non li gestisce direttamente, trasforma l'interrupt in messaggio a livello utente, che invia al processo che gestisce l'interrupt</p> Text Only<pre><code>driver thread:\nESEGUI\n    wait(msg, mittente)\n    SE (mittente = mio_interrupt_hardware)\n        ALLORA\n            leggi/scrivi le porte di I/O\n            azzera l'output hardware\n        ALTRIMENTI\n            &gt;&gt; ....\n    FINE\nFINE\n</code></pre>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/","title":"Gestione delle risorse e problematiche annesse","text":""},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#gestione-delle-risorse","title":"Gestione delle risorse","text":"<p>I processi utilizzano delle risorse (es. bus, CPU, stampanti, etc). Tali risorse sono gestite dal sistema operativo, che le governa e le amministra. Il sistema operativo decide in merito all'assegnazione delle risorse ai processi, disponendo l'ordine di accesso dei processi a queste e le modalit\u00e0 di accesso</p> <p>I processi utilizzano le risorse per tramite del sistema operativo, che trasmette le operazioni agli strati sottostanti per conto dei processi. La gestione delle risorse pu\u00f2 portare a diverse problematiche, le quali devono essere accuratamente attenzionate. Tali problematiche sono legate alla concorrenza e alla mutua esclusione delle risorse. Una risorsa singola pu\u00f2 generalmente essere assegnata a un solo processo alla volta (mutua esclusione).</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#grafo-di-allocazione-delle-risorse","title":"Grafo di allocazione delle risorse","text":"<p>Un grafo di allocazione delle risorse \u00e8 un grafo che rappresenta in che modo le risorse sono assegnate ai processi e le richieste dei processi.</p> <pre><code>stateDiagram-v2\n  direction LR\n  P1: P\u2081\n  Ra: R\u2090\n  P1 --&gt; Ra: requests</code></pre> La risorsa viene richiesta <pre><code>stateDiagram-v2\n  direction LR\n  P1: P\u2081\n  Ra: R\u2090\n  Ra --&gt; P1: Held by</code></pre> La risorsa viene tenuta"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#stallo-di-processi","title":"Stallo di processi","text":"<p>Lo stallo di processi (deadlock) \u00e8 una delle condizioni problematiche che possono verificarsi nell'ambito della gestione delle risorse.</p> <p>Deadlock</p> <p>Un insieme di processi \u00e8 detto \"in stallo\" se ciascun processo nell'insieme \u00e8 in attesa di un evento che solo un altro processo nello stesso insieme pu\u00f2 generare.</p> <p>Generalmente l'evento \u00e8 il rilascio di una risorsa detenuta da uno dei processi.</p> <p>Negli scacchi, lo stallo \u00e8 la condizione in cui il Re non pu\u00f2 effettuare mosse legittime pur non essendo sotto scacco.</p> <p>Lo stallo comporta che, essendo tutti i processi in attesa di un evento, sono nello stato di Blocked. Tale situazione comporta che nessuno dei processi in stallo pu\u00f2:</p> <ul> <li>passare in esecuzione, poich\u00e9 necessita del verificarsi dell'evento;</li> <li>rilasciare risorse, in quanto non pu\u00f2 passare in esecuzione.</li> </ul> <p>Nessuno dei processi in stallo pu\u00f2 quindi passare in Running, pertanto nessuno dei processi in stallo pu\u00f2 essere riattivato. I processi in stallo sono quindi congelati nella situazione di stallo a meno di un intervento da parte del sistema operativo o dell'amministratore.</p> <pre><code>flowchart LR\n  P1[\"P\u2081\"] --&gt;|Requests| Ra[\"R\u2081\"]\n  Ra --&gt;|Held by| P2[\"P\u2082\"]\n  P2 --&gt;|Requests| Rb[\"R\u2082\"]\n  Rb --&gt;|Held by| P1</code></pre> <p>Lo stallo di processi per verificarsi necessit\u00e0 della congiunzione di quattro condizioni:</p> <ol> <li>mutua esclusione (oppure risorse seriali): un solo processo alla volta pu\u00f2    utilizzare una risorsa;</li> <li>hold &amp; wait (oppure possesso e attesa): un processo pu\u00f2 mantenere il    possesso delle risorse allocate mentre attende di averne altre;</li> <li>assenza di prerilascio (oppure assenza di prelazione o risorse non    prerilasciabili): i processi non possono essere forzati a rilasciare in    anticipo le risorse acquisite;</li> <li>attesa circolare: un processo aspetta una risorsa occupata da un altro    processo in attesa circolare</li> </ol> <p>Le prime tre condizioni sono necessarie ma non sufficienti, aggiungendovi l'attesa circolare, diventano necessarie e sufficienti. Inoltre, le prime tre derivano direttamente dalla progettazione e sono in molti casi auspicabili, l'attesa circolare invece \u00e8 un evento che si pu\u00f2 verificare e che dipende dalla particolare sequenza di richieste e rilasci.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#strategie-per-affrontare-lo-stallo","title":"Strategie per affrontare lo stallo","text":"<p>Sono possibili quattro diverse strategie per affrontare il problema dello stallo di processi:</p> <ol> <li>ignorare il problema (algoritmo dello struzzo);</li> <li>consentire il verificarsi dello stallo, rilevarlo e risolverlo;</li> <li>evitarlo con politiche di allocazione: le tre condizioni necessarie sono    permesse, un algoritmo verifica dinamicamente che una richiesta non produca    una situazione di stallo;</li> <li>impedirlo rimuovendone le condizioni: progettare un sistema operativo in modo    che la possibilit\u00e0 di avere uno stallo sia esclusa a priori tramite la    negazione di una delle quattro condizioni.</li> </ol>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#algoritmo-dello-struzzo","title":"Algoritmo dello struzzo","text":"<p>L'algoritmo dello struzzo pretende che il problema non esista. \u00c8 una soluzione ragionevole se:</p> <ul> <li>lo stallo capita di rado</li> <li>il costo per evitare lo stallo \u00e8 troppo elevato</li> </ul> <p>Si ha quindi un compromesso tra convenienza e correttezza. Windows e UNIX utilizzano principalmente questo approccio.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#consentirlo-rilevarlo-e-risolverlo","title":"Consentirlo, rilevarlo e risolverlo","text":"<p>La seconda strategia possibile \u00e8 quella di consentire il verificarsi dello stallo, rilevarlo e risolverlo. Tale strategia prevede quindi di operare normalmente e verificare periodicamente se si \u00e8 verificato uno stallo.</p> <p>\u00c8 possibile dividerla in due fasi:</p> <ol> <li>rilevare lo stallo;</li> <li>eliminare la situazione di stallo.</li> </ol>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#rilevarlo","title":"Rilevarlo","text":"<p>Avendo a disposizione una sola risorsa di ogni tipo si pu\u00f2 rilevare lo stallo costruendo il grafo di assegnazione delle risorse. Un ciclo all'interno del grafo denota uno stallo. \u00c8 concretamente irragionevole da implementare in quanto molto complesso.</p> <p>Lo si pu\u00f2 applicare solo nei casi di una risorsa per tipologia.</p> <p>Serve quindi una soluzione che funzioni in generale, ovvero anche nei casi in cui si hanno pi\u00f9 risorse per ogni tipologia. Siano dunque:</p> \\[   E = \\ipmatrix{E_1 &amp; E_2 &amp; \\dots &amp; E_m}   \\qquad   A = \\ipmatrix{A_1 &amp; A_2 &amp; \\dots &amp; A_m} \\] \\[   C = \\begin{bmatrix}         C_{11} &amp; C_{12} &amp; \\dots  &amp; C_{1m} \\\\         C_{21} &amp; C_{22} &amp; \\dots  &amp; C_{2m} \\\\         \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\         C_{n1} &amp; C_{n2} &amp; \\dots  &amp; c_{nm}       \\end{bmatrix}   \\qquad   R = \\begin{bmatrix}         R_{11} &amp; R_{12} &amp; \\dots  &amp; R_{1m} \\\\         R_{21} &amp; R_{22} &amp; \\dots  &amp; R_{2m} \\\\         \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\         R_{n1} &amp; R_{n2} &amp; \\dots  &amp; R_{nm}       \\end{bmatrix} \\] <p>dove \\(E\\) sono le risorse esistenti, \\(A\\) sono le risorse disponibili, \\(C\\) \u00e8 la matrice di allocazione corrente e \\(R\\) \u00e8 la matrice delle richieste.</p> <p>Sia \\(r_i\\) l'\\(i\\)-esima riga della matrice \\(R\\). Dati due vettori \\(X = [\\oneton[m]{x}]\\) e \\(Y = [\\oneton[m]{y}]\\), si dice che:</p> \\[ X \\leq Y \\iff \\forall i \\in [1,\\; m] \\quad x_i \\leq y_i \\] <p>L'algoritmo di individuazione dello stallo opera nel seguente modo:</p> <ol> <li>inizialmente ogni processo \\(P_i\\) non \u00e8 marcato;</li> <li>per ogni processo non marcato \\(P_i \\tc r_i \\leq A\\) (si individuano i    processi che possono ottenere le risorse necessarie alla loro terminazione):<ul> <li>\\(A = A + C_i\\);</li> <li>marca \\(P_i\\) (il processo pu\u00f2 terminare la sua normale esecuzione:   avviene il rilascio delle risorse).</li> </ul> </li> <li>se rimangono processi non marcati:<ul> <li>i processi non marcati sono in stallo (nessuno di loro pu\u00f2 acquisire   risorse sufficienti a terminare, tenendo occupate le risorse gi\u00e0 prese).</li> </ul> </li> </ol> <p>Rilevo dello stallo</p> 1<sup>o</sup> esempio2<sup>o</sup> esempio <p>Siano:</p> \\[ E = \\ipmatrix{4 &amp; 2 &amp; 3 &amp; 1} \\qquad A = \\ipmatrix{2 &amp; 1 &amp; 0 &amp; 0} \\] \\[   C = \\begin{bmatrix}         0 &amp; 0 &amp; 1 &amp; 0 \\\\         2 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 1 &amp; 2 &amp; 0       \\end{bmatrix}   \\qquad   R = \\begin{bmatrix}          2 &amp; 0 &amp; 0 &amp; 1 \\\\         1 &amp; 0 &amp; 1 &amp; 0 \\\\         2 &amp; 1 &amp; 0 &amp; 0       \\end{bmatrix} \\] <p>In questo caso:</p> <ol> <li>viene marcato il processo \\(P_1\\);</li> <li>viene marcato il processo \\(P_2\\);</li> <li>viene marcato il processo \\(P_3\\).</li> </ol> <p>Pertanto i processi non sono in stallo.</p> <p>Siano:</p> \\[    E = \\ipmatrix{2 &amp; 1 &amp; 1 &amp; 2 &amp; 1}    \\qquad   A = \\ipmatrix{0 &amp; 0 &amp; 0 &amp; 0 &amp; 1}  \\] \\[   C = \\begin{bmatrix}         1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\\\         1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0        \\end{bmatrix}   \\qquad   R = \\begin{bmatrix}         0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\         1 &amp; 0 &amp; 1 &amp; 0 &amp; 1       \\end{bmatrix} \\] <p>In questo caso:</p> <ol> <li>viene marcato il processo \\(P_1\\)</li> </ol> \\[    A = A + C_3      = \\ipmatrix{0 &amp; 0 &amp; 0 &amp; 0 &amp; 1} + \\ipmatrix{0 &amp; 0 &amp; 0 &amp; 1 &amp; 0}     = \\ipmatrix{0 &amp; 0 &amp; 0 &amp; 1 &amp; 1} \\] <p>Non vi sono altri indici, dunque processi, per i quali viene soddisfatto \\(r_i \\leq A\\). Pertanto i processi non marcati \\(P_1\\), \\(P_2\\), \\(P_4\\) sono in stallo.</p> <p>Quando e quanto spesso invocare l'algoritmo dipende da:</p> <ul> <li>frequenza presunta con la quale si verifica lo stallo;</li> <li>numero di processi coinvolti nello stallo.</li> </ul> <p>In generale uno stallo si verifica quando un processo avanza una richiesta che non pu\u00f2 essere soddisfatta immediatamente.</p> <p>Utilizzare l'algoritmo a ogni richiesta, consente la determinazione dello stallo e del processo la cui richiesta ha cagionato lo stallo. Vi \u00e8 un aumento notevole del carico (overhead).</p> <p>Invocare l'algoritmo quando la percentuale di utilizzo delle risorse scende al di sotto di una soglia.</p> <p>Invocare l'algoritmo ad istanti arbitrari, nel grafo di assegnazione delle risorse potrebbero esistere molti cicli e diventa difficile determinare quale processo ha \"causato\" lo stallo.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#eliminarlo","title":"Eliminarlo","text":"<p>Si pu\u00f2 operare secondo diverse modalit\u00e0.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#terminazione-dei-processi","title":"Terminazione dei processi","text":"<p>Generalmente si effettua l'abort di tutti i processi coinvolti nello stallo.</p> <p>In alternativa si pu\u00f2 effettuare l'abort di un processo alla volta fino a quando il ciclo non \u00e8 eliminato. Dopo ogni abort si deve rieseguire l'algoritmo di determinazione dello stallo. L'ordine con cui abortire i processi viene dato da una funzione di minimo costo basata su:</p> <ul> <li>priorit\u00e0 dei processi;</li> <li>tempo trascorso in esecuzione e necessario al completamento;</li> <li>risorse gi\u00e0 utilizzate e risorse richieste (processo in fase di stampa, etc);</li> <li>tipo di processo (interattivo, ecc.).</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#prelazione-di-risorse","title":"Prelazione di risorse","text":"<p>Si seleziona un processo vittima che minimizzi i costi e viene effettuato il rollback del processo a cui \u00e8 stata sottratta la risorsa, ovvvero si effettua un return a uno stato sicuro per poterlo riavviare in seguito. Per questo motivo vi \u00e8 un salvataggio periodico dello stato dei processi. In caso di stallo:</p> <ul> <li>si ripristina il processo all'ultimo stato salvato;</li> <li>si fa ripartire il processo, il non-determinismo dei processi concorrenti   dovrebbe garantire il non ri-verificarsi dello stallo.</li> </ul> <p>In generale conviene uccidere il processo</p> <p>Si pu\u00f2 andare incontro a starvation: alcuni processi potrebbero essere selezionati costantemente come vittime, include number of rollback in cost factor.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#evitarlo-con-politiche-di-allocazione","title":"Evitarlo con politiche di allocazione","text":"<p>La strategia di evitare lo stallo mediante politiche di allocazione prevede di definire un ordine di assegnazione delle risorse tale che non si verifichi mai uno stallo.</p> <p>Un esempio grafico \u00e8 il seguente:</p> <p>TODO: aggiungere immagine.</p> <p>Sugli assi sono riportate le istruzioni che devono essere eseguite, sull'ascissa per il processo \\(A\\) e sull'ordinata per il processo \\(B\\). Sono presenti due risorse: printer e plotter, le quali sono usate dai processi nelle istruzioni indicate con la freccia a punta doppia. Le aree sbarrate non sono percorribili, in quanto si avrebbe la stessa risorsa assegnata a due processi</p> <p>Qual \u00e8 l'ordine giusto per evitare lo stallo?</p> <p>Con ordine di esecuzione \\(I_1 \\to I_5\\) si arriva allo stallo, in quanto non vi sono percorsi percorribili:</p> <ul> <li>printer \u00e8 assegnato ad \\(A\\), plotter a \\(B\\);</li> <li>per proseguire, \\(A\\) necessita del plotter;</li> <li>per proseguire, \\(B\\) necessita del printer.</li> </ul> <p>Con ordine di esecuzione \\(I_1\\to I_2\\to I_3\\to I_4\\to I_5\\to I_6\\to I_7\\to I_8\\) non si verifica stallo.</p> <p>I vantaggi di questa politica \u00e8 che non \u00e8 necessario interrompere processi e riportarli in uno stato precedente, il che era un problema presente nelle strategie di rilevamento dello stallo.</p> <p>Le restrizioni sono per\u00f2 le seguenti:</p> <ul> <li>il numero massimo di risorse necessitate da ogni processo deve essere noto a   priori (prima dell'esecuzione);</li> <li>i processi devono essere indipendenti: l'ordine di esecuzione non deve essere   vincolato a esigenze di sincronizzazione;</li> <li>deve esserci un numero fissato di risorse da allocare</li> <li>quando un processo richiede risorse potrebbe essere posto in attesa</li> <li>quando un processo ottiene tutte le risorse di cui necessita, deve rilasciarle   in un tempo finito.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#stato-sicuro-e-insicuro","title":"Stato sicuro e insicuro","text":"<p>Si possono pertanto definire due stati del sistema, rispetto alle risorse assegnate:</p> <ul> <li>sicuro: esiste almeno una sequenza di esecuzione dei processi che ne consente   la terminazione senza incorrere in una situazione di stallo;</li> <li>insicuro.</li> </ul> <p>Lo stato sicuro garantisce l'impossibilit\u00e0 di verificarsi dello stallo. Quello insicuro indica che vi \u00e8 possibilit\u00e0 (non certezza) che si verifichi lo stallo.</p> <p>La strategia di evitare lo stallo si basa sulla certezza che uno stato sicuro non possa determinare uno stallo.</p> <p>Deadlock avoidance</p> <p>Assicurarsi che il sistema non entri mai in uno stato non sicuro.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#algoritmo-del-banchiere","title":"Algoritmo del banchiere","text":"<p>La strategia di evitare lo stallo mediante politiche di allocazione vede la sua applicazione pratica nell'algoritmo del banchiere. Questo assegna risorse al processo solo se il sistema resta in uno stato sicuro: i processi procedono, terminano e restituiscono le risorse al sistema.</p> <p>Lo stato sicuro viene determinato utilizzando l'algoritmo di rilevazione dello stallo. Tale strategia prende il nome dal comportamento del banchiere: nessun banchiere presterebbe dei soldi senza avere certezze che questi tornino a s\u00e9. Il principio \u00e8 attuato utilizzando le risorse come se fossero il denaro.</p> <p>Segue una bozza in C/pseudocodice dell'algoritmo del banchiere:</p> Strutture dati globali<pre><code>struct state {\nint resource[m];\nint available[m];\nint claim[n][m];\nint alloc[n][m];\n}\n</code></pre> Algoritmo di allocazione risorse<pre><code>if (alloc[i][*] + request[*] &gt; claim[i][*]) {\n// &lt;error&gt;\n} else if (requests[*] &gt; available[*]) {\n// &lt;suspend-process&gt;\n} else {\n// &lt;define-new-state&gt;\nalloc[i][*] = alloc[i][*] + request[*];\navailable[*] = available[*] + request[*];\n}\nif (safe(newstate)) {\n// &lt;carry-on-allocation&gt;\n} else {\n// &lt;restore-original-state&gt;\n// &lt;suspend-process&gt;\n}\n</code></pre> Algoritmo per test della sicurezza<pre><code>boolean safe(state S) {\nint currentavail[m];\nprocess rest[number_of_processes];\ncurrentavail = available;\nrest = {all_processes};\npossible = true;\nwhile (possible) {\n// find a process Pk in rest sush that\nclaim[k][*] - alloc[k][*] &lt;= currentavail;\nif (found) { // simulate execution of Pk\ncurrentavail = currentavail + alloc[k][*];\nrest = rest - {Pk};\n} else {\npossible = false;\n}\nreturn (rest == null);\n}\n}\n</code></pre>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#impedirlo-rimuovendone-le-condizioni","title":"Impedirlo rimuovendone le condizioni","text":"<p>\u00c8 possibile impedire il verificarsi dello stallo rimuovendo una delle quattro condizioni. Si impongono pertanto dei vincoli sulla richiesta delle risorse. Le classi di prevenzione sono:</p> <ul> <li>metodi indiretti: prevengono il verificarsi di una delle tre condizioni   necessarie;</li> <li>metodi diretti: prevengono il verificarsi dell'attesa circolare.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#negare-la-mutua-esclusione","title":"Negare la mutua esclusione","text":"<p>In questo caso, un processo non deve mai attendere una risorsa condivisibile, devono essere possibili degli accessi multipli contemporanei alle risorse condivise. Questa soluzione non \u00e8 generalmente applicabile.</p> <p>\u00c8 applicabile in alcuni casi specifici: alcuni dispositivi (es. stampanti) possono essere gestiti con spool:</p> <ul> <li>i processi scrivono l'output in un'area di spool;</li> <li>solo il gestore della stampante richiede e usa la stampante;</li> <li>quindi lo stallo per la stampante \u00e8 eliminabile;</li> </ul> <p>Non tutti i dispositivi possono essere per\u00f2 gestiti con spool e vi pu\u00f2 comunque essere stallo nell'accesso all'area di spool.</p> <p>Principio:</p> <ul> <li>evitare di assegnare una risorsa quando non strettamente necessario;</li> <li>Far in modo che il minor numero possibile di processi possa richiedere una   risorsa.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#negare-lhold-and-wait","title":"Negare l'hold and wait","text":"<p>In questo caso ogni processo deve richiedere all'inizio della sua esecuzione tutte le risorse. I problemi sono i seguenti:</p> <ul> <li>il processo potrebbe non sapere di quali risorse avr\u00e0 bisogno;</li> <li>il processo entra in Blocked fino a quando tutte le richieste non vengono   soddisfatte contemporaneamente.</li> <li>vincola risorse che altri processi potrebbero utilizzare</li> </ul> <p>Questo approccio \u00e8 inefficiente, poich\u00e9:</p> <ul> <li>prima di andare in run tutte le risorse devono essere disponibili, in realt\u00e0   potrebbe procedere utilizzandone solo una parte;</li> <li>le risorse assegnate al processo potrebbero rimanere inutilizzate per molto   tempo, gli altri processi sono in attesa indefinita.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#negare-lassenza-di-prerilascio","title":"Negare l'assenza di prerilascio","text":"<p>In questo caso vi sono due possibilit\u00e0:</p> <ol> <li>un processo che non riesce ad ottenere le risorse di cui necessita, rilascia   quelle che detiene per richiederle nuovamente in un istante successivo;</li> <li>il sistema operativo pu\u00f2 richiedere il pre-rilascio delle risorse al processo   che le detiene per assegnarle al richiedente.</li> </ol> <p>L'approccio \u00e8 applicabile solo se lo stato della risorsa \u00e8 facilmente salvabile (CPU), non \u00e8 applicabile nel caso di stampanti, etc.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#negare-lattesa-circolare","title":"Negare l'attesa circolare","text":"<p>Si definisce un ordine lineare (di numerazione) per tutte le risorse, Se un processo richiede una risorsa \\(R\\), successivamente potr\u00e0 richiedere solo una risorsa che nell'ordinamento segue \\(R\\).</p> <p>Esempio</p> <p>\\(R_i\\) precede \\(R_j\\) se \\(i &lt; j\\), un processo potr\u00e0 chiedere le risorse solo nell'ordine \\(R_i\\), \\(R_j\\).</p> <p>Questo metodo pu\u00f2 essere inefficiente.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#concorrenza","title":"Concorrenza","text":"<p>Con multiprogrammazione si intende la gestione di pi\u00f9 processi su un singolo processore, mentre con multiprocessing si intende la gestione di pi\u00f9 processi su pi\u00f9 processori. I processi distribuiti prendono il nome di cluster.</p> <p>Vi \u00e8 competizione tra i processi/threads per ottenere e condividere le risorse: CPU, Memoria, Canali di I/O, Files, etc.</p> <p>Terminologia</p> <code>Sessione critica</code> Porzione di codice all'interno di un processo/thread che richiede accesso a risorse condivise. <code>Deadlock</code> Situazione nella quale due o pi\u00f9 processi sono impossibilitati dal  procedere poich\u00e9 sono in attesa l'uno dell'altro. <code>Livelock</code> Situazione nella quale due o pi\u00f9 processi cambiano continuamente il  proprio stato a causa del cambiamento di stato degli altri, senza fare  alcun lavoro utile. <code>Mutua esclusione</code> Requisito per il quale, quando un processo \u00e8 nella propria sezione  critica, nessun altro processo pu\u00f2 essere nella propria sezione critica  se questa fa riferimento a risorse condivise con il primo processo. <code>Race condition</code> Situazione nella quale thread o processi leggono e scrivono un dato  condiviso e il risultato dipende dalla loro velocit\u00e0 reciproca. <code>Starvation</code> Situazione nella quale un processo non riceve mai l'utilizzo di una  risorsa e viene costantemente scavalcato da altri processi. <p>I vantaggi della concorrenza sono i seguenti:</p> <ul> <li>benefici sull'esecuzione nonostante il sovraccarico dovuto dal context   switching;</li> <li>migliore utilizzo delle risorse.</li> </ul> <p>I problemi su singolo processore sono:</p> <ul> <li>condivisione pericolosa: ordine delle operazioni di lettura e scrittura su   aree di memoria condivise;</li> <li>difficolt\u00e0 nell'assegnare le risorse ai processi in maniera ottimale;</li> <li>difficolt\u00e0 nella rilevazione degli errori nel codice e dei conflitti di   interlacciamento.</li> </ul> C<pre><code>char in, out; // condivise\nvoid echo() {\nscanf(\"%c\", &amp;in);\nout = in;\nprintf(\"%c\", out);\n}\n</code></pre> <p>La procedura <code>echo()</code> \u00e8 condivisa, in questo modo c'\u00e8 risparmio dello spazio di memoria ma anche due processi concorrenti.</p> <ul> <li>\\(P_1\\) viene interrotto dopo la <code>scanf()</code>;</li> <li>\\(P_2\\) esegue tutto <code>echo()</code>;</li> <li>\\(P_1\\) viene riattivato da <code>scanf()</code> in poi e ha perso il dato che aveva   letto.</li> </ul> <p>La soluzione sta nell'avviare un solo processo alla volta (mutua esclusione).</p> <p>I problemi in caso di SMP invece sono:</p> <ul> <li>stessi problemi di un calcolatore a singolo processore, una interruzione pu\u00f2   fermare l'esecuzione di un processo in un qualsiasi istante;</li> <li>interlacciamento esecuzione processi paralleli.</li> </ul> Processo \\(P_1\\), Processore 1Processo \\(P_2\\), Processore 2 C<pre><code>// ...\nscanf(\"%c\", &amp;in);\n// ...\nout = in;\nprintf(\"&amp;c\", out);\n// ...\n</code></pre> C<pre><code>// ...  \n// ...\nscanf(\"%c\", &amp;in);\nout = in;\n// ...\nprintf(\"&amp;c\", out);\n</code></pre> <p>Il carattere letto da \\(P_1\\) \u00e8 perso prima di poter essere stampato, questo \u00e8 dovuto alla perdita di aggiornamento. La soluzione \u00e8 nuovamente la mutua esclusione.</p> <p>Un solo programma per volta pu\u00f2 entrare nella propria sezione critica (es. un solo programma per volta pu\u00f2 inviare comandi alla stampante).</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#mutua-esclusione","title":"Mutua esclusione","text":"<p>I meccanismi che provvedono alla mutua esclusione devono garantire i seguenti requisiti:</p> <ul> <li>un solo processo alla volta deve accedere alla sezione (o risorsa) critica;</li> <li>un processo fuori della sezione critica non deve interferire con il processo   nella sezione critica;</li> <li>ogni processo deve poter accedere dopo un tempo finito di attesa in coda alla   risorsa critica (no stallo o starvation);</li> <li>se nessun processo \u00e8 nella sezione critica, un processo deve poter entrare   nella sezione critica senza attese;</li> <li>non ci devono essere supposizioni sulla velocit\u00e0 di esecuzione relativa dei   processi;</li> <li>il tempo di permanenza nella sezione critica \u00e8 (de)finito.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#approcci-software","title":"Approcci software","text":"<p>I processi, senza ausilio del sistema operativo o del linguaggio di programmazione, devono coordinarsi tra loro (Dekker). Questo porta ad un aumento del tempo di esecuzione e a errori frequenti.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#algoritmo-di-dekker","title":"Algoritmo di Dekker","text":""},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#primo-tentativo","title":"Primo tentativo","text":"<p>Protocollo dell'Igloo: prima di entrare nella sezione critica, i processi controllano uno alla volta una variabile turno. Questo provoca il busy wait (attesa attiva) che consuma tempo utile di esecuzione.</p> Processo \\(0\\)Processo \\(1\\) Dekker \u2013 v1<pre><code>var turno = 0..1;  // variabile globale condivisa\n// ...\nwhile (turno != 0) {\nnulla;  // busy wait\n}\n// !!sezione-critica!!\nturno = 1;\n// ...\n</code></pre> Dekker \u2013 v1<pre><code>var turno = 0..1;  // variabile globale condivisa\n// ...\nwhile (turno != 1) {\nnulla;  // busy wait\n}\n// !!sezione-critica!!\nturno = 1;\n// ...\n</code></pre> <p>Il pro \u00e8 che garantisce la mutua esclusione. I punti deboli per\u00f2 sono i seguenti:</p> <ol> <li>i processi devono osservare l'alternanza, il pi\u00f9 lento determina la velocit\u00e0    di avanzamento di entrambi i processi;</li> <li>se un processo fallisce nella propria sezione critica e non, l'altro processo    rimarr\u00e0 bloccato per sempre.</li> </ol>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#secondo-tentativo","title":"Secondo tentativo","text":"<p>Ogni processo ha un flag relativo all'utilizzo della risorsa e pu\u00f2 leggere il flag dell'altro senza modificarlo.</p> Processo \\(0\\)Processo \\(1\\) Dekker \u2013 v2<pre><code>boolean flag[2];  // variabile condivisa\n//  ...\nwhile (flag[1]) {\nnulla;\n}\nflag[0] = true;\n// !!sezione-critica!!\nflag[0] = false;\n// ...\n</code></pre> Dekker \u2013 v2<pre><code>boolean flag[2];  // variabile condivisa\n//  ...\nwhile (flag[0]) {\nnulla;\n}\nflag[1] = true;\n// !!sezione-critica!!\nflag[1] = false;\n// ...\n</code></pre> <p>Il pro \u00e8 che s\u00e8un processo fallisce al di fuori della sua sezione critica, l'altro pu\u00f2 continuare a lavorare. I contro sono i seguenti:</p> <ul> <li>se un processo fallisce entro la sezione critica o prima di mettere <code>false</code>   nel suo flag allora l'altro \u00e8 bloccato per sempre;</li> <li>se entrambi vedendo il flag dell'altro <code>false</code>, mettono il loro flag a   <code>true</code>, entrambi vanno nella sezione critica, senza mutua esclusione.   Vi \u00e8 dipendenza della velocit\u00e0 dei processi.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#terzo-tentativo","title":"Terzo tentativo","text":"Processo \\(0\\)Processo \\(1\\) Dekker \u2013 v3<pre><code>boolean flag[2];\n// ...\n// la volont\u00e0 di entrare in **sezione critica** viene\n// espressa prima della stessa\nflag[0] = true;\nwhile (flag[1]) {\nnulla\n}\n// !!sezione-critica!!\nflag[0] = false;\n// ...\n</code></pre> Dekker \u2013 v3<pre><code>boolean flag[2];\n// ...\n// la volont\u00e0 di entrare in **sezione critica** viene\n// espressa prima della stessa\nflag[1] = true;\nwhile (flag[0]) {\nnulla\n}\n// !!sezione-critica!!\nflag[1] = false;\n// ...\n</code></pre> <p>Il pro \u00e8 che la mutua esclusione \u00e8 garantita. Vi sono per\u00f2 dei problemi:</p> <ul> <li>se un processo fallisce entro la sua sezione critica l'altro \u00e8 bloccato;</li> <li>se entrambi settano il flag a true prima che uno dei due verifichi la   condizione del <code>while</code> si ha stallo.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#quarto-tentativo","title":"Quarto tentativo","text":"Processo \\(0\\)Processo \\(1\\) Dekker \u2013 v4<pre><code>// ...\nflag[0] = true;\nwhile (flag[1]) {\nflag[0] = false;\npausa;\nflag[0] = true;\n}\n// sezione critica\nflag[0] = false;\n// ...\n</code></pre> Dekker \u2013 v4<pre><code>// ...\nflag[1] = true;\nwhile (flag[0]) {\nflag[1] = false;\npausa;\nflag[1] = true;\n}\n// sezione critica\nflag[1] = false;\n// ...\n</code></pre> <p>Anche in questo caso la mutua esclusione viene garantita. I problemi sono i seguenti:</p> <ul> <li>si pu\u00f2 avere una situazione nella quale i due processi cambiano   contemporaneamente le flag, generando attesa. In realt\u00e0 non'\u00e8 uno stallo   poich\u00e9 chi esce prima dal ciclo di attesa riesce ad entrare nella sezione   critica;</li> <li>se un processo fallisce entro la sua sezione critica l'altro \u00e8 bloccato.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#soluzione-corretta","title":"Soluzione corretta","text":"<p>Ogni processo ha una propria variabile <code>flag</code> che indica se vuole andare nella sezione critica o meno. La variabile <code>turno</code> specifica chi ha il diritto di insistere nel tentativo di entrare nella propria sezione critica.</p> <p>Es.: P0 vuole entrare (pone il suo flag a true) P0 controlla il flag di P1 se falso entra nella sezione critica se vero controlla il turno se turno \u00e8 0 (il suo) continua a controllare periodicamente il flag di P1 se turno \u00e8 1 pone il suo flag a falso lasciando il passo a P1</p> ALGORITMO DI DEKKER<pre><code>boolean flag[2];\nint turno;\nvoid main() {\nflag[0] = false;\nflag[1] = false;\nturno = 1;\n// turno = 0;\n// ...\nprocesso(0);\nprocesso(1);\n// ...\n}\nvoid processo(num) {\nif (num == 0) {\ni = 0;\nj = 1;\n}\nif (num == 1) {\ni = 1;\nj = 0;\n}\n// ...\nflag[i] = true;\nwhile (flag[j]) {\nif (turno == 1) {\nflag[j] = false;\nwhile (turno == 1) {\nnulla; // ATTESA ATTIVA\n}\nflag[i] = true;\n}\n}\n// !!sezione-critica!!\nflag[i] = false;\n// ...\n}\n</code></pre> <p>L'algoritmo \u00e8 complesso e genera attesa attiva: un processo controlla continuamente il flag dell'altro processo se pari a <code>true</code>.</p> <p>Se un processo fallisce nella propria sezione critica l'altro processo rimane bloccato.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#supporti-hardware","title":"Supporti hardware","text":"<p>L'utilizzo di particolari istruzioni macchina permette una riduzione del sovraccarico, nonostante non sia una soluzione del tutto soddisfacente.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#macchine-monoprocessore","title":"Macchine monoprocessore","text":"<p>I processi si alternano in esecuzione e la mutua esclusione si ottiene evitando l'interruzione di un processo attivando e disattivando gli interrupt, \u00e8 proprio qui che \u00e8 presente il supporto hardware.</p> Supporto hardware<pre><code>// &lt;disattiva-le-interruzioni&gt;\n// !!sezione-critica!!\n// &lt;attiva-le-interruzioni&gt;\n</code></pre> <p>Il pro \u00e8 che la mutua esclusione viene garantita, per\u00f2:</p> <ul> <li>l'efficienza peggiora poich\u00e9 il processore non pu\u00f2 alternare i processi   liberamente;</li> <li>non funziona su macchine SMP.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#soluzioni-su-smp","title":"Soluzioni su SMP","text":"<p>Su SMP sono presenti delle istruzioni macchina speciali per l'accesso a locazioni di memoria in modo atomico (non interrompibile), queste sono <code>TestAndSet()</code> e <code>Swap()</code></p> <p>L'accesso sequenziale ad una locazione di memoria \u00e8 garantita dall'hardware. Se si eseguono due test-and-set (o swap) contemporaneamente, le funzioni vengono serializzate.</p> TEST AND SET<pre><code>boolean TestAndSet(boolean *target) {\nboolean val = *target;\n*target = true;\nreturn val;\n}\n</code></pre> <p>Come si utilizza la funzione <code>TestAndSet()</code>? Sia <code>boolean lock</code> una variabile booleana condivisa inizializzata a <code>false</code> (la risorsa \u00e8 libera).</p> C<pre><code>boolean lock = false;\nwhile (true) {\nwhile (TestAndSet(&amp;lock))\nnulla;\n// !!sezione-critica!!\nlock = false; // rilascio\n// ...\n}\n</code></pre> <p>Lo swap permette di scambiare due variabili.</p> SWAP<pre><code>void Swap(boolean *a, boolean *b) {\nboolean temp = *a;\n*a = *b;\n*b = temp:\n}\n</code></pre> <p>Come si usa <code>Swap()</code> per garantire la mutua esclusione? Sia <code>boolean lock</code> una variabile booleana condivisa inizializzata a <code>false</code> (ovvero la risorsa \u00e8 accessibile).</p> C<pre><code>boolean lock = false;\nwhile (true) {\nkey = true;\nwhile (key == true) {\nswap(&amp;lock, &amp;key); // key torna `false`\n}\n// !!sezione-critica!!\nlock = false;\n// ...\n}\n</code></pre> <p>Anche i supporti hardware hanno i loro vantaggi e svantaggi</p> VantaggiSvantaggi <ul> <li>si pu\u00f2 applicare a un qualsiasi numero di processi anche su    multiprocessori a memoria condivisa;</li> <li>si pu\u00f2 usare per gestire pi\u00f9 di una sezione critica, ciascuna con una propria variabile;</li> </ul> <ul> <li>attesa attiva, poich\u00e9 i processi consumano tempo di CPU</li> <li>starvation, poich\u00e9 la scelta di quale processo andr\u00e0 nella sezione    critica \u00e8 arbitraria;</li> <li>stallo.</li> </ul> <p>Esempio di stallo su singolo processore</p> <p>Siano \\(p_0\\) e \\(p_1\\) due processi, con \\(p_0\\) a priorit\u00e0 pi\u00f9 alta di \\(p_1\\). </p> <p>Se \\(p_0\\) \u00e8 in sezione critica, \\(p_1\\) tenter\u00e0 di accedere (o tramite <code>TestAndSet()</code> o <code>Swap()</code>) alla risorsa bloccata da \\(p_0\\) e  nella sua attesa attiva non lascer\u00e0 mai il posto a \\(p_0\\) che ha priorit\u00e0 pi\u00f9 bassa.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#supporto-del-sistema-operativo-o-del-linguaggio-di-programmazione","title":"Supporto del sistema operativo o del linguaggio di programmazione","text":"<p>Le soluzioni offerte dal sistema operativo e dai linguaggi di programmazione sono:</p> <ul> <li>scambio messaggi (Inter ProcessCommunication);</li> <li>semafori;</li> <li>monitor.</li> </ul> <p>Il semaforo pu\u00f2 essere binario, ovvero che gestisce una sola risorsa o contatore, che gestisce un lotto di risorse dello stesso tipo.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#semafori","title":"Semafori","text":"<p>Il semaforo utilizza una variabile booleana o intera su cui sono possibili tre operazioni:</p> <ul> <li>inizializzazione ad un valore non negativo;</li> <li>operazione atomica <code>wait()</code> che decrementa il valore della variabile. Se   il valore della variabile diventa negativa, il processo che ha eseguito la   <code>wait()</code> viene bloccato;</li> <li>operazione atomica <code>signal()</code>che incrementa il valore della variabile. Se   il valore della variabile era negativo, uno dei processi bloccati   sull'operazione di <code>wait()</code> viene sbloccato.</li> </ul>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#implementazione","title":"Implementazione","text":"<ol> <li>si associa un semaforo ad ogni risorsa condivisa;</li> <li>il processo che vuole utilizzare la risorsa effettua una operazione di    <code>wait()</code>;</li> <li>il processo che rilascia la risorsa effettua il <code>signal()</code>;</li> <li>la variabile numerica indica il numero di istanze di una specifica risorsa    condivisa (semaforo contatore);</li> <li>se la variabile \u00e8 negativa, essa rappresenta (presa in valore assoluto) il    numero di processi in attesa.</li> </ol> <p>Le funzioni <code>wait()</code> e <code>signal()</code> nel semaforo binario impostano il valore del semaforo rispettivamente a <code>false</code> e <code>true</code>.</p> C<pre><code>wait(S);\n// !!sezione-critica!!\nsignal(S);\n</code></pre> SEMAFORO CONTATORE<pre><code>typedef struct {\nint istanze;\nstruct processo *P; // lista dei processi in coda\n} semaforo;\nvoid wait(semaforo s) {\ns.istanze--;\nif (s.istanze &lt; 0) {\n// &lt;poni-processo-in-coda&gt;\n// &lt;blocca-questo-processo&gt;  *Running*--&gt;*Blocked*\n}\n}\nvoid signal(semaforo s) : {\ns.istanze++;\nif (s.istanze &lt;= 0) {\n// &lt;rimuovi-un-processo-in-coda&gt;\n// &lt;sveglia-il-processo&gt;  *Blocked*--&gt;*Ready*\n}\n}\n</code></pre> SEMAFORO BINARIO<pre><code>typedef struct {\nboolean val;\nstruct processo *P; // lista dei processi in coda\n} semaforo_bin;\nvoid wait(semaforo_bin s) {\nif (s.val == 1)\ns.val = 0;\nelse {\n// &lt;poni-processo-in-coda-a-P&gt;\n// &lt;blocca-questo-processo&gt;: *Running*--&gt;*Blocked*\n}\n}\nvoid signal(semaforo_bin s) {\nif (*P == NULL) // coda vuota\ns.val = 1;\nelse {\n// &lt;rimuovi-un processo-in-coda&gt;\n// &lt;sveglia-il-processo&gt;: *Blocked*--&gt;*Ready*\n}\n}\n</code></pre> <p>Il semaforo binario \u00e8 un semaforo il cui valore intero pu\u00f2 essere solo <code>0</code> o <code>1</code>. La gestione \u00e8 pi\u00f9 complessa che non con semafori contatore.</p> <p>Come fare affinch\u00e9 le operazioni <code>signal()</code> e <code>wait()</code> siano atomiche?</p> <ol> <li>implementarle in hardware o firmware;</li> <li>Dekker o Peterson, si genera per\u00f2 sovraccarico di elaborazione;</li> <li>utilizzo dell'istruzione atomica <code>TestAndSet()</code>;</li> <li>se il sistema \u00e8 monoprocessore basta disabilitare gli interrupt durante le    operazioni;</li> </ol> <p>I semafori non presentano attesa attiva in quanto i processi in coda vengono bloccati. Se un processo fallisce nella sezione critica, il semaforo si occupa di dare comunque il signal della risorsa.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#deadlock-e-starvation","title":"Deadlock e starvation","text":"<p>Siano \\(S\\) e \\(Q\\) due semafori inizializzati a \\(1\\), si avr\u00e0:</p> Processo \\(0\\)Processo \\(1\\) C<pre><code>wait(S);\nwait(Q);\n// ...\nsignal(S);\nsignal(Q);\n</code></pre> C<pre><code>wait(Q);\nwait(S);\n// ...\nsignal(Q);\nsignal(S);\n</code></pre> <p>Il processo \\(p_1\\) non rilascia \\(Q\\) fin quando non ottiene \\(S\\), \\(p_0\\) invece non rilascia \\(S\\) fino a quando non ottiene \\(Q\\). Le operazioni di <code>signal()</code> non verranno eseguite e si va in stallo.</p>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#produttore-e-consumatore","title":"Produttore e consumatore","text":"<p>Tipica rappresentazione dei processi concorrenti:</p> <ul> <li>uno o pi\u00f9 produttori generano dati inserendoli in un buffer</li> <li>un consumatore preleva i dati uno alla volta</li> </ul> ProduttoreConsumatore C<pre><code>/* &lt;produce-dato&gt; */ {\nbuffer[in] = dato;\nin++;\n}\n</code></pre> C<pre><code>while (in &gt;= out) {\nw = buffer[out];\nout++;\n// &lt;consuma-w&gt;\n}\n</code></pre> <p>Vi \u00e8 l'ipotesi che il buffer sia infinito: l'accesso al buffer tra produttore e consumatore deve essere mutuamente esclusivo</p> Produttore e Consumatore (semafori binari)<pre><code>int n;                      // numero di elementi nel buffer\nbinary_semaphore s = 1;     // gestisce l'accesso al buffer\nbynary_semaphore delay = 0; // gestisce il caso di nessun elemento nel buffer\nvoid producer() {\nwhile (true) {\nproduce();\nsemWaitB(s);\n// Essendo il buffer infinito, il produttore pu\u00f2 inserire tutto\n// quello che produce\nappend();\nn++;\n// Se n == 1, significa che il buffer prima era vuoto ed occorre\n// avvisare il consumator\nif (n == 1) {\nsemSignalB(delay);\n}\nsemSignalB(s);\n}\n}\nvoid consumer() {\nint m; // variabile locale\n// Si pone in attesa che il primo elemento\n// venga prodotto\nsemWaitB(delay);\nwhile (true) {\nsemWaitB(S);\ntake();\nn--;\nsemSignalB(s);\nconsume();\n// Se il consumatore ha svuotato il buffer, si mette in attesa\n// che venga prodotto un nuovo elemento\nif (n == 0) {\nsemWaitB(delay);\n}\n}\n}\nvoid main() {\nn = 0;\nparbegin(producer, consumer);\n}\n</code></pre> Produttore e Consumatore (semafori contatore)<pre><code>semaphore n = 0;\nsemaphore s = 0;\nvoid producer() {\nwhile (true) {\nproduce();\nsemWaitB(s);\nappend();\nsemSignalB(s); // Il loro ordine di chiamata\nsemSignalB(n); // \u00e8 indifferente\n}\n}\nvoid consumer() {\nwhile (true) {\n// Qui l'ordine \u00e8 invece importante. Il consumatore entrerebbe in\n// sezione critica quando il buffer \u00e8 vuoto e nessun produttore\n// potrebbe aggiungere elementi: STALLO\nsemSignalB(n);\nsemSignalB(s);\ntake();\nsemSignalB(s);\nconsume();\n}\n}\nvoid main() { parbegin(producer, consumer); }\n</code></pre>"},{"location":"Anno_I/AESO/SO3_gestione_risorse_problemi/#monitor","title":"Monitor","text":"<p>I semafori sono primitive potenti per gestire la mutua esclusione, ma la scrittura di un programma con l'utilizzo dei semafori pu\u00f2 essere tutt'altro che semplice. Per questo esistono i monitor, che sono un costrutto di sincronizzazione di alto livello.</p> <p>\u00c8 un modulo software le cui caratteristiche principali sono:</p> <ul> <li>variabili locali accessibili solo dalle procedure (metodi) definite al suo   interno e non da procedure esterne;</li> <li>un processo entra nel monitor chiamando le sue procedure</li> <li>un solo processo alla volta pu\u00f2 essere in esecuzione all'interno del monitor.   Gli altri processi sono sospesi nell'attesa che il monitor diventi disponibile</li> </ul> <p>Vengono utilizzati per garantire la mutua esclusione e per la protezione delle strutture dati condivise.</p> <p>La sincronizzazione avviene tramite dell variabili di condizione. Su tali variabili si opera mediante due funzioni:</p> <ul> <li><code>cwait(c)</code>, che sospende l'esecuzione del processo chiamante sulla   condizione <code>c</code>;</li> <li><code>csignal(c)</code>, che riattiva un processo sospeso sulla condizione <code>c</code>.</li> </ul> <p>Nota Bene</p> <p>Se non c'\u00e8 nessun processo in attesa su tale condizione il segnale viene perso.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/","title":"Gestione della memoria centrale","text":""},{"location":"Anno_I/AESO/SO4_gestione_memoria/#principi-di-base","title":"Principi di base","text":"<p>La gestione della memoria si occupa di allocare la memoria fisica ai processi che ne fanno richiesta. Nessun processo pu\u00f2 diventare attivo prima di avere ottenuto un certo quantitativo di memoria.</p> <p>L'utilizzo globale delle risorse e tutte le altre prestazioni di un calcolatore vengono influenzate dalle prestazioni del modulo di gestione della memoria sia in funzione della sua efficienza nell'allocare memoria, sia per l'influenza che pu\u00f2 avere sullo scheduler.</p> <p>Un buon gestore di memoria in un ambiente multiprogrammato deve garantire la protezione dei dati, impedendo ai processi attivi di sconfinare nello spazio di indirizzamento di altri processi, e permettere allo stesso tempo la loro condivisione affinch\u00e9 i processi cooperanti possano accedere ad aree comuni di memoria.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#allocazione-della-memoria","title":"Allocazione della memoria","text":"<p>I moduli di gestione della memoria si differenziano in base al tipo di allocazione della stessa, che pu\u00f2  essere:</p> ContiguaNon contigua <p>La memoria viene allocata in modo tale che ciascun oggetto occupa un insieme di locazioni i cui indirizzi sono strettamente consecutivi. Esistono vari tipi di allocazione contigua:</p> <ul> <li>monoallocazione;</li> <li>partizionamento statico;</li> <li>partizionamento dinamico;</li> <li>segmentazione.</li> </ul> <p>La memoria viene allocata in modo tale che un unico oggetto logico viene posto  in aree separate e non adiacenti. Durante l'esecuzione di un processo viene eseguita la traduzione degli indirizzi per ristabilire la corrispondenza tra lo spazio virtuale di indirizzamento (contiguo) e gli indirizzi fisici. Le tipologie afferenti sono:</p> <ul> <li>paginazione;</li> <li>memoria virtuale.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#monoallocazione","title":"Monoallocazione","text":""},{"location":"Anno_I/AESO/SO4_gestione_memoria/#monitor-monoprocesso","title":"Monitor Monoprocesso","text":"<p>\u00c8 lo schema pi\u00f9 semplice per la gestione della memoria che viene suddivisa in due aree contigue:</p> <ul> <li>la prima allocata permanentemente ad una porzione residente del sistema   operativo (Monitor);</li> <li>la seconda assegnata ai processi in esecuzione, processi utente o porzioni   non residenti del sistema operativo, per il tempo necessario al completamento.</li> </ul> <p>Questo schema viene generalmente utilizzato da sistemi operativi monoprocesso per microcomputer.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#modalita-dello-schema","title":"Modalit\u00e0 dello schema","text":"<p>Il sistema operativo:</p> <ul> <li>tiene traccia solo della prima e dell'ultima locazione disponibile per i   processi transienti;</li> <li>viene posto ad uno dei due estremi della memoria;</li> <li>ingloba i vettori di interrupt;</li> <li>altri suoi moduli temporanei vengono posti all'altra estremit\u00e0 della memoria.</li> </ul> <p>Alla richiesta di esecuzione di un programma, il sistema operativo:</p> <ul> <li>si assicura che le dimensioni del processo siano compatibili con la memoria   disponibile;</li> <li>conferisce il controllo al processo utente fino al suo completamento o ad   eventuali condizioni di errore;</li> <li>al termine del processo la memoria viene liberata e pu\u00f2 essere assegnata ad   un altro processo in attesa.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-protezione","title":"Meccanismi di protezione","text":"<p>Raramente un monitor monoprocesso supporta meccanismi di protezione tra processi utente in quanto in ogni istante vi pu\u00f2 essere al massimo un solo processo residente in memoria. Gli eventuali meccanismi si riferiscono alla protezione del codice del sistema operativo da eventuali sconfinamenti del processo transiente in esecuzione.</p> <p>La protezione del sistema operativo dai processi utente \u00e8 spesso effettuata mediante supporti hardware come:</p> <ul> <li>registri barriera;</li> <li>diritti di accesso mediante bit di protezione;</li> <li>sistema operativo in memoria a sola lettura.</li> </ul> <p>I registri barriera sono usati per tracciare un confine tra le aree dei processi di sistema e dei processi transienti. Nel registro viene memorizzata la prima locazione disponibile al processo e il sistema operativo effettua i controlli di sconfinamento. Questo metodo richiede la capacit\u00e0 di distinguere l'esecuzione del sistema operativo da quella dei processi utente definendo gli stati \"utente\" e \"supervisore\".</p> <p>Un altro metodo per proteggere la memoria consiste nel memorizzare i diritti di accesso, mediante bit di protezione, nella memoria stessa. Ad ogni parola di memoria viene associato un bit di protezione che viene posto a \\(1\\) nelle zone che contengono il sistema operativo e a \\(0\\) nelle restanti. I processi utente accedono solo a parole con bit \\(0\\), mentre il sistema operativo ha accesso illimitato.</p> <p>Un modo semplice e diffuso per proteggere il codice del sistema operativo dai programmi utente consiste nel porre il sistema operativo in memoria a sola lettura. Nelle applicazioni generiche, come i personal computer, questo metodo non \u00e8 solitamente utilizzato per la sua scarsa flessibilit\u00e0 e impossibilit\u00e0 di correggere o aggiornare il codice del sistema operativo.</p> <p>La condivisione del codice e dei dati in memoria non ha molto senso negli ambienti monoprocesso e raramente viene supportata dai relativi monitor. I programmi utente potrebbero passarsi dei dati, mediante accordi interni, ponendoli in locazioni di memoria che non vengono sovrascritte durante l'esecuzione di processi partecipanti, o mediante file.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#prestazioni","title":"Prestazioni","text":"<p>Difetti:</p> <ul> <li>la mancanza di supporti per la multi-programmazione produce un abbassamento   dell'efficienza sia della memoria che della CPU;</li> <li>la memoria pu\u00f2 risultare sovradimensionata per la maggioranza dei processi</li> <li>processi di dimensione pi\u00f9 grande della memoria non possono essere eseguiti,   oppure richiedono particolari suddivisioni del codice (overlay);</li> <li>i programmi tendono ad essere ottimizzati rispetto alla dimensione, comportando   spesso sacrifici di funzionalit\u00e0 e velocit\u00e0.</li> </ul> <p>Pregi:</p> <ul> <li>basso costo di progettazione del modulo di gestione della memoria;</li> <li>contenuti supporti hardware specifici per la gestione della memoria.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#partizionamento-statico","title":"Partizionamento statico","text":"<p>Un modo per supportare la multiprogrammazione consiste nel dividere la memoria in diverse partizioni, ciascuna delle quali pu\u00f2 essere allocata a un processo diverso. Il partizionamento statico implica che la suddivisione della memoria venga fatta \"fuori linea\" e che da quel momento le partizioni rimangano di dimensioni fisse.</p> <p>Il numero e la dimensione di ciascuna partizione vengono determinati durante la generazione del sistema considerando:</p> <ul> <li>capacit\u00e0 della memoria fisica disponibile;</li> <li>grado desiderato di multiprogrammazione;</li> <li>dimensioni dei processi pi\u00f9 frequentemente eseguiti;</li> </ul> <p>Alcuni calcolatori permettono una ridefinizione manuale delle dimensioni delle partizioni senza dover ripetere l'intero processo di generazione del sistema.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#principi-operativi","title":"Principi operativi","text":"<p>Il sistema operativo deve tener traccia delle partizioni definite. Lo stato corrente delle partizioni ed i loro attributi vengono raccolti in una struttura dati chiamata tabella di descrizione delle partizioni (TDP).</p> <p>L'unico campo variabile nella TDP \u00e8 lo stato della partizione che indica in ogni istante se la partizione \u00e8 allocata o no. Gli altri campi contengono valori definiti al momento del partizionamento.</p> \\[   \\begin{array}{ cc }     \\begin{array}{ |c| }\\hline       \\hspace{2.5cm} OS \\hspace{2.5cm} \\\\             \\hline     \\end{array}     &amp; \\text{Sistema operativo} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.65cm} p_1 \\hspace{2.65cm} \\\\ \\\\      \\hline     \\end{array}     &amp; \\text{Processo utente} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{5.8cm} \\\\             \\hline     \\end{array}     &amp; \\text{Partizione libera} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.65cm} p_2 \\hspace{2.65cm} \\\\ \\\\             \\hline     \\end{array}     &amp; \\text{Processo utente} \\\\   \\end{array} \\] <p>TDP dell'esempio precedente:</p> # partizione Base partizione Dimensione partizione Stato partizione 0 0 kB 200 kB Allocata 1 200 kB 400 kB Allocata 2 600 kB 600 kB Libera 3 1200 kB 500 kB Allocata <p>Quando un processo non residente deve essere creato o attivato, il sistema operativo tenta di allocare una partizione di memoria libera di dimensioni sufficienti per contenerlo, consultando la TDP. Se il test \u00e8 positivo, il campo \"stato della partizione\" viene impostato ad \"Allocata\" e l'immagine del processo viene caricata nella corrispondente partizione. Quando il processo termina \u00e8 necessario effettuarne uno swapping dalla memoria. Questa informazione verr\u00e0 utilizzata per localizzare e aggiornare lo stato della partizione associata al valore \"Libera\".</p> <p>I metodi pi\u00f9 comuni per la ricerca di una partizione libera sono:</p> <ul> <li>first fit: consiste nell'allocare la prima partizione libera sufficientemente   larga per contenere il processo;</li> <li>best fit: consiste nell'allocare la pi\u00f9 piccola delle partizioni libere che   contenga il processo.</li> </ul> <p>Il metodo first fit \u00e8 pi\u00f9 veloce in esecuzione poich\u00e9 si arresta nella ricerca, alla prima partizione libera disponibile, mentre il metodo best fit deve controllare, prima di arrestarsi, tutte le partizioni libere disponibili per individuarne la migliore.</p> <p>Il metodo best fit, tuttavia, \u00e8 pi\u00f9 accurato in esecuzione e quindi pu\u00f2 raggiungere un miglior utilizzo della memoria, rispetto al metodo first fit, riducendo al minimo la differenza di dimensione tra il processo e la partizione allocata.</p> <p>Quando il numero delle partizioni \u00e8 molto grande nessuno dei due metodi si rivela particolarmente adatto.</p> <p>Riassumendo, se esiste una partizione allocabile al processo richiedente:</p> <ul> <li>l'allocazione viene effettuata;</li> <li>la TDP viene aggiornata;</li> <li>nel descrittore del processo si registra la partizione associata;</li> <li>quando il processo termina la partizione viene disallocata.</li> </ul> <p>Le cause di mancata disponibilit\u00e0 di una partizione sono:</p> <ol> <li>non vi sono partizioni di memoria sufficientemente grandi per contenere il    processo entrante;</li> <li>tutte le partizioni sono allocate;</li> <li>alcune partizioni sono libere ma nessuna di esse \u00e8 sufficientemente grande.</li> </ol> Caso 1Caso 2Caso 3 <p>Non vi sono partizioni di memoria sufficientemente grandi per contenere il processo entrante. Cause:</p> <ul> <li>errore di scelta della dimensione delle partizioni;</li> <li>Processo eccezionalmente pi\u00f9 grande della norma.</li> </ul> <p>La soluzione sta nel ridefinire la dimensione delle partizioni, oppure  progettare il programma di origine utilizzando uno schema di overlay.</p> <p>Tutte le partizioni sono allocate. Soluzioni:</p> <ul> <li>attesa di una partizione libera;</li> <li>swapping del processo.</li> </ul> <p>Entrambe le soluzioni possono essere anche applicate al caso \\(3\\).</p> <p>Alcune partizioni sono libere ma nessuna di esse \u00e8 sufficientemente grande. In questo caso l'assegnazione di partizioni pu\u00f2 continuare</p> <ul> <li>vengono allocate partizioni a processi pi\u00f9 piccoli;</li> <li>l'utilizzo della memoria viene mantenuto pi\u00f9 elevato;</li> <li>si pu\u00f2 violare l'ordinamento di attivazione dei processi dallo scheduler    modificando, cos\u00ec, le prestazioni del sistema.</li> </ul> <p>Il funzionamento del gestore della memoria e dello scheduler sono strettamente correlati:</p> <ul> <li>lo scheduler determina quali processi sono pronti, e quindi residenti in   memoria, in attesa della CPU;</li> <li>il gestore della memoria pu\u00f2 decidere di \"sfrattare\" un processo in memoria   per liberare una partizione.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#swapping","title":"Swapping","text":"<p>Lo swapping \u00e8 l'operazione di rimozione dalla memoria di un processo sospeso e il suo successivo caricamento. Nel partizionamento statico questo aumenta il livello di occupazione della memoria centrale e, conseguentemente, il livello di utilizzo della CPU.</p> <p>Quando lo scheduler decide l'introduzione in memoria di un nuovo processo il gestore dello swapping ne sceglie uno da rimuovere in base a:</p> <ul> <li>dimensione della partizione richiesta;</li> <li>priorit\u00e0 del processo;</li> <li>tipo di evento atteso dal processo;</li> <li>tempo gi\u00e0 trascorso in memoria.</li> </ul> <p>Un processo residente in memoria, gi\u00e0 parzialmente eseguito, \u00e8 costituito da:</p> <ul> <li>codice eseguibile;</li> <li>dati finora elaborati;</li> <li>stack;</li> <li>registri di stato;</li> <li>file aperti;</li> <li>descrittore del processo.</li> </ul> <p>Al momento dello swapping questi oggetti vengono registrati in un file su hard disk detto file di swapping.</p> <p>Tutti i processi che hanno subito uno swapping possono essere mantenuti:</p> <ul> <li>in un file unico per tutto il sistema</li> <li>in file separati, ciascuno associato ad un singolo processo</li> </ul> <p>Un file di swapping di sistema viene solitamente creato al momento dell'inizializzazione del sistema e collocato su una periferica veloce di memorizzazione secondaria. L'indirizzo e la dimensione di tale file sono solitamente statici in modo da beneficiare di un indirizzamento diretto su disco.</p> <p>Un parametro critico per la realizzazione di un file di swapping \u00e8 la dimensione:</p> <ul> <li>se troppo grande spreca spazio su dischi veloci</li> <li>se troppo piccolo pu\u00f2 rendere indisponibile l'operazione di swapping</li> </ul> <p>L'alternativa \u00e8 disporre di un file di swapping per ciascun processo presente nel sistema che pu\u00f2 essere creato dinamicamente al momento della creazione del processo o staticamente al momento della preparazione del programma.</p> <p>Vantaggi:</p> <ul> <li>eliminazione del problema del dimensionamento del file unico</li> <li>nessuna restrizione sul numero di processi attivi</li> </ul> <p>Svantaggi:</p> <ul> <li>maggior spreco di spazio</li> <li>maggiori tempi di accesso ai file distribuiti sul disco</li> </ul> <p>Uno swapping efficiente richiede che i processi siano rilocabili dinamicamente:</p> <ul> <li>il processo pu\u00f2 iniziare l'esecuzione in qualunque area di memoria</li> <li>pu\u00f2 essere spostato in un'altra area di memoria</li> <li>il calcolo degli indirizzi viene effettuato dinamicamente ad esempio con l'uso   di un registro base.</li> </ul> <p>I processi non rilocabili dinamicamente sono legati alle partizioni in cui iniziano l'esecuzioni e rendono inefficiente lo swapping. In linea di principio lo swapping va utilizzato solo in casi di necessit\u00e0 poich\u00e9 la CPU spreca un tempo elevato nelle operazioni di trasferimento.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-protezione_1","title":"Meccanismi di protezione","text":"<p>L'integrit\u00e0 di un sistema multiprogrammato dipende anche dalla sua capacit\u00e0 di garantire l'isolamento tra spazi di indirizzi separati. Non solo si deve proteggere il sistema operativo dai processi utente ma bisogna anche proteggere i processi utente tra di loro perch\u00e9 nessuno possa invadere lo spazio riservato all'altro.</p> <p>Un sistema di protezione efficace non pu\u00f2 prescindere dall'esistenza di un supporto hardware. Nei sistemi che utilizzano per la rilocazione i registri base, vengono di solito usati dei registri limite per la protezione.</p> <p>Il compito principale di un registro limite consiste nell'individuare i tentativi di accesso oltre i limiti dello spazio di indirizzamento assegnato al programma in esecuzione dal sistema operativo. Il registro limite contiene solitamente il valore dell'indirizzo virtuale pi\u00f9 alto contenuto dal programma.</p> <p>Ad ogni accesso alla memoria la CPU controlla che il programma non richieda indirizzi oltre il limite. Le violazioni vengono rilevate e riferite al sistema operativo che le gestisce. L'indirizzo pi\u00f9 basso del processo \u00e8 contenuto nel registro base.</p> <pre><code>stateDiagram-v2\n  direction LR\n  state registroLimite &lt;&lt;choice&gt;&gt;\n  registroBase: Registro Base\n  violazioneProtezione: Violazione di protezione\n  CPU --&gt; registroLimite\n  registroLimite --&gt; +: \u2264 di registro\\n limite\n  registroLimite --&gt; violazioneProtezione: \u2265 di registro\\n limite\n  registroBase --&gt; +\n  + --&gt; memoria</code></pre>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-condivisione","title":"Meccanismi di condivisione","text":"<p>Un buon sistema di gestione della memoria deve occuparsi, oltre che della protezione, anche della condivisione controllata di dati e codice tra processi cooperanti. I sistemi a partizioni fisse non sono adatti alla condivisione, poich\u00e9 basano i propri meccanismi sull'isolamento degli spazi di indirizzamento.</p> <p>Alcuni possibili metodi di condivisione sono:</p> <ol> <li>affidare gli oggetti condivisi al sistema operativo che cos\u00ec \u00e8 in grado di    accedere a tutte le risorse. Gli svantaggi di questa tecnica sono:<ul> <li>l'area del sistema operativo dovrebbe poter variare dinamicamente;</li> <li>le routine dei processi utente devono poter essere \"linkate\" al sistema operativo   dinamicamente.</li> </ul> </li> <li>ogni processo possiede una copia identica dell'oggetto condiviso, che usa e    diffonde gli aggiornamenti. Lo svantaggio di questa tecnica consiste nel fatto    che se il sistema supporta lo swapping, uno o pi\u00f9 processi potrebbero non    essere in memoria e quindi non esse re pronti a ricevere gli aggiornamenti.</li> <li>collocare i dati in una partizione comune dedicata. In questo caso, per\u00f2, il    sistema operativo considera come violazione i tentativi dei processi    partecipanti alla condivisione di accedere a zone di memoria esterne alle    rispettive partizioni. Se il sistema usa registri base e limite sono necessari    accorgimenti per indirizzare partizioni che potrebbero non essere contigue.</li> </ol>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#conclusioni","title":"Conclusioni","text":"<p>Il partizionamento statico:</p> <ul> <li>\u00e8 uno dei metodi pi\u00f9 semplici di gestione della memoria, pur supportando la   multiprorammazione;</li> <li>richiede un supporto hardware modesto;</li> <li>si adegua ad ambienti statici con carico predicibile di lavoro come ambienti   in cui vengono eseguiti solo applicativi, controllo di processi e sistemi di   tipo bancario.</li> </ul> <p>Svantaggi:</p> <ul> <li>il problema principale \u00e8 la frammentazione interna;</li> <li>pu\u00f2 richiedere progettazione dei programmi con schemi ad overlay;</li> <li>non si adatta a contenere oggetti come stack che possono crescere in maniera   non facilmente controllabile;</li> <li>il numero di partizioni fissato limita il grato di multiprogrammazione.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#partizionamento-dinamico","title":"Partizionamento dinamico","text":"<p>Il sistema delle partizioni \u00e8 analogo a quello del partizionamento statico.</p> <p>Il gestore della memoria crea ed assegna partizioni di dimensione variabile dinamicamente in base alle richieste dei processi. Quando un processo termina o subisce uno swapping, il gestore della memoria restituisce lo spazio liberato all'insieme di aree di memoria libere. Il gestore della memoria pu\u00f2 creare e allocare partizioni finch\u00e9 non viene esaurita la memoria fisica o finch\u00e9 non viene raggiunto il massimo grado di multiprogrammazione.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#principi-operativi_1","title":"Principi operativi","text":"<p>Alla richiesta di una partizione il gestore della memoria (GM) ricerca una zona di memoria libera contigua di dimensione sufficiente. Se si trova un'area adatta il sistema operativo vi ricava una partizione in modo da soddisfare esattamente le necessit\u00e0 del processo.</p> <p>L'eventuale parte rimanente di memoria libera viene restituita all'insieme della memoria libera e posta a disposizione del modulo di allocazione. La partizione viene creata registrando la sua base, la sua dimensione e il suo stato (Allocata) nella TDP o in una tabella equivalente.</p> <p>Alcune di queste informazioni vengono anche registrate nel descrittore di processo. Dopo aver caricato l'immagine del processo nella partizione creata, il processo in oggetto viene sottoposto al controllo di un modulo del sistema operativo che si occupa delle operazioni successive. Quando un processo termina o subisce uno swapping il sistema operativo restituisce la partizione all'area libera e cancella la riga corrispondente nella TDP. L'insieme delle aree libere varia dinamicamente, gli spazi interni all'area libera vengono utilizzati per mantenere una lista a puntatori.</p> <p>Esempio</p> TabellaMemoriaLista aree libere # Base Dimensione Stato 0 0 200 Allocata 1 - - - 2 400 100 Allocata 3 500 250 Allocata 4 750 150 Allocata 5 - - - 6 - - - 7 - - - \\[   \\begin{array}{ c }     \\begin{array}{ |c| }\\hline       \\hspace{2.55cm} OS \\hspace{2.55cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\\\ \\hspace{5.65cm} \\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.65cm} p_1 \\hspace{2.65cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.65cm} p_2 \\hspace{2.65cm} \\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.65cm} p_3 \\hspace{2.65cm} \\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{5.65cm} \\\\ \\hline     \\end{array} \\\\   \\end{array} \\] <pre><code>stateDiagram-v2\n  direction LR\n  a1: 100\n  a1: 300\n\n  a2: 900\n  a2: 100\n\n  [*] --&gt; a1: puntatore alla\\n prima area libera\n  a1 --&gt; a2\n  a2 --&gt; [*]</code></pre> <p>Dopo che viene allocata la partizione \\(1\\):</p> TDPMemoriaLista aree libere # Base Dimensione Stato 0 0 200 Allocata 1 100 120 Allocata 2 400 100 Allocata 3 500 250 Allocata 4 750 150 Allocata 5 - - - 6 - - - 7 - - - \\[   \\begin{array}{ c }     \\begin{array}{ |c| }\\hline       \\hspace{2.5cm} OS \\hspace{2.5cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.65cm} p_4 \\hspace{2.65cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{5.65cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.65cm} p_1 \\hspace{2.65cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.65cm} p_2 \\hspace{2.65cm} \\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.65cm} p_3 \\hspace{2.65cm} \\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{5.65cm} \\\\ \\hline     \\end{array} \\\\   \\end{array} \\] <pre><code>stateDiagram-v2\n  direction LR\n  a1: 220\n  a1: 180\n\n  a2: 900\n  a2: 100\n\n  [*] --&gt; a1: puntatore alla\\n prima area libera\n  a1 --&gt; a2\n  a2 --&gt; [*]</code></pre> <p>Dopo che viene liberata la partizione \\(3\\):</p> TDPMemoriaLista aree libere # Base Dimensione Stato 0 0 200 Allocata 1 100 120 Allocata 2 400 100 Allocata 3 - - - 4 750 150 Allocata 5 - - - 6 - - - 7 - - - \\[   \\begin{array}{ c }     \\begin{array}{ |c| }\\hline       \\hspace{2.55cm} OS \\hspace{2.55cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.65cm} p_4 \\hspace{2.65cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{5.65cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.65cm} p_1 \\hspace{2.65cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{5.65cm} \\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.65cm} p_3 \\hspace{2.65cm} \\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{5.65cm} \\\\ \\hline     \\end{array} \\\\   \\end{array} \\] <pre><code>stateDiagram-v2\n  direction LR\n  a1: 220\n  a1: 180\n\n  a2: 500\n  a2: 250\n\n  a3: 900\n  a3: 100\n\n  [*] --&gt; a1: puntatore alla\\n prima area libera\n  a1 --&gt; a2\n  a2 --&gt; a3 \n  a3 --&gt; [*]</code></pre> <p>Gli algoritmi pi\u00f9 comuni per selezionare un'aria di memoria all'interno della quale creare una partizione sono:</p> <ul> <li>first-fit, termina la ricerca quando viene individuato il primo blocco di   memoria sufficientemente grande da contenere il processo;</li> <li>best-fit, (variante del first-fit) il puntatore alla lista delle aree   libere, dopo avere effettuato un'allocazione, viene salvato cosicch\u00e9 la ricerca   successiva continua da dove si era fermata la precedente;</li> <li>next-fit, alloca il blocco di memoria libero pi\u00f9 piccolo che pu\u00f2 contenere   il processo;</li> <li>worst-fit, al contrario, alloca il blocco di memoria libero pi\u00f9 grande le   cui dimensioni superino quelle della partizione richiesta.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#compattazione","title":"Compattazione","text":"<p>Lo schema di partizionamento dinamico genera, inevitabilmente, \"buchi\" di memoria inutilizzabile. Per questo motivo pu\u00f2 anche diventare impossibile l'allocazione di memoria richiesta da un processo, pur contenendo la memoria globalmente un'area di dimensione sufficiente. Questo fenomeno si chiama frammentazione esterna.</p> <p>Quando la frammentazione raggiunge un grado elevato \u00e8 necessario effettuare la compattazione della memoria che consiste nello spostare i processi residenti in memoria in modo da creare partizioni libere pi\u00f9 grandi. Questa operazione generalmente richiede un grande costo di CPU.</p> <p>La compattazione pu\u00f2 essere effettuata:</p> <ol> <li>Continuamente:<ul> <li>la memoria viene compattata ogni volta che un processo libera un'area;</li> <li>la frammentazione \u00e8 ridotta al minimo;</li> <li>questa operazione ha un grande costo di CPU.</li> </ul> </li> <li>Su necessit\u00e0:<ul> <li>la compattazione viene effettuata quando non si riesce ad allocare memoria   ad un processo richiedente;</li> <li>un controllo preliminare verifica se il totale dell'area liberabile \u00e8   sufficiente a contenere il processo.</li> </ul> </li> </ol> <p>La compattazione pu\u00f2 essere effettuata in due modi:</p> <ol> <li>Spostamento selettivo incrementale:<ul> <li>ricerca di una strategia ottima di movimento per compattare al meglio la   memoria;</li> <li>consente di risparmiare tempo negli spostamenti;</li> <li>Poco utilizzata perch\u00e9 richiede un sovraccarico notevole.</li> </ul> </li> <li>Spostamento globale:<ul> <li>tutte le partizioni vengono rilocate ad uno dei due estremi della memoria;</li> <li>il tempo di trasferimento delle partizioni non \u00e8 ottimizzabile;</li> <li>non richiede strategie particolari.</li> </ul> </li> </ol> MemoriaSpostamento SelettivoSpostamento Globale \\[   \\begin{array}{ c }     \\begin{array}{ |c| }\\hline       \\hspace{2.55cm} OS \\hspace{2.55cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.7cm} P \\hspace{2.7cm}\\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.7cm} Q \\hspace{2.7cm}\\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\\\ \\\\ \\\\ \\hspace{5.8cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.7cm} R \\hspace{2.7cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{5.8cm} \\\\ \\hline     \\end{array} \\\\   \\end{array} \\] \\[   \\begin{array}{ c }     \\begin{array}{ |c| }\\hline       \\hspace{2.55cm} OS \\hspace{2.55cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.7cm} P \\hspace{2.7cm}\\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\hspace{5.8cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.7cm} R \\hspace{2.7cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.7cm} Q \\hspace{2.7cm}\\\\ \\hline     \\end{array} \\\\   \\end{array} \\] \\[   \\begin{array}{ c }     \\begin{array}{ |c| }\\hline       \\hspace{2.55cm} OS \\hspace{2.55cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\hspace{2.7cm} P \\hspace{2.7cm}\\\\ \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.7cm} Q \\hspace{2.7cm}\\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\hspace{2.7cm} R \\hspace{2.7cm} \\\\ \\hline     \\end{array} \\\\ %     \\begin{array}{ |c| }\\hline       \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\hspace{5.8cm} \\\\ \\hline     \\end{array} \\\\   \\end{array} \\]"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-protezione-e-condivisione","title":"Meccanismi di protezione e condivisione","text":"<p>Le tecniche di protezione e condivisione sono analoghe a quelle del partizionamento statico, considerato che il supporto hardware \u00e8 simile. Nel partizionamento dinamico \u00e8 possibile una particolare forma di condivisione:</p> <ul> <li>a due partizioni contigue \u00e8 consentito sovrapporsi, mettendo un'area in comune</li> <li>questa forma di condivisione \u00e8 molto restrittiva, in quanto, pu\u00f2 avvenire solo   tra due processi.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#conclusioni_1","title":"Conclusioni","text":"<p>Il partizionamento dinamico:</p> <ul> <li>richiede un supporto hardware modesto, analogo al partizionamento statico;</li> <li>la differenza tra i due schemi risiede sostanzialmente nel software;</li> <li>elimina la frammentazione interna ma produce quella esterna che pu\u00f2 essere   eliminata con la compattazione;</li> <li>si adegua ad ambienti con carico non predicibile di lavoro come ad esempio   sviluppo di software.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#segmentazione","title":"Segmentazione","text":"<p>La segmentazione \u00e8 uno schema di gestione della memoria che si basa sulla divisione dello spazio di indirizzamento dei processi in entit\u00e0 logiche che possono essere poste in aree non contigue di memoria. La segmentazione fornisce strumenti per la rilocazione dinamica, la protezione e la condivisione.</p> <p>La frammentazione esterna pu\u00f2 essere ridotta se la dimensione delle aree richieste \u00e8 pi\u00f9 piccola. Un programma eseguibile pu\u00f2 essere suddiviso, ad esempio, in codice, dati e stack; ciascuno di questi oggetti pu\u00f2 essere posto in un segmento diverso di dimensioni differenti. La segmentazione condivide alcune propriet\u00e0:</p> <ul> <li>degli schemi di allocazione contigua relativamente ad un singolo segmento,   poich\u00e9 i dati di ogni singola entit\u00e0 logica devono essere posti in un'area   contigua di memoria;</li> <li>degli schemi di allocazione non contigua relativamente all'intero spazio di   indirizzamento del processo, poich\u00e9 blocchi logici diversi possono essere   messi in segmenti non contigui.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#principi-operativi_2","title":"Principi operativi","text":"<ul> <li>La raccolta degli oggetti in segmenti viene predisposta dal programmatore;</li> <li>Ciascun segmento inizia all'indirizzo virtuale zero;</li> <li>Ogni segmento ha un nome che viene poi tradotto in un indirizzo in fase di   caricamento in memoria;</li> <li>Un singolo dato all'interno del segmento viene identificato dallo   \"spiazzamento\" relativo all'inizio del segmento cui appartiene.</li> </ul> <p>L'indirizzamento nella segmentazione \u00e8 di tipo bidimensionale, infatti la designazione univoca di un dato o di una istruzione richiede il nome del segmento e lo spiazzamento all'interno del segmento. La memoria fisica, naturalmente, mantiene l'indirizzamento lineare, per cui \u00e8 necessario un meccanismo per la traduzione degli indirizzi bidimensionali di segmenti virtuali in indirizzi fisici.</p> <p>Il caricamento di un processo segmentato avviene nel seguente modo:</p> <ul> <li>il sistema operativo cerca di allocare \\(n\\) partizioni adatte per gli \\(n\\)   segmenti in cui \u00e8 suddiviso il processo;</li> <li>il sistema operativo crea un descrittore di segmento registrandovi l'indirizzo   fisico in cui \u00e8 stato posto il segmento e la sua dimensione;</li> <li>l'insieme dei descrittori di segmento di un processo viene raccolto nella   tabella dei descrittori di segmento (TDS).</li> </ul> <p>La traduzione di un indirizzo avviene nel seguente modo:</p> <ul> <li>l'indirizzo bidimensionale virtuale I (segment, displacement) \u00e8 tradotto in   modo equivalente al meccanismo del registro base;</li> <li>il segment viene utilizzato per ritrovare l'indirizzo fisico del segmento   nella TDS;</li> <li>il displacement viene sommato all'indirizzo fisico del segmento per ottenere   l'indirizzo fisico richiesto;</li> <li>la dimensione del segmento, riportata nella TDS, viene utilizzata anche per   controllare eventuali violazioni.</li> </ul> <p>Le dimensioni della TDS sono legate alle dimensioni dello spazio virtuale di indirizzamento di un processo. I processori della famiglia Intel, ad esempio, supportano fino a \\(16000\\) segmenti di \\(64 \\KB\\). La TDS pu\u00f2 essere costituita da qualche riga fino a qualche migliaia di righe. Essa viene tenuta in memoria, in uno dei segmenti associati al processo. Due registi hardware, RBTDS e RLTDS, contengono l'indirizzo di inizio e fine della TDS associata al processo in esecuzione. Ci\u00f2 consente anche il controllo d'accesso a segmenti non assegnati al processo.</p> <ul> <li>RBTDS: Registro Base della Tabella dei Descrittori di Segmento</li> <li>RLTDS: Registro Limite della Tabella dei Descrittori di Segmento</li> </ul> <p>La base ed il limite della nuova TDS vengono caricati nei registri RBTDS e RLTDS. Quando un processo subisce uno swapping, al ritorno in memoria va aggiornata la sua TDS. Generalmente si preferisce rigenerarla totalmente utilizzando la mappa statica fornita dal linker. L'eventuale compattazione richiede l'aggiornamento nella TDS delle righe relative ai segmenti spostati.</p> <p>La traduzione di ciascun indirizzo bidimensionale virtuale richiede due accessi in memoria:</p> <ul> <li>uno alla TDS per tradurre l'indirizzo del segmento da virtuale a fisico;</li> <li>l'altro per accedere fisicamente alla locazione richiesta.</li> </ul> <p>La segmentazione, quindi, raddoppia il tempo per l'accesso ad una locazione di memoria.</p> <p>Se i descrittori di segmento sono pochi, o se alcuni sono utilizzati pi\u00f9 frequentemente, conviene specificare il loro caricamento in opportuni registri hardware. I processori della famiglia Intel, ad esempio, dispongono di \\(4\\) registri utilizzabili da schemi di segmentazione:</p> <ul> <li>CS: Code Segment;</li> <li>DS: Data Segment;</li> <li>SS: Stack Segment;</li> <li>ES: Extra Segment.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-protezione_2","title":"Meccanismi di protezione","text":"<p>La forma pi\u00f9 naturale di protezione per un sistema segmentato \u00e8 l'utilizzo di registri base e limite. La protezione tra spazi di indirizzamento di processi differenti \u00e8 garantita dalla collocazione dei segmenti in aree disgiunte di memoria. Una caratteristica offerta dai sistemi segmentati consiste nel fornire un livello di protezione all'interno dello spazio di indirizzamento di un singolo processo. \u00c8 possibile definire diritti e modalit\u00e0 di accesso per ogni \"tipo\" di segmento. \u00c8 possibile definire ad esempio:</p> <ul> <li>accesso in modalit\u00e0 \"execute\" (o anche \"read-only\") al segmento codice;</li> <li>accesso in modalit\u00e0 \"read/write\" al segmento stack;</li> <li>accesso \"read-only\" o \"read/write\" al segmento dati.</li> </ul> <p>I diritti di accesso possono essere registrati in un campo dellaTDS</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-condivisione_1","title":"Meccanismi di condivisione","text":"<p>La segmentazione offe una condivisione semplice e flessibile. Gli oggetti condivisi sono collocati in segmenti dedicati e separati. Il segmento condiviso pu\u00f2 essere mappato, attraverso la TDS, nello spazio di indirizzamento virtuale di tutti i processi autorizzati ad accedervi. Lo spiazzamento interno di un dato risulta identico per tutti i processi che lo condividono.</p> <p>Nell'esempio in figura (pagina successiva) \u00e8 possibile vedere tre processi che condividono il codice di un editor. Ogni processo ha il proprio documento in un segmento dati privato. La condivisione del codice di un applicativo tra molti utenti pu\u00f2 consentire un notevole risparmio di memoria. Particolari accorgimenti vanno adottati in sistemi che supportano lo swapping.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#collegamento-dinamico","title":"Collegamento dinamico","text":"<p>Il Collegamento Dinamico indica il caricamento di una procedura, ad esempio una libreria, in fase di esecuzione di un processo e solo su sua richiesta. Lo spazio in memoria per una procedura viene occupato solo se e quando tale procedura viene richiesta. La segmentazione consente di aggiungere nuovi segmenti al processo richiedente, aggiornando la TDS e i registri base e limite della TDS.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#conclusioni_2","title":"Conclusioni","text":"<ul> <li>eliminando la necessit\u00e0 di allocare processi in aree contigue si rende pi\u00f9   efficiente la gestione della memoria fisica;</li> <li>viene eliminata la frammentazione interna;</li> <li>viene ridotta la frammentazione esterna;</li> <li>sono supportate efficientemente protezione e condivisione;</li> <li>viene supportato il collegamento dinamico;</li> </ul> <p>Gli svantaggi principali sono:</p> <ul> <li>necessit\u00e0 di effettuare comunque la compattazione che \u00e8 resa pi\u00f9 complessa;</li> <li>il duplice accesso alla memoria deve essere supportato da hardware apposito;</li> <li>la gestione della memoria da parte del sistema operativo \u00e8 pi\u00f9 complessa   rispetto a quella per il partizionamento statico e dinamico;</li> <li>non rende ancora possibile l'esecuzione di processi pi\u00f9 grandi delle   dimensioni fisiche della memoria.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#paginazione","title":"Paginazione","text":"<p>La memoria fisica viene concettualmente suddivisa in pagine di dimensione fissa chiamate pagine fisiche. Anche lo spazio di indirizzamento dei processi viene diviso in pagine virtuali della stessa dimensione delle pagine fisiche. Il meccanismo di traduzione fa corrispondere indirizzamenti all'interno di pagine virtuali ad indirizzamenti in pagine fisiche. Ogni pagina \u00e8 mappata separatamente, per cui non \u00e8 necessaria la contiguit\u00e0 delle pagine fisiche.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#principi-operativi_3","title":"Principi operativi","text":"<p>Ogni indirizzo all'interno di un processo \u00e8 diviso in:</p> <ul> <li>bit pi\u00f9 significativi \u2192 numero di pagina (virtuale);</li> <li>bit meno significativi \u2192 spiazzamento (reale).</li> </ul> <p>Il sistema operativo tiene traccia della corrispondenza tra pagine virtuali e pagine fisiche mediante la tabella delle pagine (TDP):</p> <ul> <li>la TDP viene costruita al momento del caricamento del processo</li> <li>ogni riga della tabella contiene l'indirizzo di partenza della pagina fisica   in cui \u00e8 allocata la corrispondente pagina virtuale (solo i bit pi\u00f9   significativi);</li> <li>la tabella \u00e8 costituita da un numero di righe pari al numero di pagine   occupate.</li> </ul> <p>Principi operativi: esempio</p> <ul> <li>Memoria: \\(1 \\MB\\);</li> <li>Dimensione Pagina: \\(256 \\byte\\);</li> <li>Numero di pagine: \\(4096\\);</li> <li>Lunghezza dell'indirizzo: \\(20 \\bit\\).</li> </ul> <p>Lo spazio di indirizzamento di un ipotetico processo utente che occupi \\(1008 \\byte\\) viene diviso in quattro pagine virtuali numerate da \\(0\\) a \\(3\\).</p> <p>La traduzione dell'indirizzo virtuale avviene nel seguente modo:</p> <ul> <li>un meccanismo hardware divide l'indirizzo virtuale in:<ul> <li>12 bit pi\u00f9 significativi (numero di pagina)</li> <li>8 bit meno significativi (displacement interno alla pagina)</li> </ul> </li> <li>il numero di pagina viene usato all'interno della TDP per ottenere il   corrispondente indirizzo della pagina fisica.</li> <li>l'indirizzo ottenuto, concatenato con il displacement, fornisce l'indirizzo   fisico cercato.</li> </ul> <p>Il sistema operativo tiene traccia dello stato di tutte le pagine fisiche mediante la tabella di memoria (TDM):</p> <ul> <li>in ogni riga della TDM \u00e8 indicato lo stato della relativa pagina: \"Libera\" o   \"Allocata\";</li> <li>il numero di righe della tabella \u00e8 uguale al numero di pagine fisiche.</li> </ul> <p>Quando un processo termina o subisce uno swapping:</p> <ul> <li>restituisce tutte le pagine fisiche ad esso assegnate;</li> <li>la sua TDP viene eliminata.</li> </ul> <p>Quando il processo richiedente ha uno spazio di indirizzamento non multiplo della dimensione delle pagine fisiche si crea il fenomeno della frammentazione interna della pagina. Questo \u00e8 comunque un fenomeno molto ridotto e legato alla dimensione della pagina fisica.</p> <p>Particolare attenzione va posta nella scelta della tecnica di memorizzazione delle aree libere. La consultazione della TDM statica per trovare \\(n\\) pagine fisiche libere, infatti, richiede una ricerca su un numero di righe in media \\(x = \\ifrac{n}{q}\\), dove \\(q\\) \u00e8 la probabilit\u00e0 che una pagina sia libera e si lega alla percentuale di memoria libera \\(u\\):</p> \\[ q = \\frac{u}{100} \\qquad  0 &lt; q &lt; 1 \\] <p>In sostanza \\(x\\) \u00e8 legata ad \\(\\ifrac{1}{q}\\) e quindi aumenta con l'aumentare della memoria utilizzata.</p> <p>Esempio</p> <p>Dati:</p> \\[ n = 10, \\qquad u = 40\\%, \\qquad q = 0.4 \\] <p>\\(x\\) in media \u00e8 di \\(25\\) righe per ritrovare \\(10\\) pagine libere  (nell'ipotesi che le pagine siano distribuite casualmente).</p> <p>Per questo motivo si preferisce sostituire la TDM con una lista a puntatori contenente i numeri delle pagine fisiche:</p> <ul> <li>\\(n\\) pagine da allocare si individuano nei primi \\(n\\) nodi della lista;</li> <li>in fase di deallocazione vengono inseriti in testa alla lista gli \\(n\\) nodi   relativi alle pagine liberate.</li> </ul> <p>Vantaggi: il tempo di allocazione e disallocazione non dipende dalla percentuale di occupazione della memoria.</p> <p>Svantaggi: per il singolo elemento vi \u00e8 un lieve spreco di memoria e di tempo rispetto alla gestione di una tabella statica.</p> <p>I meccanismi hardware per la paginazione vengono utilizzati per due scopi:</p> <ol> <li>Risparmiare la memoria necessaria per le TDP;</li> <li>Velocizzare la traduzione da indirizzi virtuali a fisici.</li> </ol>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#organizzazione-delle-tdp","title":"Organizzazione delle TDP","text":"<p>Esempio</p> <p>Si abbiano \\(16 \\MB\\) di RAM, una dimensione pagina di \\(256 \\byte\\) un numero di righe della TDP pari a \\(64\\,000\\), una dimensione della riga di \\(16 \\bit\\) e una dimensione della tabella di \\(128 \\KB\\). Non \u00e8 quindi possibile allocare il massimo numero di righe indirizzabili per ogni TDP.</p> <p>\u00c8 ragionevole costruire tabelle con un numero di righe uguale alle pagine effettivamente utilizzate. Si rende necessario quindi l'uso di due registri hardware:</p> <ul> <li>registro limite della TDP (RLTDP), che contiene il numero di pagina virtuale   pi\u00f9 alto utilizzato dal processo;</li> <li>registro base della TDP (RBTDP) che contiene l'indirizzo di partenza della   TDP.</li> </ul> <p>I valori dei registri sono di norma memorizzati nel descrittore di processo. Questo meccanismo consente anche il controllo di accesso a pagine non assegnate al processo.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#velocizzazione-del-tempo-di-traduzione","title":"Velocizzazione del tempo di traduzione","text":"<p>La traduzione di ciascun indirizzo virtuale richiede due accessi in memoria:</p> <ul> <li>uno alla TDP per prelevare il numero di pagina fisica</li> <li>l'altro per accedere fisicamente alla locazione richiesta</li> </ul> <p>In sostanza la paginazione raddoppia il tempo per l'accesso ad una locazione di memoria. Un metodo di velocizzazione \u00e8 l'uso di una cache di traduzione in cui vengono mantenuti gli indirizzi delle pagine usate pi\u00f9 frequentemente.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-protezione_3","title":"Meccanismi di protezione","text":"<p>Spazi di indirizzamento distinti vengono di norma allocati in zone disgiunte della memoria fisica. Gli accessi alla memoria sono ristretti al proprio spazio di indirizzamento. Il registro limite della TDP blocca i tentativi di accedere a pagine virtuali oltre il limite assegnato al processo. I valori dei registri sono modificati esclusivamente da istruzioni privilegiate del sistema operativo.</p> <p>L'aggiunta di alcuni bit alle righe delle TDP consente di definire e controllare il tipo di accesso alla pagina. Nella paginazione non ha senso la protezione interna allo spazio di indirizzamento del processo, poich\u00e9 non prevede tipizzazione di dati.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#meccanismi-di-condivisione_2","title":"Meccanismi di condivisione","text":"<p>La condivisione \u00e8 immediata con lo schema di paginazione, infatti:</p> <ul> <li>una copia unica di una pagina fisica pu\u00f2 essere mappata in molti spazi di   indirizzamento;</li> <li> <p>i diversi processi possono avere un tipo di accesso diverso alla pagina.</p> </li> <li> <p>la condivisione viene riconosciuta ed effettuata da programmi di sistema,   poich\u00e9 la paginazione \u00e8 trasparente all'utente;</p> </li> <li>il codice condiviso deve naturalmente essere rientrante o eseguito in mutua   esclusione.</li> </ul> <p>Codice rientrante</p> <p>\u00c8 un codice che non si automodifica e variabili, costanti e stack sono raggruppati in aree separate.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#memoria-virtuale","title":"Memoria virtuale","text":"<p>La memoria virtuale \u00e8 uno schema di gestione della memoria in cui soltanto una parte dello spazio di indirizzamento virtuale di un processo \"residente\" viene effettivamete caricata in memoria. Con questo tipo di gestione si ha che:</p> <ul> <li>la somma di tutti gli spazi di indirizzamento virtuali dei processi attivi pu\u00f2   superare la capacit\u00e0 della memoria fisica;</li> <li>la dimensione ammissibile per lo spazio di indirizzamento virtuale di un   singolo processo pu\u00f2 superare la capacit\u00e0 della memoria fisica disponibile in   un sistema.</li> </ul> <p>Gli schemi dei precedenti tipi di gestione della memoria tendevano ad una occupazione della memoria vicina al \\(100\\%\\) mentre lo schema con memoria virtuale \"sembra\" fornire un grado di occupazione superiore al \\(100\\%\\). Questo risultato si ottiene:</p> <ul> <li>mantenendo in memoria secondaria l'immagine dell'intero spazio virtuale di   indirizzamento del processo;</li> <li> <p>trasferendo in memoria fisica soltanto alcune parti al momento in cui sono   necessarie.</p> </li> <li> <p>il sistema operativo sceglie tempi e modalit\u00e0 di trasferimento in memoria   fisica tenendo conto di fattori quali:</p> <ul> <li>richieste dei processi attivi</li> <li>priorit\u00e0 dei processi</li> <li>disponibilit\u00e0 globali del sistema</li> </ul> </li> </ul> <p>Dal punto di vista del programmatore:</p> <ul> <li>i dettagli della gestione sono trasparenti;</li> <li>non \u00e8 necessario l'adeguamento di un programma ad una memoria limitata;</li> <li>un programma pu\u00f2 essere eseguito su sistemi con disponibilit\u00e0 di memoria fisica   diversa, senza alcun adattamento.</li> </ul> <p>Dal punto di vista del Sistema Operativo:</p> <ul> <li>un processo pu\u00f2 essere caricato in uno spazio di dimensione arbitrarie;</li> <li>si riduce la frammentazione esterna;</li> <li>non \u00e8 necessario modificare l'ordine previsto di esecuzione di un processo;</li> <li>il quantitativo di memoria assegnato ad un processo pu\u00f2 variare durante la   sua esecuzione;</li> <li>il sistema operativo pu\u00f2 dinamicamente scegliere di velocizzare l'esecuzione   di un processo allocando un quantitativo maggiore di memoria o, in alternativa,   aumentare il grado di multiprogrammazione.</li> </ul> <p>Osservazioni:</p> <ul> <li>un'istruzione pu\u00f2 essere completata soltanto se quanto gli \u00e8 necessario (codice,   stack, dati) \u00e8 presente in memoria;</li> <li>un processo che richiede un \"oggetto\" fuori dalla memoria viene sospeso per un   tempo \"relativamente\" lungo;</li> </ul> <p>L'importanza dell'uso dello schema di memoria virtuale si basa sulle seguenti osservazioni:</p> <ul> <li>durante una specifica esecuzione, alcune parti del programma non vengono   indirizzate;</li> <li>le diverse condizioni interne o esterne causano diversi tracciati ad ogni   esecuzione di un processo;</li> <li>alcune parti di un programma vengono eseguite molto raramente (es. routine di   gestione errori);</li> <li>alcuni programmi contengono tracciati complementari (es. compilatori).</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#principi-operativi_4","title":"Principi operativi","text":"<p>Il funzionamento della memoria virtuale \u00e8 analogo alla paginazione ed alla segmentazione e quindi con uso di tabelle di traduzione. La differenza sostanziale \u00e8 che alcune pagine possono essere \"mancanti\", per cui il processo di traduzione \u00e8 pi\u00f9 articolato. Sia \\(V = \\set{0,\\; 1,\\; \\dotsc,\\; v-1}\\) lo spazio di indirizzamento di un processo e sia \\(M = \\set{0,\\; 1,\\; \\dotsc,\\; m-1}\\) lo spazio di memoria fisica assegnato con \\(v &gt; m\\). Il meccanismo di traduzione deve realizzare la funzione \\(f\\) che associa i nomi virtuali alle locazioni fisiche:</p> \\[   f\\colon V \\to M \\tc f(x) =   \\begin{cases}     r                        &amp; \\text{se \\(x\\) \u00e8 in memoria reale in locazione } r\\\\     \\text{``cond. critica''} &amp; \\text{se \\(x\\) non \u00e8 nella memoria reale} \\\\   \\end{cases} \\]"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#tabelle","title":"Tabelle","text":"<p>Lo schema di memoria virtuale fa uso della tabella di traduzione delle pagine (nel caso di memoria virtuale con schema a paginazione) con aggiunta di \\(1 \\bbit\\) di \"presenza\" che viene posto a \\(1\\) se la pagina \u00e8 in memoria reale mentre viene posto a \\(0\\) se si tratta di una pagina mancante (page fault).</p> <p>Il caricamento di un processo avviene nel seguente modo: il sistema operativo crea la TDP, ponendo ad \\(1\\) i bit di presenza delle pagine portate in memoria. Se viene richiesta, successivamente, una pagina mancante il processo viene sospeso in attesa del suo caricamento, altri processi vengono posti in esecuzione nel frattempo.</p> <p>Lo schema di memoria virtuale fa uso anche della Tabella di Descrizione del File (TDF). La TDF \u00e8 equivalente alla TDP, associa al numero di pagine virtuali l'indirizzo di residenza di queste sulla memoria secondaria.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#interrompibilita-dellistruzione","title":"Interrompibilit\u00e0 dell'istruzione","text":"<p>In genere i sistemi supportano:</p> <ul> <li>l'interruzione di un processo tra due istruzioni;</li> <li>ma non supportano l'interrompibilit\u00e0 della singola istruzione.</li> </ul> <p>Lo schema di memoria virtuale \u00e8 implementabile solo su sistemi che supportano l'interrompibilit\u00e0 della singola istruzione.</p> <p>Istruzione Decrement and branch to Indirizzo i: decrement reg(1) and branch to address(i+1) if reg(1) = 0 Indirizzo i+1 address</p> <p>Gli indirizzi i e i+1 della singola istruzione potrebbero essere posti rispettivamente sull'ultima locazione di una pagina e sulla prima della successiva.</p> <p>L'assenza della memoria della pagina successiva causa una interruzione della istruzione che deve essere gestita oltre alla interrompibilit\u00e0 della istruzione, l'hardware deve essere in grado di gestire i cambiamenti avvenuti durante l'esecuzione della stessa. Le possibili soluzioni a questo problema sono:</p> <ul> <li>gli effetti parziali di una istruzione vengono cancellati e l'istruzione viene   ricominciata dopo aver risolto il page fault;<ul> <li>dipende strettamente dal tipo di istruzioni, non \u00e8 facile generalizzare;</li> <li>alcuni cambiamenti possono essere irreversibili;</li> <li>pu\u00f2 richiedere molto lavoro;</li> </ul> </li> <li>l'istruzione viene fatta partire dal punto esatto in cui era stata interrotta,   questo tipo di soluzione richiede forme sofisticate di memorizzazione dello   stato CPU;</li> <li>prima di iniziare l'esecuzione si controllano gli accessi in memoria che   l'istruzione eseguir\u00e0, per\u00f2 pu\u00f2 non essere possibile giustificare il controllo.</li> </ul> <p>Le soluzioni adottate sono spesso miste e rientrano nelle scelte architetturali</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#gestione-della-memoria-virtuale","title":"Gestione della memoria virtuale","text":"<p>La gestione della memoria virtuale segue gli schemi analoghi alla paginazione o alla segmentazione gi\u00e0 discussi, con l'aggiunta della TDF. Ai fini dell'efficienza della memoria virtuale l'allocazione di un sottoinsieme delle pagine virtuali su pagine fisiche richiede l'applicazione di specifiche strategie. Tali strategie si possono classificare in:</p> <ul> <li>strategie di allocazione: quanta memoria reale allocare a ciascun processo;</li> <li>strategie di ricerca: quali oggetti trasferire e quando dalla memoria secondaria   alla memoria centrale;</li> <li>strategie di sostituzione: in mancanza di spazio, quali oggetti rimuovere per   assegnare spazio alle nuove richieste;</li> <li>strategie di posizionamento: dove collocare un oggetto che entra in memoria.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#strategie-di-allocazione-e-sostituzione","title":"Strategie di allocazione e sostituzione","text":"<p>Le strategie di allocazione e sostituzione sono immediate, in quanto:</p> <ul> <li>gli oggetti vengono trasferiti quando servono, si parla infatti di paginazione   o segmentazione a richiesta;</li> <li>non sono facilmente applicabili strategie di previsione;</li> <li>il posizionamento delle pagine segue le regole dello schema con cui \u00e8 realizzata   la memoria virtuale, ossia paginazione e segmentazione.</li> </ul> <p>Queste due strategie sono particolarmente importanti per l'efficienza della gestione della memoria virtuale e richiedono particolare attenzione.</p> <p>Importante infatti analizzare il comportamento di un processo, dal punto di vista delle sequenze di accesso alla memoria durante la sua esecuzione al fine di:</p> <ul> <li>minimizzare il tempo di residenza in memoria di un processo(un processo viene   sospeso in caso di page fault);</li> <li>minimizzare i trasferimenti di pagine (coinvolgono la CPU e i dispositivi di   I/O).</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#localita-dei-programmi","title":"Localit\u00e0 dei programmi","text":"<p>Numerosi studi mostrano che i programmi hanno una forte tendenza a favorire un sottoinsieme del loro spazio di indirizzamento durante l'esecuzione. Questo fenomeno \u00e8 conosciuto con il nome di localit\u00e0 dei programmi. Dal punto di vista del sistema operativo la localit\u00e0 si concretizza nel fatto che una parte notevole degli accessi, in un periodo di tempo, vengono effettuati su un set ridotto delle pagine virtuali di un processo. Un processo si \"muove\" lentamente da una localit\u00e0 ad un'altra nel corso della sua esecuzione. La localit\u00e0 \u00e8 una propriet\u00e0 dinamica dei programmi, ossia il set di pagine pi\u00f9 referenziate varia lentamente nel tempo. Questa importante propriet\u00e0 \u00e8 utilizzata per realizzare le strategie di allocazione e sostituzione delle pagine nello schema di gestione della memoria virtuale.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#strategie-di-sostituzione","title":"Strategie di sostituzione","text":"<p>All'occorrenza di una page fault, se il gestore della memoria non ha pagine disponibili pu\u00f2 disporre due operazioni:</p> <ul> <li>sospensione del processo che ha generato la page fault</li> <li>sostituzione di una pagina in memoria</li> </ul> <p>La prima operazione \u00e8 raramente scelta perch\u00e9:</p> <ul> <li>l'eccezione di page fault \u00e8 dovuta allo schema di gestione e non al processo</li> <li>la sospensione del processo influirebbe sullo scheduling e sul tempo di risposta   relativi al processo;</li> <li>in condizioni di memoria piena il tempo che una pagina si liberi pu\u00f2 essere   lungo.</li> </ul> <p>La seconda operazione \u00e8 la via generalmente scelta perch\u00e9:</p> <ul> <li>richiede preferibilmente la presenza di 1 bit per il controllo di pagina   modificata;</li> <li>il dirty bit pu\u00f2 rientrare tra i fattori presi in considerazione per scegliere   la pagina da sostituire.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#algoritmi-di-sostituzione","title":"Algoritmi di sostituzione","text":"<p>Esistono numerosi algoritmi per la sostituzione delle pagine tra cui esaminiamo:</p> <ul> <li>algoritmo FIFO (First In First Out)</li> <li>algoritmo LRU (Least Recently Used)</li> <li>algoritmo di Belady</li> <li>algoritmo NRU (Not Recently Used)</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#first-in-first-out","title":"First In First Out","text":"<p>L'algoritmo FIFO sostituisce le pagine che da pi\u00f9 tempo risiedono in memoria. Il gestore della memoria deve tenere traccia dell'ordine di caricamento delle pagine in memoria, ad esempio con una coda FIFO dei numeri di pagina.</p> <p>Pregi:</p> <ul> <li>\u00e8 di semplice realizzazione;</li> <li>richiede di aggiornare la coda solo ad ogni page fault;</li> <li>non richiede supporti hardware specifici.</li> </ul> <p>Difetti:</p> <ul> <li>la politica FIFO spesso getta via pagine pi\u00f9 frequentemente indirizzate, poich\u00e9   per loro natura permangono pi\u00f9 tempo in memoria;</li> <li>ci\u00f2 succede perch\u00e9 questo metodo non tiene traccia dell'ordine di riferimento   delle pagine.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#least-recently-used","title":"Least Recently Used","text":"<p>L'algoritmo LRU sostituisce le pagine residenti che meno recentemente sono state utilizzate. L'LRU considerala sequenza del comportamento di un programma con l'ipotesi che la pagina meno utilizzata recentemente \u00e8 quella che ha la minore probabilit\u00e0 di essere referenziata in futuro. Una possibile modalit\u00e0 operativa \u00e8:</p> <ul> <li>memorizzare l'uso delle pagine attraverso l'uso di una struttura simile ad   uno stack;</li> <li>ogni volta che la pagina viene referenziata, viene ricercata nello stack e   posta in cima ad esso;</li> <li>la pagina da rimuovere viene presa dalla parte bassa dello stack.</li> </ul> <p>Pregi:</p> <ul> <li>in media si comporta meglio dell'algoritmo FIFO.</li> </ul> <p>Difetti:</p> <ul> <li>l'aggiornamento dello stack va effettuato ad ogni riferimento alla pagina   (praticamente ad ogni accesso in memoria);</li> <li>l'organizzazione dell'LRU \u00e8 tale da richiedere un supporto hardware sofisticato   e dedicato alle operazioni relative all'aggiornamento dello stack.</li> </ul>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#belady","title":"Belady","text":"<p>L'algoritmo di Belady sostituisce le pagine che saranno referenziate nel pi\u00f9 lontano futuro. Non \u00e8 realizzabile, ma \u00e8 di importanza teorica poich\u00e9 consente di confrontare le prestazioni degli altri algoritmi.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#not-recently-used","title":"Not Recently Used","text":"<p>L'algoritmo NRU combina il basso costo FIFO con la registrazione delle pagine residenti tipico dell'LRU sostituendo le pagine non recentemente usate.</p> <p>Principi di funzionamento:</p> <ul> <li>associa \\(1 \\bbit\\) a ciascuna pagina residente;</li> <li>il bit viene posto a \\(1\\) ad ogni riferimento alla pagina;</li> <li>i bit di tutte le pagine vengono posti a zero ciclicamente;</li> <li>al momento di scegliere la pagina, l'algoritmo sceglie tra quelle con bit a   \\(0\\);</li> <li>facendo uso di una lista circolare, riparte ogni volta dall'ultima pagina   esaminata.</li> </ul> <p>Esistono numerose varianti a questo algoritmo, ma si fondano tutte sul principio di basare le proprie decisioni sull'effettivo e misurato uso delle pagine prendendo quindi in considerazione le sequenze del comportamento di ogni programma</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#algoritmi-di-sostituzione-globale","title":"Algoritmi di sostituzione globale","text":"<p>Gli algoritmi di sostituzione globale scelgono la pagina da rimuovere non solo tra quelle appartenenti al processo ma tra tutte quelle residenti. Questi algoritmi guardano pi\u00f9 alle esigenze di sistema che all'andamento individuale di ciascun processo e possono variare la strategia degli algoritmi di allocazione. Tra gli algoritmi di sostituzione sono i meno utilizzati.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#strategie-di-allocazione-delle-pagine","title":"Strategie di allocazione delle pagine","text":"<p>Le strategie di allocazione servono per decidere quanta memoria fisica allocare a ciascun processo attivo. L'allocazione di un numero di pagine ottimale:</p> <ul> <li>riduce la frequenza di page fault</li> <li>riduce al minimo indispensabile il tempo di esecuzione</li> <li>aumenta l'uso della CPU</li> </ul> <p>L'allocazione di un numero di pagine molto grande:</p> <ul> <li>riduce il numero di processi attivi</li> <li>abbassa il fattore di utilizzo della CPU</li> </ul> <p>L'allocazione di un numero di pagine troppo ridotto:</p> <ul> <li>produce un aumento delle page fault</li> <li>aumenta il tempo di residenza in memoria dei processi</li> <li>aumenta lo spreco di CPU e dei dispositivi di I/O per il trasferimento delle pagine</li> </ul> <p>Si consideri, ad esempio, l'istruzione <code>ADD [x], [y]</code> assumendo che il codice operativo e gli operandi siano codificati ciascuno in una parola, tale istruzione richiede:</p> <ul> <li>\\(3\\) accessi in memoria per leggere l'istruzione;</li> <li>\\(2\\) per leggere gli operandi;</li> <li>\\(2\\) per leggere i valori finali da sommare;</li> <li>\\(1\\) per scrivere il risultato.</li> </ul> <p>Nel caso peggiore, l'esecuzione di questa istruzione richiede \\(6\\) pagine differenti! Poich\u00e9 una possibile realizzazione dello schema di memoria virtuale \u00e8 la riesecuzione completa di un istruzione che ha generato una page fault, se al processo sono allocate meno di \\(6\\) pagine si avr\u00e0 che:</p> <ul> <li>non completer\u00e0 mai questa istruzione;</li> <li>provocher\u00e0 continui page fault.</li> </ul> <p>Esistono quindi delle indicazioni sul numero minimo di pagine da assegnare ad un processo. A riguardo del numero massimo si fanno alcune considerazioni:</p> <ul> <li>relazione tra frequenza di errori di pagina e memoria assegnata;</li> <li>i parametri dipendono dal particolare programma, ma l'andamento degli errori   di pagina \u00e8 simile.</li> </ul> <p>Un buon algoritmo di allocazione deve variare dinamicamente il numero di pagine allocate ad un processo, in base alle sue richieste ed allo stato del sistema tenendo presente:</p> <ul> <li>il limite inferiore: sotto il quale l'aumento degli errori di pagina aumenta   molto rapidamente:</li> <li>il limite superiore: oltre il quale l'allocazione di altre pagine produce un   modesto miglioramento delle prestazioni.</li> </ul> <p>Algoritmi troppo semplificati possono provocare il thrashing: eccessivo scambio di pagine di dati tra la RAM e la memoria secondaria.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#working-set","title":"Working set","text":"<p>Orientamento comune nella gestione della memoria virtuale \u00e8 che le strategie di allocazione e di sostituzione delle pagine non possono essere trattate in modo indipendente in quanto:</p> <ul> <li>le strategie di allocazione, determinano le condizioni operative delle strategie   di sostituzione;</li> <li>le strategie di sostituzione possono variare il quantitativo di memoria allocata   ai processi.</li> </ul> <p>La teoria del Working Set tratta in maniera interattiva l'allocazione e la sostituzione indicando:</p> <ul> <li>quante pagine assegnare ad un processo;</li> <li>quali pagine \u00e8 necessario tenere in memoria.</li> </ul> <p>Le premesse su cui si poggia la teoria del Working set sono:</p> <ul> <li>durante qualsiasi intervallo di tempo, un processo in esecuzione favorisce un   sottoinsieme delle proprie pagine;</li> <li>la sequenza d'accesso alla memoria da parte di un processo mostra una relazione   tra il passato immediato ed il futuro;</li> <li>la frequenza con cui una pagina viene referenziata \u00e8 una funzione variante   lentamente nel tempo.</li> </ul> <p>Il working-set \\(W(t, \\Delta)\\) viene definito come l'insieme delle pagine referenziate da un programma durante un recente intervallo di tempo:</p> \\[   W(t, \\Delta) = \\set{i \\in \\N \\mid r_{t-\\Delta+1} &lt; i &lt; r_t} \\] <p>dove \\(r_t\\) denota l'accesso in memoria all'istante \\(t\\). In concreto, la teoria del working-set suggerisce che:</p> <ul> <li>un programma deve essere in esecuzione se e solo se il suo working-set \u00e8 in   memoria;</li> <li>una pagina di memoria pu\u00f2 essere rimpiazzata solo se non fa parte del working-set.</li> </ul> <p>La determinazione accurata del working-set richiede l'intervento del sistema operativo dopo ogni accesso in memoria, pertanto la maggior parte delle realizzazioni pratiche approssimano la teoria del working-set.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#supporti-hardware","title":"Supporti hardware","text":"<p>I supporti hardware richiesti sono gli stessi dello schema di gestione che realizza la memoria virtuale, segmentazione o paginazione in pi\u00f9 la memoria virtuale richiede i supporti per l'aggiornamento di:</p> <ul> <li>\\(1 \\bbit\\) di presenza;</li> <li>\\(1 \\bbit\\) d'uso.</li> </ul> <p>Particolare attenzione deve essere posta nella scelta della dimensione della pagina in relazione alla dimensione di allocazione dei blocchi sulla memoria secondaria.</p> <p>La protezione e la condivisione in un sistema a memoria virtuale mantengono le caratteristiche dello schema con cui \u00e8 realizzata la memoria virtuale.</p> <p>La rimozione dalla memoria di un oggetto condiviso comporta un aggravio tale di operazioni da compiere che usualmente si preferisce semplificarne la gestione lasciandolo in memoria.</p>"},{"location":"Anno_I/AESO/SO4_gestione_memoria/#conclusioni_3","title":"Conclusioni","text":"<p>Dal punto di vista dell'utente:</p> <ul> <li>la memoria virtuale consente ai programmatori di concentrarsi sulle prestazioni   dei loro programmi senza preoccuparsi del quantitativo di memoria richiesta;</li> <li>lo stesso programma pu\u00f2 essere eseguito su elaboratori con memoria fisica   diversa.</li> </ul> <p>Dal punto di vista del sistema operativo:</p> <ul> <li>la memoria virtuale consente di variare il quantitativo di memoria fisica   assegnata ad un processo e quindi di variare il numero di processi attivi e   di diminuire la memoria sprecata;</li> <li>parti di codice dei processi mai utilizzate non vengono mai caricate in memoria.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/","title":"Il file system","text":"<p>Le applicazioni su un calcolatore hanno bisogno di memorizzare e rintracciare informazioni. Le informazioni memorizzate nello spazio degli indirizzi di un processo vengono perse al termine dell'esecuzione del processo.</p> <p>Un processo pu\u00f2 utilizzare il suo spazio degli indirizzi per memorizzare un quantitativo limitato di informazioni. Pu\u00f2 essere necessario che le informazioni siano memorizzate per lungo tempo. Pi\u00f9 processi possono aver bisogno delle stesse informazioni contemporaneamente per cui \u00e8 necessario che queste e la loro allocazione siano indipendenti dal processo. Per memorizzare grandi quantit\u00e0 di informazioni, rendere la memoria permanente e dare la possibilit\u00e0 a pi\u00f9 processi di accedere alle stesse informazioni \u00e8 necessario registrare tali informazioni in dischi o altri supporti in unit\u00e0 dette file.</p>"},{"location":"Anno_I/AESO/SO5_file_system/#i-file","title":"I file","text":"<p>Il sistema operativo consente la gestione dei file mediante il modulo di gestione del File System.</p> <p>Oltre al contenuto proprio del file, il file system gestisce informazioni complementari relative al file come:</p> <ul> <li>struttura;</li> <li>nome;</li> <li>tipo di accesso;</li> <li>protezione, ecc.</li> </ul> <p>Il nome del file si suddivide generalmente in:</p> \\[ \\bnf{nome}\\,.\\bnf{estensione} \\] <p>entrambi con un numero variabile di caratteri e varia utilizzazione del minuscolo/maiuscolo. Spesso l'estensione indica un particolare tipo di file.</p>"},{"location":"Anno_I/AESO/SO5_file_system/#struttura","title":"Struttura","text":"<p>I file, in genere, contengono le informazioni in tre tipi di strutture:</p> <ul> <li>sequenza non strutturata di byte: consente la massima flessibilit\u00e0 al   programma utente. Dos e Unix utilizzano questa struttura (a); Accesso diretto   ai singoli byte:</li> <li>sequenza di record a lunghezza fissa: ha perso popolarit\u00e0 con il tempo (b);</li> <li>albero di record con campo chiave: ancora in uso sui grossi mainframe usati per   l'elaborazione di dati commerciali \u00a9. 1 Byte (a) (b) 1 Record Chiave Chiave Chiave Chiave Chiave Chiave Chiave \u00a9 3</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#tipi-e-formati","title":"Tipi e formati","text":"<p>Tipi di file:</p> <ul> <li>file regolari: contengono le informazioni dell'utente, un programma   eseguibile, ecc:</li> <li>directory: conservano la struttura del file system ed informazioni sui   file regolari;</li> <li>file speciali a caratteri: usati per modellare unit\u00e0 di input/output   seriali come video, stampanti, reti, ecc;</li> <li>file speciali a blocchi: usati per modellare unit\u00e0 di input/output a   blocchi come i dischi.</li> </ul> <p>Le informazioni nei file sono generalmente contenute in due formati:</p> <ul> <li>codice ASCII (o UNICODE, ecc.)<ul> <li>utilizza \\(8 \\bbit\\) di cui uno di controllo: \\(7 \\bbit = 128\\) configurazioni</li> <li>UNICODE: Codice a \\(16 \\bbit\\) (codifica i caratteri usati in quasi tutte le     lingue vive e in alcune lingue morte, nonch\u00e9 simboli matematici e chimici,     cartografici, l'alfabeto Braille, ideogrammi, ecc);</li> <li>i file programma sorgente ed i documenti sono generalmente registrati in questo     formato.</li> </ul> </li> <li>codice Binario:<ul> <li>le sequenze di codici sono \"illeggibili\";</li> <li>di solito i file memorizzati in questa modalit\u00e0 hanno una struttura interna.   4</li> </ul> </li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#accesso","title":"Accesso","text":"<ul> <li>Accesso Sequenziale: i byte o i record che costituiscono il file sono letti   uno dopo l'altro, dall'inizio alla fine;</li> <li>Accesso Casuale (diretto).<ul> <li>l'accesso al blocco di informazioni avviene in maniera diretta;</li> <li>l'avvento dei dischi ha consentito l'introduzione di questo metodo di     accesso;</li> <li>meccanismo utilizzato dalle basi di dati</li> <li>generalmente l'accesso \u00e8 diretto al blocco e sequenziale all'interno del     blocco.</li> </ul> </li> </ul> <p>I sistemi operativi associano ai file altre informazioni come:</p> <ul> <li>data e ora della creazione;</li> <li>proprietario;</li> <li>dimensione, ecc. I File (attributi)\u2026</li> </ul> Campo Significato Protezione Chi pu\u00f2 accedere al file e in che modo Password Parola d'ordine necessaria per accedere al file Flag di sola lettura 0 per lettura/scrittura, 1 per sola lettura Flag di sistema 0 per file normale, 1 per file di sistema Flag ASCII/binario 0 per file ASCII, 1 per file binario Lunghezza record Numero di byte in un record Tempo di creazione Data e ora del momento in cui \u00e8 stato creato il file Dimensione attuale Numero di byte nel file Dimensione massima Dimensione massima che il file pu\u00f2 raggiungere"},{"location":"Anno_I/AESO/SO5_file_system/#operazioni","title":"Operazioni","text":"<p>Il sistema operativo pone a disposizione dell'utente comandi di alto livello e chiamate di sistema per la gestione dei file. Alcune chiamate di sistema pi\u00f9 comuni sono:</p> <ul> <li>create: creazione del file;</li> <li>delete: cancellazione del file;</li> <li>open: apertura del file con varie modalit\u00e0 (read-only, append, ecc.);</li> <li>close: chiusura del file;</li> <li>read: lettura di blocchi di dati;</li> <li>write: scrittura di blocchi di dati;</li> <li>append: aggiunta, in coda al file, di nuovi dati;</li> <li>seek: posizionamento del puntatore all'interno del file.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#file-mappati-in-memoria","title":"File mappati in memoria","text":"<p>Un file viene caricarlo tutto o in parte in memoria e gli vengono assegnati indirizzi virtuali.</p> <ul> <li>i processi possono accedere in maniera trasparente ai file (possono essere quindi   contenuti in memoria centrale per interi o per blocchi)</li> <li>si velocizzano le operazioni compiute sul file, soprattutto quando si riferiscono a   parti limitate e non all'intero file.</li> </ul> <p>La virtualizzazione dell'accesso comporta alcuni problemi :</p> <ul> <li>in caso di apertura contemporanea del file da parte di pi\u00f9 processi alcune   informazioni possono risultare inconsistenti;</li> <li>quando il processo che sta usando il file termina, quest'ultimo viene riscritto sul   disco;</li> <li>in caso di caduta del sistema alcune informazioni possono essere perse.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#le-directory","title":"Le directory","text":"<p>I vecchi sistemi operativi prevedevano un'unica directory in cui confluivano tutti i file. Questo concetto \u00e8 ormai superato dai sistemi gerarchici di directory.</p> <p>Tipicamente un elemento della directory contiene:</p> <ul> <li>il nome di un file ed eventualmente include anche gli attributi del file;</li> <li>in alternativa, il nome di un file ed un puntatore ad un'altra struttura in   cui si trovano gli attributi e gli indirizzi del disco.</li> </ul> <p>Ogni directory pu\u00f2 contenere:</p> <ul> <li>file regolari;</li> <li>altre directory.</li> </ul> <p>In questo modo, a partire da una directory radice (root directory) \u00e8 possibile generare un albero di directory e subdirectory.</p> <p>Il tipo di organizzazione dell'albero delle directory dipende dalle scelte dell'amministratore di sistema. Un tipico esempio prevede:</p> <ul> <li>la root directory include alcune directory di sistema come etc, bin, lib,   tmp, ecc.;</li> <li>la directory usr contiene una subdirectory per ogni utente ed ogni utente   organizza il proprio sottoalbero nel modo che ritiene pi\u00f9 efficiente e   comodo per il tipo di attivit\u00e0 che svolge.</li> </ul> <p>Si ha inoltre:</p> <ul> <li>path name assoluto: cammino dalla directory radice al file. I componenti   del cammino sono separati da opportuni simboli di separazione come \"/\" in Unix;</li> <li>path name relativo: si usa congiuntamente al concetto di directory di   lavoro. Un utente pu\u00f2 definire una directory come directory di lavoro corrente.   In questo caso tutti i path name che non iniziano con la directory radice sono   considerati relativi alla directory di lavoro.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#operazioni_1","title":"Operazioni","text":"<p>Alcune tipiche chiamate di sistema per la gestione delle directory sono:</p> <ul> <li>create: crea una directory vuota<ul> <li><code>mkdir &lt;nome-directory&gt;</code></li> <li>directory nidificate: <code>mkdir -p &lt;nome-dir1&gt;/&lt;nome-dir2&gt;</code></li> </ul> </li> <li>delete: cancella una directory;<ul> <li>directory vuota: <code>rmdir &lt;nome-directory&gt;</code>;</li> <li>directory non vuota: <code>rm \u2013rf &lt;nome-directory&gt;</code>.</li> </ul> </li> <li>Spostarsi tra le directory:<ul> <li><code>cd newdir</code>;</li> <li><code>cd ..</code> (directory precedente);</li> <li><code>cd</code> (directory home);</li> <li><code>cd ~bill</code> (directory home dell'utente bill).</li> </ul> </li> <li>rename: rinomina una directory: <code>mv &lt;nome-directory&gt; &lt;nuovo-nome&gt;</code>;</li> <li>Elencazione file:<ul> <li><code>ls</code>;</li> <li><code>ls -l</code>, elenco dettagliato.</li> </ul> </li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#implementazione-del-file-system","title":"Implementazione del file system","text":"<p>Un fattore chiave nell'implementazione della memorizzazione dei file \u00e8 tener traccia di quali blocchi del disco associare a ciascun file.</p> <p>Le modalit\u00e0 di allocazione dei blocchi e del relativo reperimento sono:</p> <ul> <li>Allocazione contigua;</li> <li>Allocazione a lista concatenata;</li> <li>Allocazione a lista concatenata con indice;</li> <li>Allocazione mediante uso di tabelle i-node.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#allocazione-contigua","title":"Allocazione contigua","text":"<p>Memorizza il file in blocchi di disco consecutivi.</p> <p>Pregi:</p> <ul> <li>semplice da implementare: occorre tenere traccia dell'indirizzo di inizio del   file e della sua lunghezza;</li> <li>efficiente perch\u00e9 permette di leggere l'intero file con una sola operazione.</li> </ul> <p>Difetti:</p> <ul> <li>\u00e8 necessario conoscere la dimensione massima del file;</li> <li>il disco risulta frammentato (frammentazione esterna) e molto spazio viene   sprecato;</li> <li>Difficolt\u00e0 di reperire spazio libero: Best fit, First fit, Worst fit.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#allocazione-a-lista-concatenata","title":"Allocazione a lista concatenata","text":"<p>Ogni blocco associato al file contiene:</p> <ul> <li>dati veri e propri;</li> <li>il numero del blocco successivo assegnato al file.</li> </ul> <p>Pregi:</p> <ul> <li>non implica spreco di spazio perch\u00e9 i blocchi vengono allocati dinamicamente;</li> <li>no frammentazione esterna;</li> <li>nell'elemento della directory viene memorizzato l'indirizzo del primo blocco e   dell'ultimo blocco.</li> </ul> <p>Difetti:</p> <ul> <li>la lettura sequenziale del file \u00e8 semplice, ma l'accesso diretto ai blocchi \u00e8   estremamente lento;</li> <li>ogni blocco deve contenere il puntatore al blocco successivo. Tale area deve   essere non accessibile ai programmi utenti (protezione).</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#allocazione-a-lista-concatenata_1","title":"Allocazione a lista concatenata","text":"<ul> <li>I blocchi di disco assegnati al file non sono necessariamente contigui;</li> <li>L'elenco dei blocchi assegnati al file \u00e8 mantenuto mediante una tabella (sezione   su disco all'inizio di ciascuna partizione);</li> <li>L'elemento della tabella indicizzato dal numero di blocco contiene il numero   di blocco successivo del file. L'ultimo blocco punta a NULL;</li> <li>Blocchi vuoti sono indicati da NULL;</li> <li>L'elemento directory contiene il numero del primo blocco del file.</li> </ul> <p>Questo tipo di allocazione \u00e8 utilizzata nel sistema operativo MS-DOS: FAT (File Allocation Table) con indice.</p> <p>Pregi:</p> <ul> <li>l'intero blocco \u00e8 disponibile per i dati;</li> <li>l'accesso diretto ad un blocco \u00e8 rapido;</li> </ul> <p>Difetti:</p> <ul> <li>ad un gran numero di blocchi di disco corrisponde una tabella grande che   occupa molto spazio in memoria centrale;</li> <li>la lettura della FAT pu\u00f2 causare numerosi spostamenti della testina.   Soluzione: FAT in cache.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#allocazione-mediante-uso-di-tabelle-i-node","title":"Allocazione mediante uso di tabelle i-node","text":"<p>Allocazione indicizzata: tutti i puntatori ai blocchi di un file sono raggruppati in una sola locazione: blocco indice. Ogni file ha il proprio blocco indice L'elemento directory contiene l'indirizzo del blocco indice.</p> <p>Allocazione utilizzata in Unix.</p> <p>Gli i-node sono piccole tabelle che contengono:</p> <ul> <li>gli attributi del file;</li> <li>gli indirizzi dei primi quindici blocchi assegnati al file:<ul> <li>i primi 12 puntano a blocchi diretti: contengono direttamente l'indirizzo     dei blocchi del file;</li> <li>gli altri 3 puntano a blocchi indiretti.<ul> <li>Blocco indiretto singolo: il blocco indirizzato non contiene dati     ma indirizzi di altri blocchi i quali contengono dati;</li> <li>Blocco indiretto doppio;</li> <li>Blocco indiretto triplo;</li> </ul> </li> </ul> </li> </ul> <p>Pregi:</p> <ul> <li>l'elemento di directory contiene solo il nome del file ed il numero di i-node;</li> <li>consente di mantenere in memoria gli i-node dei file aperti sprecando poco   spazio;</li> <li>consente di indirizzare un numero enorme di blocchi di disco;</li> <li>per i file di piccole dimensioni consente di reperire rapidamente l'indirizzo   dei primi blocchi di disco.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#gestione-dello-spazio-su-disco-dimensione-dei-blocchi","title":"Gestione dello spazio su disco: dimensione dei blocchi","text":"<p>Blocco molto grande:</p> <ul> <li>rende pi\u00f9 veloce il tempo di lettura (seek+rotational+transfert)</li> <li>provoca maggior spreco di spazio (frammentazione interna).</li> </ul> <p>Blocco molto piccolo:</p> <ul> <li>causa numerosi accessi ai blocchi per leggere i dati</li> <li>consente una gestione pi\u00f9 efficiente dello spazio.</li> </ul> <p>L'efficienza nel tempo e nello spazio sono intrinsecamente in conflitto.</p> <p>Confrontando la velocit\u00e0 di trasferimento dei dati e l'efficienza dello spazio su disco risulta che a una buona utilizzazione dello spazio corrisponde una bassa percentuale di dati e viceversa.</p> <p>COMPROMESSO: Dimensione blocco di allocazione: \\(512 \\byte\\), \\(1 \\KB\\), \\(2 \\KB\\=, \\(4 \\KB\\), \\(8 \\KB\\).</p> <p>Il settore \u00e8 la minima unit\u00e0 fisica leggibile dal disco. La dimensione del settore sul disco \u00e8 generalmente di \\(512 \\byte\\) e la lettura di un blocco di allocazione di \\(1 K\\) causer\u00e0 sempre la lettura di due settori di disco.</p>"},{"location":"Anno_I/AESO/SO5_file_system/#gestione-dello-spazio-libero-su-disco","title":"Gestione dello spazio libero su disco","text":"<p>I metodi usati comunemente sono due:</p> <ul> <li>lista concatenata: tutti i blocchi liberi sono concatenati ed un puntatore   indica il primo blocco libero. Necessit\u00e0 di proteggere il puntatore al primo   blocco libero.</li> <li>mappa di bit: un disco di \\(n\\) blocchi richiede una mappa di \\(n\\) bit. I   blocchi liberi si rappresentano con \\(1\\) sulla mappa, i blocchi allocati con   \\(0\\) (o viceversa).</li> </ul> <p>Bit map richiede extra space. Es.</p> Text Only<pre><code>block size = 212 bytes (4KB)\ndisk size = 29230 bytes (500 gigabyte)\nn = 239/212 = 227 bits (or 16M bytes)\n</code></pre> <p>Il metodo della lista concatenata \u00e8 pi\u00f9 efficiente se il disco \u00e8 quasi pieno, poich\u00e9 il numero di blocchi \u00e8 molto limitato. Inoltre in queste condizioni, la mappa di bit potrebbe risultare spesso piena e richiedere continui accessi ad altre parti di mappa per assegnare blocchi liberi.</p> <p>Se c'\u00e8 abbastanza memoria principale per contenere la mappa di bit, \u00e8 generalmente preferibile quest'ultimo metodo.</p>"},{"location":"Anno_I/AESO/SO5_file_system/#affidabilita-del-file-system","title":"Affidabilit\u00e0 del File System","text":"<p>Il file system pu\u00f2 contenere dati che non possono essere persi poich\u00e9 di difficile o costoso recupero.</p> <p>L'affidabilit\u00e0 del file system va perseguita spesso anche a scapito dell'efficienza o di economie.</p> <p>I dispositivi di memorizzazione presentano spesso blocchi inutilizzabili:</p> <ul> <li>difetti di fabbricazione;</li> <li>usura;</li> <li>urti violenti.</li> </ul> <p>I blocchi inutilizzabili non devono essere assegnati a nessun file, necessit\u00e0 di una gestione appropriata.</p> <p>Gestione dei blocchi danneggiati:</p> <ul> <li>soluzione hardware<ul> <li>una parte di disco \u00e8 riservata per tenere traccia dei blocchi rovinati     e contiene dei blocchi di riserva;</li> <li>in fase di inizializzazione il controllore del dispositivo legge questi     blocchi e li sostituisce con blocchi di riserva, memorizzandone     l'avvenuta sostituzione;</li> <li>soluzione trasparente al file system.</li> </ul> </li> <li>soluzione software<ul> <li>il file system tiene traccia dei blocchi rovinati assegnandoli tutti ad     un file speciale da non utilizzare.</li> </ul> </li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#backup","title":"Backup","text":"<p>Nella pianificazione delle operazioni di backup vanno valutati principalmente:</p> <ul> <li>la frequenza con cui effettuare le copie di backup;</li> <li>i file che presentano la maggior necessit\u00e0 di essere copiati;</li> <li>la tecnica migliore per effettuare il backup.</li> </ul> <p>Frequenza: la scelta va pianificata in base alla quantit\u00e0 di lavoro svolta nel tempo ed al costo di ripristino. Generalmente la frequenza \u00e8 di tipo:</p> <ul> <li>giornaliero;</li> <li>settimanale;</li> <li>mensile;</li> <li>annuale (solo per archivi storici).</li> </ul> <p>Scelta dei file: la scelta va pianificata in base al contenuto dei file ed al costo di ripristino. Ad esempio: i file critici potrebbero essere raggruppati in directory dedicate delle quali si effettua copia con maggiore frequenza; la duplicazione di alcuni file critici pu\u00f2 essere opportuna se il quantitativo di memoria sprecato \u00e8 giustificabile.</p> <p>Tecnica di backup: la scelta va pianificata in base al tempo disponibile ed al costo sopportabile per i supporti. Le tecniche di backup possono essere:</p> <ul> <li>backup su nastri dell'intero file system;</li> <li>backup incrementale (copia solo dei file nuovi o modificati dall'ultimo   backup);</li> <li>duplicazione incrociata dei dati su due dispositivi: met\u00e0 di ogni disco   contiene i propri dati e l'altra met\u00e0 contiene i dati dell'altro disco.</li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#prestazioni","title":"Prestazioni","text":"<p>Accesso a disco operazione lenta. Molti file system prevedono tecniche per ridurre il numero di accessi al disco:</p> <ul> <li>caching;</li> <li>riduzione dei movimenti del braccio del disco (soluzione soft);</li> <li>riduzione dei movimenti del braccio del disco (soluzione hard).</li> </ul> <p>block cache: un certo numero di blocchi in memoria vengono riservati per contenere blocchi di disco.</p> <ul> <li>ad ogni richiesta di un blocco viene scandita la tabella dei blocchi in   memoria per verificarne la presenza;</li> <li>se non \u00e8 presente il blocco viene caricato dal disco, copiato nella   chache e poi reso disponibile alle richieste;</li> <li>la lista pu\u00f2 essere gestita con normali algoritmi di   rimpiazzamento delle pagine come FIFO e LRU;</li> </ul> <p>UNIX ogni 30 secondi riscrive tutti i blocchi modificati su disco (oppure a richiesta dell'utente), WINDOWS riscrive immediatamente ogni blocco modificato.</p> <p>Riduzione dei movimenti del braccio del disco (soluzione soft):</p> <ul> <li>raggruppamento di blocchi in uso. Andando a stimare i blocchi a cui si accede   con maggiore probabilit\u00e0 in sequenza al fine di ridurre i movimenti della   testina;</li> <li>posizione dell'indice dei blocchi . La lettura di un file richiede comunque   almeno 2 accessi (uno all'i-node ed uno al blocco). Il posizionamento degli   i-node o della tabella di allocazione dei file al centro del disco per ridurre   la distanza tra questi ed i blocchi a cui questi fanno riferimento;</li> <li>partizioni aperte. Si tende ad avvicinare il pi\u00f9 possibile gli i-node ai   blocchi cui fanno riferimento nel seguente modo:<ul> <li>divisione del disco in gruppi di cilindri, ognuno con i propri i-node e     la propria lista dei blocchi liberi;</li> <li>quando una partizione esaurisce i blocchi, un blocco pu\u00f2 essere allocato     in una partizione diversa.</li> </ul> </li> </ul> <p>Interleave. un processo richiede un tempo tb per richiedere e recuperare un blocco. In situazioni (frequenti) di richieste consecutive di blocchi sequenziali pu\u00f2 accadere che:</p> <ul> <li>il blocco richiesto pu\u00f2 essere gi\u00e0 passato sotto la testina;</li> <li>bisogna attendere una rotazione intera.</li> </ul> <p>La tecnica di interleaving alloca i blocchi fisici del disco in ordine non sequenziale stretto, ma sequenziale con salti (fattore di interleaving).</p> <p>La riduzione dei movimenti del braccio del disco (soluzione hard) avviene mediante la schedulazione del braccio del disco. Il tempo necessario per leggere un blocco di disco dipende da:</p> <ul> <li>seek time: spostamento della testina sul cilindro;</li> <li>latency time: tempo di rotazione per raggiungere il settore richiesto;</li> <li>transfer time: tempo di trasferimento.</li> </ul> <p>Il ritardo predominante \u00e8 dato dal seek time. Algoritmi per ottimizzare il movimento del braccio:</p> <ul> <li>FCFS (First Come First Served):<ul> <li>serve le richieste nell'ordine in cui giungono;</li> <li>non richiede nessun specifico supporto hardware o     software;</li> <li>\u00e8 l'algoritmo pi\u00f9 corretto nei riguardi delle richieste</li> <li>non ottimale;</li> </ul> </li> <li> <p>SSF (Shortest Seek First):</p> <ul> <li>mantenendo in tabella tutte le richieste pendenti, l'SSF si sposta sempre     sulla richiesta pi\u00f9 vicina a quella appena servita;</li> <li>riduce di circa la met\u00e0 gli spostamenti sul disco rispetto al FCFS;</li> <li>presenta un problema di localizzazione delle richieste.</li> </ul> </li> <li> <p>algoritmo dell'ascensore:</p> <ul> <li>mantiene in tabella le richieste pendenti;</li> <li>un bit up/down indica la direzione attuale del braccio del disco;</li> <li>serve le richieste pi\u00f9 vicine proseguendo sempre nella stessa direzione;</li> <li>cambia direzione quando raggiunge l'estremit\u00e0 o quando non ci sono pi\u00f9     richieste nella direzione attuale;</li> </ul> </li> </ul>"},{"location":"Anno_I/AESO/SO5_file_system/#identificazione-degli-utenti","title":"Identificazione degli utenti","text":"<p>I meccanismi di protezione degli archivi sono basati sul presupposto della sicura identificazione degli utenti.</p> <ul> <li>nei sistemi interattivi multi-utente, il progenitore di tutti i processi di   un generico utente \u00e8 quello che viene generato quando esso si connette al   sistema attraverso un terminale.</li> <li>per ogni processo diverso dal progenitore, la responsabilit\u00e0 di definire il   proprietario spetta esclusivamente al sistema operativo</li> <li>la sicurezza degli archivi \u00e8 fondata sulla corretta definizione del   proprietario del processo progenitore, che a sua volta dipende dalla   sicura identificazione dell'utente che si connette attraverso il terminale.</li> <li>la tecnica comunemente usata \u00e8 quella della parola d'ordine (password),</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/","title":"Laboratorio di Informatica","text":"<p>Corso tenuto da Fabio Abbattista fabbattista@gmail.com.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/","title":"Test e Debugging","text":"Bug <p>Errore sintattico o semantico presente in un programma.</p> Debug <p>Processo di riconoscimento e rimozione dei bug.</p> Attenzione <p>I bug sono molto frequenti, anche in programmi semplici. Il debug \u00e8 un'attivit\u00e0 difficile, che richiede un tempo imprevedibile e occorre adottare tutte le tecniche che riducano la presenza di bug e il tempo del debug.</p> <p>Test e Debugging sono due attivit\u00e0 diverse, la prima avviene dopo la scrittura del codice, la seconda invece avviene durante la scrittura dello stesso. Entrambe mirano a cercare errori nel codice.</p> <p>Il debugging non viene effettuato sistematicamente, a differenza del testing.</p> <p>Il testing pu\u00f2 essere effettuato anche dopo la stesura di una funzione o altro, non per forza va effettuato dopo la stesura dell'intero codice.</p> Origine della parola Bug <p>Il \\(9\\) settembre \\(1947\\) il tenente Grace Hopper ed il suo gruppo stavano cercando la causa del malfunzionamento di un computer Mark II quando, con stupore, si accorsero che una falena si era incastrata tra i circuiti. Dopo aver rimosso l'insetto (alle ore \\(15\\):\\(45\\), il tenente incoll\u00f2 la falena rimossa sul registro del computer e annot\u00f2: \"\\(1545\\). Relay \\(\\#70\\) Panel F (moth) in relay. First actual case of bug being found\". Questo registro \u00e8 conservato presso lo Smithsonian National Museum of American History<sup>\\(\\dagger\\)</sup>.</p> <p>Il testing \u00e8 una fase di verifica sistematica della correttezza di un software. \u00c8 una stima della correttezza ed \u00e8 parte integrante dei processi di sviluppo del software. Il testing \u00e8 parte prevalente nelle metodologie agili.</p> <p>Il debugging \u00e8 un processo atto a scovare la causa di un errore.</p> <p>E. Dijkstra</p> <p>Il testing pu\u00f2 solo dimostrare la presenza di bug, ma non la loro assenza.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#verifica-delle-condizioni-limite","title":"Verifica delle condizioni limite","text":"<p>La maggior parte dei bug si verificano in corrispondenza dei limiti:</p> <ul> <li>Cicli: cosa succede se il numero di cicli \u00e8 \\(0\\)?</li> <li>Array: cosa succede se si tenta di colmare un array?</li> <li>Input: cosa succede se l'input acquisito \u00e8 nullo?</li> <li>Stream: cosa succede se si accede a un file inesistente, un disco pieno,   una connessione interrotta, etc?</li> </ul> <p>Approccio: ogni volta che si scrive un blocco di codice significativo (ciclo, condizione, input), \u00e8 necessario testarne le condizioni limite.</p> <p>Occorre immaginare tutte le possibili condizioni limite e documentarle.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#esempio","title":"Esempio","text":"<p>Il seguente programma tenta di leggere una sequenza di caratteri da un file e li memorizza in un array fino a quando viene letta una newline o si raggiunge la dimensione massima <code>MAX</code> maggiore di zero:</p> C<pre><code>int i = 0;\nchar c[MAX];\nwhile ((c[i] = fgetc(file)) != '\\n' &amp;&amp; (i &lt; MAX - 1)) {\ni = i + 1;\n}\nc[--i] = '\\0';\n</code></pre> <p>Quali sono le condizioni limite?</p> <ol> <li>l'input \u00e8 vuoto (<code>'\\n'</code>);</li> <li><code>MAX == 1</code>;</li> <li>l'input ha una lunghezza pari a <code>MAX</code>;</li> <li>l'input ha una lunghezza maggiore di <code>MAX</code>;</li> <li>l'input non contiene una newline (se possibile).</li> </ol> <p>Riscrivendo il codice usando uno stile pi\u00f9 leggibile, si eviterebbe l'errore del codice precedente:</p> C<pre><code>int i = 0;\nchar c[MAX];\nint stop = 0;\nwhile (!stop &amp;&amp; i &lt; MAX) {\nc[i] = fgetc(file);\nstop = (c[i] == '\\n');\ni = i + 1;\n}\nc[--i] = '\\0';\n</code></pre> <p>Esercizio (?)</p> C<pre><code>/**\n * @brief Restituisce la media aritmetica di una lista di numeri.\n *\n * @param a     la lista di numeri di cui calcolare la media.\n * @param len_a la lunghezza della lista di numeri.\n * @return la media aritmetica.\n */\ndouble avg(double a[], int len_a) {\nint i;\ndouble sum = 0.0;\nfor (i = 0; i &lt; len_a; i++) {\nsum += a[i];\n}\nreturn sum / len_a;\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#programmazione-difensiva","title":"Programmazione difensiva","text":"<p>Si tratta dell'aggiunta di codice per casi \"impossibili\":</p> C<pre><code>if (age &lt; 0 || age &gt; MAX_AGE) {\nrange = \"???\";\n} else if (age &lt;= 18) {\nrange = \"Teenager\";\n} // ...\n</code></pre> <p>Non si pu\u00f2 assumere che i dati ricevuti in input dal programma siano corretti, il pi\u00f9 delle volte non lo sono. in questo modo, il programmatore si cautela da qualsiasi input venga inserito.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#controllo-dei-valori-di-errore-restituiti","title":"Controllo dei valori di errore restituiti","text":"<p>Se una funzione restituisce dei valori di errore questi vanno verificati dal chiamante:</p> C<pre><code>range = num_to_range(age);\nif (strcmp(range, \"???\") == 0) {\n/* errore */\n// ...\n} else {\n// ...\n}\n</code></pre> <p>La funzione non deve preoccuparsi di scrivere all'utente che sia sbagliato, etc, essa riceve un numero e trova la sua categoria. Il resto lo gestisce la funzione chiamante, altrimenti la funzione chiamante far\u00e0 il suo normale lavoro.</p> <p>\u00c8 possibile che la funzione chiamante non gestisca direttamente l'errore ma restituisce un valore specifico e lo gestir\u00e0 un'altra funzione ancora.</p> <p>Una funzione dovrebbe avere un solo compito e un solo output, cos\u00ec se sbaglia \u00e8 pi\u00f9 facile capire chi ha sbagliato e dove, rispetto all'avere pi\u00f9 compiti per la stessa funzione.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#testing-sistematico","title":"Testing sistematico","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#verifica-incrementale","title":"Verifica incrementale","text":"<p>In questa modalit\u00e0 il testing va di pari passo con l'implementazione. Il test viene effetuato su unit\u00e0 elementari, ovvero:</p> <ul> <li>una procedura o funzione;</li> <li>un blocco significativo di procedura.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#verifica-bottom-up","title":"Verifica bottom-up","text":"<p>si tratta di testare prima le parti:</p> <ul> <li>(componenti/casi) pi\u00f9 semplici</li> <li>pi\u00f9 frequentemente utilizzate</li> </ul> <p>Ricerca binaria</p> <ul> <li>in un array vuoto;</li> <li>in un array con un solo elemento;</li> <li>di un elemento minore di quello presente;</li> <li>di un elemento uguale a quello presente;</li> <li>di un elemento maggiore di quello presente:</li> <li>in un array con due elementi:<ul> <li>\\(5\\) combinazioni possibili.</li> </ul> </li> <li>in presenza di elementi ripetuti;</li> <li>in presenza di elementi contigui e non contigui.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#verifica-dei-risultati-attesi","title":"Verifica dei risultati attesi","text":"<p>Non \u00e8 prevista la conoscenza dell'algoritmo.</p> <p>Per ogni test, occorre conoscere il risultato atteso. Questo \u00e8 ovvio per molti casi, ma non per tutti.</p> <p>Ad esempio, per testare un compilatore si pu\u00f2 compilare uno o pi\u00f9 programmi formalmente corretti e testarli.</p> <p>Per testare un programma di calcolo numerico, \u00e8 possibile</p> <ul> <li>verificare i limiti dell'algoritmo;</li> <li>verificare propriet\u00e0 note;</li> <li>testare problemi con risultati gi\u00e0 noti;</li> <li>analisi statistiche.</li> </ul> <p>Mentre per testare un programma grafico/multimediale:</p> <ul> <li>uso di strumenti di image editing;</li> <li>analisi statistiche.</li> </ul> <p>Un esempio di testing di una funzione \u00e8 il seguente:</p> <pre><code>stateDiagram-v2\n  direction LR\n  fx: f(x)\n  [*] --&gt; fx: 5\n  [*] --&gt; fx: -4\n  fx --&gt; [*]: errore</code></pre> <p>oppure</p> <pre><code>stateDiagram-v2\n  direction LR\n  fx: f(x)\n  [*] --&gt; fx: 7\n  [*] --&gt; fx: 5\n  fx --&gt; [*]: 12</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#verificare-la-copertura-dei-test","title":"Verificare la copertura dei test","text":"<p>Il test di copertura \u00e8 un po' pi\u00f9 complicato poich\u00e9 non si basa pi\u00f9 soltanto sulla conoscienza dei dati di input.</p> <p>I test devono garantire che ogni istruzione sia eseguita almeno una volta, questo equivale a testare:</p> <ul> <li>i rami <code>then..else</code></li> <li>tutti i case di una <code>switch</code></li> <li>che l'esecuzione dei cicli avvenga:<ul> <li>\\(0\\), \\(1\\), \\(n\\), \\(n - 1\\) volte, con \\(n\\) massimo.</li> </ul> </li> </ul> <p>Nel caso di <code>if</code> i rami sono due, all'aggiunta di un altro <code>if</code>, raddoppiano. Nel caso di un ciclo aumentano di molto.</p> <p>Classi di equivalenza, ad esempio, se \\(n \\in ]\\min,\\; \\max[\\) allora bisogna verificare cosa sucede nei seguenti casi</p> \\[ n &lt; \\min, \\qquad n &gt; \\max, \\qquad n = \\min, \\qquad n = \\max \\] <p>L'analisi del codice pu\u00f2 aiutare a individuare gli input che consentono di coprire tutto il codice. La scelta deve essere tale da far attraversare al dato un ramo specifico, in modo tale da verificare ogni possibilit\u00e0.</p> <p>Non \u00e8 inoltre detto che ogni funzione debba essere testata con ogni tipo di test. Ad esempio, se non \u00e8 presente molta elaborazione sarebbe meglio utilizzare il test di copertura. Raramente si hanno funzioni con sia molti input che molta elaborazione.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#procedure-e-funzioni-in-c","title":"Procedure e Funzioni in C","text":"<p>Sono istruzioni non primitive per risolvere parti specifiche di un problema: i sottoprogrammi (o metodi). Sono realizzate mediante la definizione di unit\u00e0 di programma (sottoprogrammi) distinte dal programma principale (<code>main</code>). Rappresentano nuove istruzioni/operatori che agiscono sui dati utilizzati dal programma. Sono definite a partire da una sequenza di istruzioni primitive e altre procedure/funzioni.</p> <p>Tutti i linguaggi di alto livello offrono le possibilit\u00e0 di utilizzare funzioni e procedure mediante:</p> <ul> <li>costrutti per la definizione di sottoprogrammi;</li> <li>meccanismi per la chiamata a sottoprogrammi.</li> </ul> <p>Nei linguaggi ad alto livello funzioni e procedure sono molto utili per raggiungere:</p> <ul> <li>Astrazione;</li> <li>Riusabilit\u00e0;</li> <li>Modularit\u00e0 (strutturazione);</li> <li>Leggibilit\u00e0.</li> </ul> <p>Nella fase di definizione di una funzione o procedura si stabilisce:</p> <ul> <li>un identificatore del sottoprogramma (cio\u00e8 il nome da usare per   chiamare/invocare lo stesso);</li> <li>un corpo del sottoprogramma (cio\u00e8, l'insieme di istruzioni che sar\u00e0 eseguito   ogni volta che il sottoprogramma sar\u00e0 chiamato);</li> <li>una lista di parametri formali (cio\u00e8 come avviene la comunicazione tra l'unit\u00e0   di programma che usa il sottoprogramma ed il sottoprogramma stesso).</li> </ul> funzioneprocedura C<pre><code>// prototipo\nint sum(int a, int b);\n// dichiarazione\nint sum(int a, int b) {\nint c = a + b;\nreturn c;\n}\n// chiamata\nint main(void) {\nint op1, op2, result;\n// ...\nresult = sum(op1, op2);\nreturn 0;\n}\n</code></pre> <ul> <li>operatore non primitivo;</li> <li>permette di definire nuovi operatori complessi da affiancare a quelli   primitivi;</li> <li>restituisce un valore di ritorno (mediante <code>return</code>).</li> </ul> C<pre><code>// prototipo\nvoid print(int a);\n// dichiarazione\nvoid print(int a) { printf(\"%d\", a); }\n// chiamata\nint main(void) {\nint value;\n// ..\nprint(value);\n}\n</code></pre> <ul> <li>istruzione non primitiva;</li> <li>\u00e8 attivabile in un qualunque punto del programma in cui pu\u00f2 comparire   un'istruzione;</li> <li>non restituisce un valore di ritorno (mediante return).</li> </ul> <p>I parametri costituiscono il mezzo di comunicazione tra unit\u00e0 chiamante e unit\u00e0 chiamata, supportano lo scambio di informazioni tra chiamante e sottoprogramma.</p> <p>Si differenziano in:</p> <ul> <li>Parametri formali (specificati nella definizione);</li> <li>Parametri attuali (specificati nella chiamata).</li> </ul> <p>Parametri attuali e formali devono corrispondersi in numero, posizione e tipo.</p> parametri formaliparametri attuali <p>Sono quelli specificati nella definizione del sottoprogramma. Sono in numero prefissato e a ognuno di essi viene associato un tipo. Le istruzioni del corpo del sottoprogramma utilizzano i parametri formali.</p> <p>Sono i valori effettivamente forniti dall'unit\u00e0 chiamante al sottoprogramma all'atto della invocazione.</p> <p>Il passaggio di parametri pu\u00f2 avvenire in due modi:</p> <ul> <li>per valore;</li> <li>per indirizzo (o riferimento).</li> </ul> <p>Il C di default adotta il passaggio per valore:</p> <ul> <li>il valore dei parametri \u00e8 copiato nello stack;</li> <li>il passaggio per riferimento si ottiene memorizzando nello stack l'indirizzo   (puntatore) in cui \u00e8 allocata una variabile;</li> <li>il passaggio per valore \u00e8 anche pi\u00f9 \"sicuro\".</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#unit-test","title":"Unit test","text":"<p>\u00c8 una tecnica di progetto e sviluppo del software e serve a ottenere evidenza che le singole unit\u00e0 software sviluppate siano corrette e pronte all'uso. In un linguaggio procedurale come il C una unit\u00e0 pu\u00f2 essere un programma, una funzione, ecc.</p> <p>Per effettuarlo si scrivono degli unit test (o casi di test) rappresentanti una sorta di \"contratto scritto\" che la porzione di codice testata deve soddisfare.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#xunit-test-framework","title":"xUnit test framework","text":"<p>In principio \u00e8 stato creato JUnit per Java, da Kent Beck e Erich Gamma.</p> <p>M. Fowler</p> <p>Never in the field of software development have so many owed so much to so few lines of code.</p> <p>\u00c8 stato portato verso innumerevoli altri linguaggi (C/C++, C#, PHP, Python, JavaScript, Ruby, etc) dando vita all'ecosistema dei framework di tipo xUnit</p> <p>Ha dato vita al Test-Driven Development (TDD, sviluppo guidato dal test).</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#cunit","title":"CUnit","text":"<p>\u00c8 un framework di unit test per il linguaggio C la cui home page \u00e8 la seguente http://cunit.sourceforge.net/index.html.</p> <p>\u00c8 una libreria che va inclusa in ogni progetto Eclipse CDT di chiunque intenda avvalersene. La guida di installazione \u00e8 disponibile qui: http://collab.di.uniba.it/fabio/guide/</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#struttura-del-framework","title":"Struttura del framework","text":"<p>Il framework esegue automaticamente tutte le test suite inserite nel test registry. Ogni test suite \u00e8 composta da uno o pi\u00f9 test method logicamente correlati (es. suite per testare tutti i metodi di un particolare modulo).</p> <pre><code>flowchart TD \n  testRegistry(Test Registry) --&gt; suite1(Suite 1) &amp; suiten(Suite n);\n  suite1 --&gt; test1[Test 1] &amp; testm[Test m];\n  suiten --&gt; testn1[Test 1,n] &amp; testnm[Test n,m];</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#method-under-test","title":"Method under test","text":"<p>Il programma da testare \u00e8 costituito da diversi file <code>.c</code> (detti moduli) contenenti diverse funzioni e/o procedure (es. <code>func_1()</code>, <code>func_n()</code>o <code>proc_n()</code>, <code>proc_m()</code>). Queste funzioni e procedure sono detti methods under test. Per ciascun metodo da testare occorre scrivere almeno un test method. Ciascun metodo di test va chiamato <code>test_xyz()</code> (es. <code>test_funz_1()</code>, <code>test_funz_n()</code>, o <code>test_proc_1()</code>, <code>test_proc_m()</code>).</p> <p>Un metodo di test verifica la presenza di errori nel corrispettivo metodo sotto test. Con errore si intende un comportamento diverso da quello atteso.</p> <p>Attenzione</p> <p>L'ordine di inserimento ha importanza! Le test suite sono eseguite nello stesso ordine di inserimento nel registry mentre i test method sono eseguiti nello stesso ordine di inserimento nella suite.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#ciclo-di-unit-test","title":"Ciclo di unit test","text":"<p>Sequenza tipica di uso di un framework di unit test, incluso CUnit:</p> <ol> <li>Scrivi tutti i test method necessari;</li> <li>Crea il test registry;</li> <li>Crea la test suite e aggiungila al test registry;</li> <li>Aggiungi i test method alle test suite definite;</li> <li>Se necessario, ripeti i passi 3-4 per un'altra suite;</li> <li>Esegui il test registry;</li> <li>Pulisci il test registry.</li> </ol>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#aggiungere-le-librerie-cunit-a-un-progetto","title":"Aggiungere le librerie CUnit a un progetto","text":"<p>Guida di installazione e configurazione disponibile alla sezione dispense sul sito del corso: http://collab.di.uniba.it/fabio/guide/.</p> <p>Quando si prepara il modulo con i metodi di test ricordate di includere i file header in questo modo:</p> C<pre><code>#include \"CUnit/Basic.h\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#scrivere-un-test-method","title":"Scrivere un test method","text":"<p>Un metodo di test in CUnit si presenta sempre nella forma di procedura senza parametri, ad esempio <code>void test_xyz(void)</code>. Un metodo di test \u00e8 un contratto che stabilisce i vincoli che devono essere soddisfatti dal software:</p> <ul> <li>i vincoli sono stabiliti attraverso delle asserzioni;</li> <li>Un'asserzione in un linguaggio di programmazione \u00e8 una funzione che verifica   una condizione logica e restituisce:<ul> <li>Vero, se l'asserzione \u00e8 rispettata;</li> <li>Falso, altrimenti.</li> </ul> </li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#asserzioni-di-base-cunit","title":"Asserzioni di base (CUnit)","text":"Asserzione Significato <code>CU_ASSERT(int espressione)</code><code>CU_TEST(int espressione)</code> Asserisce che espressione \u00e8 <code>TRUE</code> (diverso da 0) <code>CU_ASSERT_TRUE(valore)</code> Asserisce che valore \u00e8 <code>TRUE</code> (diverso da 0) <code>CU_ASSERT_FALSE(valore)</code> Asserisce che valore \u00e8 <code>FALSE</code> (uguale a 0) <code>CU_ASSERT_EQUAL(reale, atteso)</code> Asserisce che reale <code>==</code> atteso <code>CU_ASSERT_NOT_EQUAL(reale, atteso)</code> Asserisce che reale <code>!=</code> atteso <code>CU_ASSERT_STRING_EQUAL(reale, atteso)</code> Asserisce che le stringhe reale e atteso coincidono <code>CU_ASSERT_STRING_NOT_EQUAL(reale, atteso)</code> Asserisce che le stringhe reale e atteso differiscono"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#esempio-di-test-method-per-la-funzione-maxab","title":"Esempio di test method per la funzione <code>max(a,b)</code>","text":"C<pre><code>void test_max(void) {\nCU_ASSERT_EQUAL(max(0, 2), 2);\nCU_ASSERT_TRUE(max(0, -2) == 0);\nCU_TEST(max(2, 2) == 2);\n// questa asserzione \u00e8 sbagliata e fallisce\nCU_ASSERT_TRUE(max(5, 6) == 2);\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#esempio-di-metodo-di-test-per-la-funzione-factorialx","title":"Esempio di metodo di test per la funzione <code>factorial(x)</code>","text":"\\[   n! = \\begin{cases}          1       &amp; \\text{se } n = 0 \\\\          n(n-1)! &amp; \\text{se } n &gt; 1 \\\\        \\end{cases} \\] C<pre><code>void test_factorial(void) {\n// fallisce\nCU_ASSERT_EQUAL(factorial(4), 12);\nCU_ASSERT(factorial(3) == 6);\nCU_TEST(factorial(6) == 720);\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#il-test-registry","title":"Il Test Registry","text":"<p>Raccoglie tutte le test suite. Quando si esegue un Test Registry si eseguono tutte le suite al suo interno e, di conseguenza, tutti i test method all'interno delle suite.</p> <pre><code>flowchart TD \n  testRegistry(Test Registry) --&gt; suite1(Suite 1) &amp; suiten(Suite n);\n  suite1 --&gt; test1[Test 1] &amp; testm[Test m];\n  suiten --&gt; testn1[Test 1,n] &amp; testnm[Test n,m];</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#inizializzazione-del-test-registry","title":"Inizializzazione del Test Registry","text":"<p>L'inizializzazione del test registry \u00e8 la prima operazione da effettuare:</p> C<pre><code>// *************************************************\n// TEST DI UNIT\u00c0\nint main() {\n/* inizializza registro - \u00e8 la prima istruzione */\nCU_initialize_registry();\n// ...\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#test-suite","title":"Test Suite","text":"<p>Una test suite \u00e8 definita da:</p> <ul> <li>una descrizione testuale;</li> <li>una procedura di inizializzazione (init);</li> <li>una procedura di pulitura (clean).</li> </ul> <p>Le test suite definite vengono aggiunte al test registry (l'ordine \u00e8 rilevante!)</p> C<pre><code>/* aggiungi le suite al test registry */\nCU_pSuite pSuite_A =\nCU_add_suite(\"Suite_A\", init_suite_default, clean_suite_default);\nCU_pSuite pSuite_B =\nCU_add_suite(\"Suite_B\", init_suite_default, clean_suite_default);\n</code></pre> <p>Di default inizializzazione e pulitura sono procedure vuote.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#inizializzazione-e-pulizia-delle-suite","title":"Inizializzazione e pulizia delle suite","text":"<p>Le test suite devono essere inizializzate e ripulite prima e dopo l'uso. I metodi non sono forniti da CUnit ma devono essere scritti dal programmatore.</p> <p>Perch\u00e9?</p> <p>Perch\u00e9 devono liberare le risorse allocate specificatamente per eseguire il caso di test (es. file, connessioni, etc.).</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#inizializzazione-e-pulizia","title":"Inizializzazione e pulizia","text":"C<pre><code>// Alloca tutte le risorse necessarie all'esecuzione dei test\nint init_suite_default(void) {\nreturn 0;  // tutto ok\n}\n// dealloca tutte le risorse allocate all'inizializzazione\nint clean_suite_default(void) {\nreturn 0;  // tutto ok\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#test-method-e-test-suite","title":"Test method e test suite","text":"<p>Un test method viene aggiunto ad una test suite specificando:</p> <ul> <li>il puntatore alla suite</li> <li>una descrizione testuale del test</li> <li>il puntatore al test method</li> </ul> C<pre><code>/* Aggiungi i test alle suite\n * NOTA - L'ORDINE DI INSERIMENTO \u00c8 IMPORTANTE\n */\nCU_add_test(pSuite_A, \"test of f1()\", test_f1);\nCU_add_test(pSuite_A, \"test of f3()\", test_f3);\nCU_add_test(pSuite_B, \"test of f4()\", test_f4);\nCU_add_test(pSuite_B, \"test of f2()\", test_f2);\n</code></pre> <p>L'ordine dei test nelle suite \u00e8 rilevante!</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#registrazione-ed-esecuzione-dei-test","title":"Registrazione ed esecuzione dei test","text":"<p>La procedura <code>CU_basic_run_tests()</code> esegue tutte le suite del registry e mostra i risultati.</p> C<pre><code>/* esegue tutti i casi di test con output sulla console */\nCU_basic_set_mode(CU_BRM_VERBOSE);\nCU_basic_run_tests();\n</code></pre> <p>\u00c8 possibile impostare il livello di \"verbosit\u00e0\" dell'output.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#pulire-il-registry","title":"Pulire il registry","text":"<p>Pulizia \u2013 dopo aver eseguito tutti i test nel registro. Procedura <code>void CU_cleanup_registry(void)</code>.</p> C<pre><code>/* pulisce il registro e termina lo unit test */\nCU_cleanup_registry();\nreturn CU_get_error();\n</code></pre> <p>Il <code>main()</code> termina con la return dell'eventuale codice di errore di CUnit.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#esercitazione-1-cunit","title":"Esercitazione 1 CUnit","text":"<p>Link all'esercitazione: http://goo.gl/VYfhsN</p> <p>Implementazione di una serie di funzioni e testing di queste con l'utilizzo di CUnit template di CUnit disponibile a http://goo.gl/uevMHu.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#debugging","title":"Debugging","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#supporto-del-compilatore","title":"Supporto del compilatore","text":"<p>Molti compilatori emettono dei \"warning\", cio\u00e9 dei messaggi di avvertimento:</p> <ul> <li><code>if (a = 0)</code>;</li> <li><code>x = x</code>;</li> <li>nessun return;</li> <li>codice orfano;</li> <li>condizioni tautologiche.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#backward-reasoning","title":"Backward reasoning","text":"<p>Quando si scopre un bug, occorre \"pensare al contrario\". Partendo dal risultato, occorre risalire alla catena delle cause che lo hanno portato. Una delle cause della catena sar\u00e0 errata.</p> <p>Scrivere codice leggibile aiuta al backward reasoning e, quindi, a localizzare i bug.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#pattern-familiari","title":"Pattern familiari","text":"<p>Riconoscere variazioni rispetto a \"modelli\" (pattern) di codice familiari.</p> C<pre><code>int n;\nscanf(\"%d\", n);\nint n;\nscanf(\"%d\", &amp;n);\n</code></pre> <p>L'uso di un corretto stile di programmazione aiuta a ridurre la presenza di bug.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#sviluppo-incrementale","title":"Sviluppo incrementale","text":"<p>Testare le procedure man mano che vengono sviluppate. Se i test all'istante \\(t\\) hanno successo ma falliscono all'istante \\(t + 1\\), allora molto probabilmente i bug si annidano nel codice sviluppato tra \\(t\\) e \\(t + 1\\).</p> <p>La progettazione modulare del codice aiuta a individuare meglio la posizione dei bug.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#esaminare-codice-simile","title":"Esaminare codice simile","text":"<p>Se un bug \u00e8 presente in una porzione di codice, allora \u00e8 probabile che se ne annidi un altro in un codice simile. Problema del \"copy-and-paste\". Una buona progettazione del codice riduce la ridondanza e, quindi, la possibilit\u00e0 di bug duplicati</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#non-rimandare-il-debugging","title":"Non rimandare il debugging","text":"<p>Se un bug \u00e8 individuato, va eliminato subito. Il trasferimento di un bug nei passi successivi del ciclo di sviluppo di un software fa crescere il costo del debugging in termini esponenziali.</p> D. Wilner, 1997 IEEE Real-Time Systems Symposium <p>The Mars Pathfinder mission was widely proclaimed as \"flawless\" in the early days after its July \\(4\\)th, \\(1997\\) landing on the Martian surface. [...] But a few days into the mission, not long after Pathfinder started gathering meteorological data, the spacecraft began experiencing total system resets, each resulting in losses of data.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#leggere-e-spiegare-il-codice","title":"Leggere e spiegare il codice","text":"<p>Leggere il codice e comprenderne il significato. Il codice \u00e8 un pezzo di conoscenza che deve essere compreso dalla macchina e da chi la programma. La leggibilit\u00e0 del codice \u00e8 fondamentale.</p> <p>Spiegare ad altri il codice aiuta a ridurre \"bias\" cognitivi.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#rendere-riproducibile-un-bug","title":"Rendere riproducibile un bug","text":"<p>Individuare tutte le condizioni che portano alla manifestazione di un bug</p> <ul> <li>Input e altri parametri;</li> <li>Condizioni della macchina;</li> <li>Seed di numeri casuali.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#divide-et-impera","title":"Divide et impera","text":"<p>Individuare le condizioni minimali che rendono manifesto un bug (es. il pi\u00f9 piccolo array, la stringa pi\u00f9 breve). Il test dei casi limite \u00e8 fondamentale.</p> <p>Le condizioni minimali possono facilitare la localizzazione di un bug. Se il bug non si manifesta in un caso limite, provare mediante dimezzamenti successivi dell'input. Ricerca binaria sulla lunghezza dell'input.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#ricerca-di-regolarita","title":"Ricerca di regolarit\u00e0","text":"<p>Alcuni bug si presentano con regolarit\u00e0, ma non sempre. In questo caso, occorre capire il modello (pattern) che genera la regolarit\u00e0.</p> <p>Ad esempio un editor di testi salta la visualizzazione di alcuni caratteri, l'analisi del testo mostra che i caratteri saltati sono sempre intervallati da \\(1023\\) caratteri stampati. Regolarit\u00e0: un carattere saltato ogni \\(1023\\). L'analisi del codice rivela che gli array che memorizzano le stringhe sono da \\(1024 \\byte\\) \\(1023\\) caratteri + <code>\u2018\\0'</code> portano al bug.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#stampe-ausiliarie","title":"Stampe ausiliarie","text":"<p>Per seguire l'esecuzione di un programma pu\u00f2 essere utile introdurre stampe ausiliarie. Valido soprattutto per situazioni che non possono essere tracciate da un debugger (es. sistemi distribuiti, programmi paralleli, etc.).</p> <p>Le stampe ausiliarie devono necessariamente essere eliminate dopo aver scovato il bug. Rischio di violazione delle specifiche. Possono essere commentate anzich\u00e9 eliminate.</p> <p>Per situazioni complesse, si possono usare strumenti di logging.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#altre-tecniche","title":"Altre tecniche","text":"<p>Esse sono:</p> <ul> <li>visualizzazioni grafiche;</li> <li>test statistici;</li> <li>strumenti di analisi di testo, come:<ul> <li>grep;</li> <li>diff;</li> <li>etc.</li> </ul> </li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#debugger","title":"Debugger","text":"<p>Un debugger guarda \"dentro\" il programma durante l'esecuzione:</p> <ul> <li>tracing del programma;</li> <li>visualizzazione del contenuto delle variabili;</li> <li>valutazione dinamica di espressioni;</li> <li>breakpoint, anche condizionali;</li> <li>stack trace.</li> </ul> <p>Sono strumenti molto sofisticati, abituarsi al loro uso pu\u00f2 migliorare significativamente la produttivit\u00e0 nella programmazione.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#compilazione-per-il-debug","title":"Compilazione per il debug","text":"<p>Un debugger ha bisogno di informazioni aggiuntive nel codice compilato, link tra il codice compilato e il codice sorgente.</p> <p>Per stabilire la corrispondenza tra codice compilato e codice sorgente, la compilazione per il debug non deve essere ottimizzata.</p> <p>Due modalit\u00e0 di compilazione:</p> <ul> <li>Debug, meno efficiente, per il debug;</li> <li>Release, Ottimizzata.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#esecuzione-passo-passo","title":"Esecuzione passo-passo","text":"<p>Il debugger consente di eseguire il programma un'istruzione alla volta. Al termine dell'esecuzione di una istruzione, il controllo passa al debugger, che pu\u00f2 visualizzare lo stato della macchina (variabili, stack, etc.).</p> <p>Per velocizzare il processo di debugging, si pu\u00f2 optare per eseguire il programma fino a un'istruzione specifica, segnalata da un breakpoint.</p> Nome Descrizione Step into Esegue l'istruzione corrente, e procede all'istruzione successiva che sar\u00e0 effettivamente eseguita Step over Esegue l'istruzione corrente, trattando le routine come istruzioni primitive Step return continua l'esecuzione fino al termine della procedura"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#step-into","title":"Step Into","text":"Stato iniziale<pre><code>int i;\nfor (i = 0; i &lt; b; i++) {\nresult = sum(result, a);\n}\n</code></pre> Step into<pre><code>int sum(int a, int b) {\nif (b == 0) {\nreturn a;\n} else if (b &gt; 0) {\nreturn a + b;\n}\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#step-over","title":"Step over","text":"Stato iniziale<pre><code>int i;\nfor (i = 0; i &lt; b; i++) {\nresult = sum(result, a);\n}\n</code></pre> Step over<pre><code>int i;\nfor (i = 0; i &lt; b; i++) {\nresult = sum(result, a);\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#step-return","title":"Step return","text":"Passo iniziale<pre><code>int product(int a, int b) {\nif (b == 0) {\nreturn 0;\n} else if (b &gt; 0) {\nint result = 0;\nint a;\nfor (int i = 0; i &lt; b; i++) {\nresult = sum(result, a);\n}\nreturn result;\n} else {\nreturn product(a, b);\n}\n}\n</code></pre> Step return<pre><code>int factorial(int n) {\n// printf(\"%d \", n);\nreturn /* ... */;\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#informazioni-di-debug","title":"Informazioni di debug","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#variabili","title":"Variabili","text":"<p>Le variabili visibili nell'ambito dell'istruzione corrente sono visualizzate:</p> <ul> <li>Nome, tipo, valore.</li> </ul> <p>Le variabili che cambiano valore sono evidenziate.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#espressioni","title":"Espressioni","text":"<p>Un'espressione \u00e8 un pezzo ben formato di codice (snippet) che pu\u00f2 essere valutato per produrre un risultato.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#stack-trace","title":"Stack trace","text":"<p>Visualizza la pila delle chiamate, Si pu\u00f2 selezionare un elemento della pila per conoscerne lo stato corrente.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#breakpoint","title":"Breakpoint","text":"<p>Un breakpoint interrompe il flusso di esecuzione su una linea selezionata</p> <ul> <li>i breakpoint possono essere inseriti o rimossi;</li> <li>i breakpoint inseriti possono essere attivati o disattivati.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#resume-terminate","title":"Resume &amp; Terminate","text":"<ul> <li>Resume: esegue le istruzioni fino al prossimo breakpoint oppure al termine del   programma;</li> <li>Terminate: interrompe l'esecuzione del programma. Utile quando:<ul> <li>il programma va in loop infinito;</li> <li>si scova un programma.</li> </ul> </li> </ul> <p>Attenzione: i programmi non terminati rimangono in esecuzione per il sistema operativo:</p> <ul> <li>occupazione inutile di memoria;</li> <li>problemi per la ricompilazione.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/00_test_debugging/#breakpoint-condizionali","title":"Breakpoint condizionali","text":"<p>I breakpoint possono interrompere l'esecuzione solo quando una condizione diventa vera. Condizione: espressione booleana.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-02-2023/","title":"Appunti del 02-03-2023","text":"<p>fabbattista@gmail.com manda nome cognome email</p> <p>mercoled\u00ec esercitazione, gioved\u00ec lezione.</p> <p>consegne gruppo saranno solo numero assegnato da lui lol (sempre cartella compressa).</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-02-2023/#test-e-debugging","title":"Test e Debugging","text":"<p>sono due attivit\u00e0 diverse. la 2a avviene durante la scrittura del codice, la prima invece dopo la scrittura, si cercano errori.</p> <p>debugging non viene effettuato sistematicamente a differenza del testing.</p> <p>testing effettuato dopo stesura non per forza di tutto il programma, anche di una funzione o simili.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-02-2023/#i-bug","title":"i bug","text":"<p>erorri sintattici</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-02-2023/#testing-vs-debugging","title":"testing vs. debugging","text":"<p>testing verifica sistematica della corretteza di un software. debugging processoa tto a scovare la causa di un errore. testing parte prevalente nelle metodologie agili.</p> C<pre><code>int i = 0;\nchar s[MAX];\nwhile ((s[i] = fgetc(file)) != '\\n' &amp;&amp; i &lt; MAX - 1)\ni++;\ns[--i] = '\\0';\n</code></pre> <p>un caso limite \u00e8 che il file sia vuoto, un file che contiene + di MAX, un file senza alcun caratter</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-08-2023/","title":"Appunti del 08-03-2023","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-08-2023/#esercizio","title":"esercizio","text":"<p>relazzare pseudocodice di una funzione che riceve in input una matrice (contiene solo 0, 1, 2)</p> <p>n righe m colonne</p> <p>righe giornate e colonne le squadre</p> Text Only<pre><code>  G/S A B C D\n   1  0 1 1 2\n   2  0 2 1 1\n   3  2 0 1 1\n</code></pre> <p>dove G \u00e8 giornata e S \u00e8 squadra.</p> <p>individuare capolista per ogni giornata</p> Text Only<pre><code>G1 D\nG2 B D\nG3 D\n</code></pre> <p>non conviene usare delle lettere per le giornate ma un numero, cos\u00ec diventa:</p> Text Only<pre><code>  G/S 1 2 3 4\n   1  0 1 1 2\n   2  0 2 1 1\n   3  2 0 1 1\n</code></pre> <p>come prima idea di soluzione ci si limita a scandire riga per riga (GxG). per ogni giornata devo calcolare punteggio di ogni squadra fino alla G esaminata</p> <p>Trovare i\u00ecvalore massimo dei punteggi calcolati.</p> <p>La base dell'algoritmo \u00e8 la seguente:</p> Text Only<pre><code>per ogni giornata\n    calcolare il punteggio di ogni squadra fino alla gioranta esaminata\n    trovare il valore massimo dei punteggi calcolati\n</code></pre> <p>il vv <code>LeCapolista</code> che conterr\u00e0 le squadre in testa \u00e8 un array a 1dim di int &gt; 0.</p> <p>si potrebbe</p> Text Only<pre><code>per ogni giornata\n    A = calcolare il punteggio di ogni squadra fino alla gioranta esaminata\n    LeCapolista = trovare i\u00ecvalore massimo dei punteggi calcolati\n</code></pre> <p>magari un nome migliore di A. A \u00e8 un array coi punteggi gi\u00e0 sommati per ogni squadra</p> <p>riscriviamo l'alg meglio</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-08-2023/#algoritmo-generale","title":"Algoritmo generale","text":"<p>INPUT:</p> <code>risultati</code> contiene i risultati di ogni squadra (sulle colonne) di tutte le giornate (righe) del campionato. I ris sono i valori 0, 1, 2. Array a 2dim di interi nell'intervallo \\([0,\\, 2]\\). <code>NumSquadre</code> numero di squadre che partecipano al campionato, intero maggiore di zero <code>NumGiornate</code> numero di giornate disputate, intero maggiore di 0 <p>OUTPUT:</p> <code>LeCapolista</code> contiene il nome delle squadre capolista di ogni giornata del campionato. Array a una dimensione di interi, 0 &lt; <code>LeCapolista</code> \u2264 <code>NumSquadre</code>. Ha dim pari a <code>NumGiornate</code>. <p>LAVORO:</p> <code>g</code> giornata <p>ALGORITMO:</p> Text Only<pre><code>g := 1\nMENTRE (q &lt;= NumGiornate)\n    ClassificaGiornata := CalcolareClassificaGiornata(\n        risultati, NumSquadre, NumGiornate, g\n    )\n    LeCapolista in posizione g := TrovareMassimo(\n        ClassificaGiornata, g, NumSquadre\n    )\n    g := g + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-08-2023/#trovaremassimo","title":"TrovareMassimo","text":"<p>INPUT:</p> <code>Classifica</code> punteggio di tutte le squadre, array a 1dimm di interi maggiori o uguali a zero. <code>Dimensione</code> numero di squadre che partecipano al campionato, intero maggiore di 1 <p>OUTPUT:</p> <code>Capolista</code> la squadra in testa al campionato, intero, 0 &lt; <code>Capolista</code> &lt;= <code>NumSquadre</code>. <p>LAVORO:</p> <code>i</code> contatore <p>ALGORITMO:</p> Text Only<pre><code>MAX := primo elemento di classifica\nCapolista := 1\ni := 2\nMENTRE (i &lt;= Dimensione)\n    SE (elemento di Classifica in posizione i &gt; MAX) ALLORA\n        MAX := elemento di Classifica in posizione i\n        Capolista := i\n    FINE\n    i := i + 1\nFINE\n</code></pre> <p>In questo caso se la prima squadra questo \u00e8 inutile. Aggiungendo Capolista := 1, si ovvia a questo errore.</p> <p>un appunto stilistico \u00e8 che la funzione \u00e8 generale, al posto di <code>Classifica</code> sarebbe meglio avere <code>InsiemeDiNumeri</code> ad esempio. L'algoritmo \u00e8 troppo legato a quello delle squadre, conviene slegarli. \u00c8 solo una questione di leggibilit\u00e0 etc.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-08-2023/#calcolareclassificagiornata","title":"CalcolareClassificaGiornata","text":"<p>INPUT:</p> <code>Risultati</code> come gi\u00e0 detto precedentemente. <code>NumGiornate</code> come sopra. <code>NumGiornate</code> come sopra. <code>Giornata</code> giornata in cui calcolare la classifica, intero, 0 &lt; <code>Giornata</code> &lt;= <code>NumGiornate</code>. <p>OUTPUT:</p> <code>ClassificaGiornata</code> contiene i punteggi delle squadre fino alla giornata <code>Giornata</code>. Array a 1dim di interi maggiori o uguali a zero. sar\u00e0 di dim <code>NumSquadre</code> (non ci serve per l'output). <p>LAVORO:</p> <p>boh</p> <p>ALGORITMO:</p> Text Only<pre><code>i := 1\nMENTRE (i &lt;= NumSquadre)\n    ClassificaGiornata in posizione i := SommarePunti(Risultati, i, Giornata)\n    i := i + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-08-2023/#sommarepunti","title":"SommarePunti","text":"<p>INPUT:</p> <code>Risultati</code> gi\u00e0 data <code>Squadra</code> squadra di cui si vuole calcolare il punteggio, intero 0 &lt; <code>Squadra</code> &lt;= <code>NumSquadre</code>. <code>Giornata</code> gi\u00e0 data <p>OUTPUT:</p> <code>Punti</code> punti ottenuti da sommare fino alla giornata <code>Giornata</code>, intero meggiore o uguale a zero, minore o uguale di <code>2 * Giornata</code>. <p>ALGORITMO:</p> Text Only<pre><code>Punti := 0\ni := 1\nMENTRE (i &lt;= Giornata)\n    Punti := Punti + elemento di risultato in posizione i e Squadra\n    i := i + 1\nFINE\n</code></pre> <p>Test su Valori Limite</p> <p>test per classi di equivalenza.</p> <p>VALIDI \\(]0,\\, \\text{NumGiornate}]\\)</p> <p>NON VALIDI \\(]-\\infty,\\, 0]\\), \\(]\\text{NumGiornate},\\, +\\infty[\\).</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/","title":"Appunti del 09-03-2023","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#programmazione-difensiva","title":"Programmazione difensiva","text":"<p>aggiunta codice per casi impossibili</p> C<pre><code>if (age &lt; 0 || age &gt; MAX_AGE) {\nrange = \"???\";\n} else if (age &lt;= 18) {\nrange = \"Teenager\";\n} // ...\n</code></pre> <p>non si pu\u00f2 assumere che i dati ricevuti in input dal programma siano corretti, il pi\u00f9 delle volte non lo sono. in questo modo, il programma si cautela da qualsiasi input venga inserito.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#controllo-dei-valore-di-errore-restituiti","title":"Controllo dei valore di errore restituiti","text":"<p>se una funzione restituisce dei valori di errore questi vanno verificati dal chiamante.</p> C<pre><code>range = num_to_range(age);\nif (strcmp(range, \"???\") == 0) {\n/* errore */\n// ...\n} else {\n// ...\n}\n</code></pre> <p>la funzione non deve preoccuparsi di scrivere all'utente che sia sbagliato, etc. riceve un numero e trova la categoria. le cose precedenti se le accolla la funzione chiamante. altrimenti la funzione chiamante far\u00e0 il suo normale lavoro.</p> <p>\u00c8 possibile che la funzione chiamante non gestisca direttamente l'errore ma restituisce un valore specifico e lo gestir\u00e0 un'altra funzione ancora.</p> <p>una funzione dovrebbe avere un solo compito e un solo output, cos\u00ec se sbaglia \u00e8 pi\u00f9 facile capire chi ha sbagliato e dove, rispettoa all'avere pi\u00f9 compiti per la stessa funzione.</p> <p>un solo compito = pi\u00f9 facile capire chi sbaglia.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#testing-sistematico","title":"Testing sistematico","text":"<ul> <li>verifica incrementale;</li> <li>verifica bottom-up (ha a che fare con pi\u00f9 di un'unit\u00e0);</li> <li>verifica dei risultati attesi (ha a che fare con pi\u00f9 di un'unit\u00e0);</li> <li>verifica della copertura: si incarica di vedere cosa c'\u00e8 dentro la funzione.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#verifica-dei-risultati-attesi","title":"Verifica dei risultati attesi","text":"<p>non prevede la conoscenza dell'algoritmo, anzi meglio se non la si conosce.</p> <p>per ogni test, occorre conoscere il risultato atteso.</p> <p>Ovvio per molti casi ma non per tutti.</p> <pre><code>stateDiagram-v2\n  direction LR\n  fx: f(x)\n  [*] --&gt; fx: 5\n  [*] --&gt; fx: -4\n  fx --&gt; [*]: errore</code></pre> <p>oppure</p> <pre><code>stateDiagram-v2\n  direction LR\n  fx: f(x)\n  [*] --&gt; fx: 7\n  [*] --&gt; fx: 5\n  fx --&gt; [*]: 12</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#verificare-la-copertura-dei-test","title":"Verificare la copertura dei test","text":"<p>test devono garantire ogni istr sia exe almeno una volta; then-else, tutti i casi si uno switch, exe dei cicli.</p> <p>Classi di equivalenza</p> <p>il test di copertura \u00e8 un po' pi\u00f9 complicato poich\u00e9 non si basa pi\u00f9 soltanto sulla conoscienza dei dati di input.</p> <p>la scelta deve essere tale da far attraversare al dato un ramo specifico, oppure un altro, in modo tale da verificare ogni possibilit\u00e0.</p> <p>es.</p> C<pre><code>A = 0;\nB = 5;\nif (A &gt; B) {\n/* then */\n} else {\n/* else */\n}\n</code></pre> <p>i percorsi sono due (then e else). all'aggiunta di un if raddoppiano. col l'aggiunta di un ciclo aumentano un sacco.</p> <p>non \u00e8 detto che ogni f debba essere testata con ogni tipo di test.</p> <p>se c'\u00e8 molta elaborazione conviene il test di copertura. raramente si hanno funzioni con sia molti input che molta elaborazione.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#cunit","title":"CUnit","text":"<p>cos'\u00e8 non lo richiede, gli interessa solo l'esito.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#unit-test","title":"Unit test","text":"<p>\u00e8 una tecnica di progetto e sviluppo software</p> <p>serve a ottenere evidenza che le singole unit\u00e0 SW siano corrette e pronte all'uso.</p> <p>si possono exe test su valori attesi in CUnit. dici cosa ti aspetti e lui ti dice se va bene o meno.</p> <p>si scrivono unit test rappresentanti una sorta di \"contratto scritto\" che la porzione di codice testata deve soddisfarre.</p> <p>la scocciatura di CUnit \u00e8 che bisogna trovare un altro progetto in cui si sostituisce il main in quello di CUnit e si lascia tutto il resto. Viene exe quel progetto, se ci sono errori la correzione va effettuata nel progretto principale.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#asserzioni-di-base-cunit","title":"Asserzioni di base CUnit","text":"Asserzione Significato <code>CU_ASSERT</code><code>CU_TEST</code> asserisce che expr \u00e8 TRUE <code>CU_ASSERT_TRUE</code> asserisce che il val \u00e8 TRUE <code>CU_ASSERT_FALSE</code> asserisce che il val \u00e8 FALSE <code>CU_ASSERT_EQUAL</code> asserisce che reale == atteso <code>CU_ASSERT_NOT_EQUAL</code> asserisce che reale != atteso <code>CU_ASSERT_STRING_EQUAL</code> asserisce che il val della str sia uguale <code>CU_ASSERT_STRING_NOT_EQUAL</code> asserisce il val della stringa \u00e8 diverso C<pre><code>void test_max(void) {\nCU_ASSERT_EQUAL(max(0, 2), 2);\nCU_ASSERT_TRUE(max(0, -2) == 0);\nCU_TEST(max())\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#ho-mancato-il-titolo","title":"ho mancato il titolo","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#procedure-e-funzioni","title":"Procedure e funzioni","text":"<p>istr non primitive per risolvere parti specifiche di un problema: sotto-programmi. (o metodi).</p> <p>realizzate mediante la def di unit\u00e0 programmata distinta dal prog principale (main).</p> <p>rappresentano nuove istr/op che agiscono sui dati utilizzati dal programma</p> <p>possono essere a uso personale o a uso generico (le possono usare tutti)</p> <p>sono definite a partire di una seq di istr primitive e altre procedure/func.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#definizione","title":"definizione","text":"<p>in questa fase si definisce:</p> <ul> <li>un identificatore del sottoprogramma (il nome dev'essere chiaro cos\u00ec nel   test fornisce un'indicazione rapida di ci\u00f2 che fa);</li> <li>corpo del sottoprogramma (stessa cosa, nome var significativi);</li> <li>lista di parametri formali.</li> </ul> funzioneprocedura <p>hanno output</p> C<pre><code>// prototipo\nint sum(int a, int b);\n// dichiarazione\nvoid sum(int, a, int b) {\nint c = a + b;\nreturn c;\n}\n// chiamata\nint sum(void) { // da continuare!\nint value;\n// ...\nprint(value);\n}\n</code></pre> <p>non hanno output</p> C<pre><code>// prototipo\nvoid print(int a);\n// dichiarazione\nvoid print(int, a) {\nprintf(\"%d\", a);\n}\n// chiamata\nint main(void) {\nint value;\n// ...\nprint(value);\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#parametri-formali-e-attuali","title":"Parametri formali e attuali","text":"formaliattuali <ul> <li>specificati nella def del sotto-programma</li> <li>sono in numero prefissato e ad ognuno di essi viene associato un tipo</li> <li>le istruzioni del corpo del sotto-programma utilizzano parametri formali</li> </ul> <p>sono i valori effettivamente forniti dall'unit\u00e0 chiamante al sotto-programma all'atto della invocazione.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-09-2023/#associazione-tra-parametri-formali-e-attuali","title":"Associazione tra parametri formali e attuali","text":"<p>il passaggio pu\u00f2 avvenire in due modi:</p> <ul> <li>per valore;</li> <li>per indirizzo o riferimento (+ avanti).</li> </ul> <p>il C di default adotta il passaggio per valore.</p> <ul> <li>val copiato nello stack;</li> <li>passaggio per riferimento si ottiene memorizzando nello stack l'indirizzo   in cui \u00e8 allocata una variabile;</li> <li>il passaggio per valore \u00e8 anche pi\u00f9 \"sicuro\".</li> </ul> <p>(test a copertura vedere codice, a valori attesi no)</p> <p>riesercitarsi sulle funzioni cos\u00ec dalla prox sett si \u00e8 in grado di scrivere il codice assegnato.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/","title":"Appunti del 16-03-2023","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#test-e-debugging-di-nuovo","title":"test e debugging (di nuovo)","text":"<p>test verifica sistematica della correttezza del SW.</p> <p>debugging atto a scovare la causa di un errore.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#supporto-del-compilatore","title":"supporto del compilatore","text":"<p>alcuni compilatori emettono dei warning, ovvero messaggi di avvertimento, spesso non bloccanti</p> <p>es.</p> C<pre><code>if (a = 0) {} // va messo ==\nx = x\n</code></pre> <p>altri esempi sono</p> <ul> <li>nessun return</li> <li>codice orfano</li> <li>condizioni tautologiche</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#backward-reasoning","title":"Backward reasoning","text":"<p>quando si scopre un bug occorre pensare al contrario, partendo dal risultato occorre risalire alla catena delle cause che l'hanno portato. Una delle cause della catena sar\u00e0 errata.</p> <p>scrivere codice leggibile aiuta al Backward reasoning e quindi a localizzare i bug. bisogna avere uno stile di scrittura ben definito.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#sviluppo-incrementale","title":"sviluppo incrementale","text":"<p>testare le procedure man mano che vengono sviluppate. se i test hanno successo all'istante \\(t\\) ma falliscono all'istante \\(t+1\\), allora molto probabilmente i bug si annidano nel codice sviluppato tra \\(t\\) e \\(t + 1\\).</p> <p>la progettazione modulare del codice aiuta a individuare meglio la posizione dei bug.</p> <p>questo \u00e8 pi\u00f9 efficiente poich\u00e9 oltre al poter mostrare subito al cliente un eventuale prototipo. \u00e8 vantaggioso per lo sviluppo poich\u00e9 ho un pezzo funzionante che viene messo da parte poich\u00e9 funziona e non viene pi\u00f9 toccato. per di pi\u00f9 testare 2/2 funzioni occupa meno tempo che testarne molte di pi\u00f9.</p> <ul> <li>esaminare codice simile;</li> <li>non rimandare il debugging: se bug individuato allora elimina subito.   trasferimento di un bug nei passi successivi del ciclo di sviluppo di un   software fa crescere il costo di debugging;</li> <li>leggere e spiegare il codice: leggere codice e comprenderne il significato. il   codice \u00e8 un pezzo di conoscenza che deve essere compreso dalla macchina e da   chi la programma. spiegare il codice ad altri aiuta a ridurre \"bias\" cognitivi;</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#rendere-riproducibile-un-bug","title":"rendere riproducibile un bug","text":"<p>individuare le tutte le condizioni che portano alla manifestazione del bug come input e altri parametri, condizioni della macchina, seed di numeri casuali, etc.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#divide-et-impera","title":"divide et impera","text":"<p>individuare le condizioni minimali che rendono manifesto un bug. es. il pi\u00f9 piccolo array, la str pi\u00f9 breve il test dei casi limite \u00e8 fondamentale.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#ricerca-di-regolaita","title":"ricerca di regolait\u00e0","text":"<p>alcuni bug si presentano con regolarit\u00e0, ma non sempre. il questo caso occorre il modello (\"pattern\") che genera la regolarit\u00e0.</p> <p>es. editor di testo salta la visualizzazione di alcuni caratteri, l'analisi del testo mostra che i caratteri saltati sono intervallati da 1023 char stampati. gli array che memorizzano le stringhe sono da 1024byte ovvero 1023 caratteri pi\u00f9 il <code>\\0</code> \u2192 BUG.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#stampe-ausiliarie","title":"stampe ausiliarie","text":"<p>per segure l'exe di un programma pu\u00f2 essere utile introdurre stampe ausiliarie valido soprattutto per situazioni che non possono essere traccaite da debugger</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#altre-tecniche","title":"altre tecniche","text":"<ul> <li>visualizzazioni grafiche</li> <li>test statistici</li> <li>strumenti di analisi del testo come<ul> <li>grep</li> <li>diff</li> </ul> </li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#debugger","title":"debugger","text":"<p>un debugger guarda \"dentro\" il programma durante l'exe</p> <ul> <li>tracing del programma</li> <li>visualizzazione del contenuto delle varaibili</li> <li>valutazione dinamica di espressioni</li> <li>ha cambiato slide</li> </ul> <p>un debugger ha bisogno di informazioni aggiuntive nel codice compilato, c'\u00e8 un link tra il codice compilato ...</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#breakpoint","title":"breakpoint","text":"<p>un breakpoint interrompe i\u00ecflusso di exe su una linea selezionata. possono essere inseriti o rimossi e quelli inseriti possono essere attivati o disattivati.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-16-2023/#categorie-progetto","title":"categorie progetto","text":"<ol> <li>gestione di qualcosa</li> <li>gioco (mastermind, oca, battaglia navale)</li> <li>funzioni di sistema operativo (vecchi/semplici/editor di testo    (ancora pi\u00f9 semplice del notepad, EDLIN/EDIT)/operazioni che hanno a che fare    col MS-DOS)</li> <li>c robots (no)</li> </ol> <p>suggerimenti degli anni passati, si possono proporre altre.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/","title":"Appunti del 23/03/23","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#stili-di-programmazione","title":"Stili di programmazione","text":"<p>bisogna rispettare lo stile altrimenti lui non lo legge</p> <ol> <li>serve a far in modo che la struttura del codice sia sempre la stessa</li> <li>quello che viene scritto sia coerente (coerenza tra descrizione delle soluzioni)</li> </ol> <p>se soluzione non rispetta lo stile, viene ignorata.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#cose-da-rispettare","title":"Cose da rispettare","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#nomi-variabili","title":"Nomi variabili","text":"<p>no nomi qualunque. il nome deve permettere di capire subito cos'\u00e8 l'oggetto. no singola lettera, no che dice altro rispetto a ci\u00f2 che fa. deve chiarire subito che tipo di dato \u00e8. deve essere breve, facile da ricordare ma deve dare le informazioni necessarie. se il nome ha ampia portata (usato in tutto il progetto) deve essere pi\u00f9 che significativo. la singola lettera pu\u00f2 andare bene per dati locali in piccole funzioni. se parliamo del main o di una var semiglobale no. nomi generici come vettore, array, vec non vanno bene.</p> <p>ogni lettera ha un suo uso</p> <ul> <li><code>i</code>, <code>j</code>, <code>k</code> come indici;</li> <li><code>n</code>, <code>m</code> per gli interi;</li> <li><code>p</code>, <code>q</code> per i puntatori;</li> <li><code>s</code>, <code>t</code> per le stringhe;</li> <li><code>c</code> per i caratteri.</li> </ul> <p>le variabili dichiarate nel main o variabili globali, la singola lettera non va bene.</p> <p>ripete la scelta del nome \u00e8 importante ma non bisogna esagerare.</p> <p>se si sceglie una costante il nome sar\u00e0 scritto tutto in maiuscolo es <code>COSTANTE</code>, una variabile in minuscolo es. <code>variabile</code> se serve un'altra parola <code>variabile_attiva</code> altrimenti camelCase <code>variabileAttiva</code>. le costanti non sono mai locali ad una funzione, succede molto raramente. per questo motivo non vanno bene costanti a una lettera. vanno bene solo ed esclusivamente nel casi un cui la variabile abbia un nome ad una lettera e sia universalmente riconosciuta.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#nomi-funzioni","title":"Nomi funzioni","text":"<p>se due func sono correlate o simili i nomi devono evidenziare questa cosa. se c'\u00e8 possibilit\u00e0 di confusione i nomi devono essere il pi\u00f9 diversi possibili.</p> <p>se es. il tipo di dato \u00e8 orario e c'\u00e8 una fun che cambia l'orario, la parola orario va trovata in ogni nome correlato.</p> <p>es. eliminare articoli, proposizioni e quant'altro.</p> <p>verbo che dichiari l'azione della funzione e oggetto su cui la esegue.</p> <p>se si ha una funzione che fa molte cose, questa funzione come va chiamata? leggi e controlla bla bla? non va bene, va riscritta. verbo all'infinito. se func \u00e8 bool is+aggettivo es <code>isPalindrome()</code>. l'importante \u00e8 scrivere tutto in una lingua o inglese o italiano. non inventare parole. nomi sono +. <p>per le func stessa cosa, es. <code>funzione_principale()</code> oppure <code>funzionePrincipale()</code> quindi o snake_case o camelCase.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#operatori","title":"Operatori (?)","text":"<p>vanno usati gli spazi es NO <code>i=i+1;</code> ma <code>i = i + 1;</code> o ancora <code>A &gt; B</code>. anche se non si vuole alterare la precedenza degli operatori, usare le parentesi per rendere pi\u00f9 facile la lettura del codice.</p> <p>cercare di scrivere le expr booleane in modo pi\u00f9 naturale possibile, come se si stesse pronunciando la stessa. es <code>A + 1 &gt; 0</code> \u00e8 corretta me \u00e8 meglio scrivere <code>A &gt; -1</code>. se bisogna verificare se un un numero \u00e8 maggiore di zero si scrive <code>A &gt; 0</code> e non <code>!(A &lt;= 0)</code></p> <ol> <li><code>if (!(a == 0) || !(b == 0))</code> \u2013 errato;</li> <li><code>if !((a == 0) &amp;&amp; (b == 0))</code> \u2013 errato;</li> <li><code>if ((a != 0) || (b != 0))</code> \u2013 corretto.</li> </ol> <p>non c'\u00e8 motivo di scrivere nei primi due modi.</p> <p>bisogna cercare di raggruppare il pi\u00f9 possibile i pezzetti logici anche se si vuole rispettare l'ordine di precedenza.</p> <p>es. <code>leap_year = y % 4 == 0 &amp;&amp; y % 100 != 0 || y % 400 == 0</code> \u00e8 scritto senza usare alcuna parentsi. \u00e8 un controllo per l'anno bisestile, sarebbe meglio scrivere <code>leap_year = (y % 4 == 0) &amp;&amp; (y % 100 != 0) || (y % 400 == 0)</code>, si potrebbe anche dividere in tre sottoespressioni differenti e in alcuni casi \u00e8 anche meglio.</p> <p>una forma che fornisce il C \u00e8 la seguente: <code>&lt;cond&gt; ? &lt;then&gt; : &lt;else&gt;</code>, dunque si pu\u00f2 scrivere <code>variabile = &lt;cond&gt; ? &lt;then&gt; : &lt;else&gt;;</code> \u00e8 difficile da leggere e sarebbe meglio scrivere:</p> C<pre><code>if (cond) {\nvariabile = ...;\n} else {\nvariabile = ...;\n}\n</code></pre> <p>il costrutto precedente permette di annidare le condizioni</p> C<pre><code>variabile = cond ? cond ? cond ? cond ? then : else;\n</code></pre> <p>il C permette di scrivere</p> C<pre><code>if (cond)\nazione;\nelse\nazione;\n</code></pre> <p>ma \u00e8 meglio non usarla</p> C<pre><code>if (cond) {\nazione;\n} else {\nazione;\n}\n</code></pre> <ol> <li>si potrebbe dover aggiungere altre condizioni in futuro</li> <li>evita problemi di capire a chi appartiene cosa.</li> </ol> <p>per evitare di avere un'indentazione eccessiva con gli <code>else..if</code> si pu\u00f2 scriverli sulla stessa riga</p> C<pre><code>if (cond) {\nazione;\n} else if (cond) {\nazione;\n} else if (cond) {\nazione;\n}\n</code></pre> <p>la posizione delle graffe va messa dopo la condizione</p> C<pre><code>if /* while/do */ (condizione) {\nazione;\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#numeri-magici","title":"Numeri magici","text":"<p>tutti i numeri che appaiono nel programma, eccetto 0/1, sono detti numeri magici. bisogna evitare di scrivere valori del tipo <code>if (a &gt; 10)</code> perch\u00e9 10 \u00e8 un numero magico, che rappresenta 10? I valori devono essere contestualizzati, si crea una costante che abbia come nome cosa rappresenta il numero.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#commenti","title":"Commenti","text":"<p>non vanno messi commenti inutili es. che duplicano quello che gi\u00e0 dice il codice. vanno usati per parti di codice che vanno spiegate, oppure per delimitare porzioni di codice. se il codice \u00e8 comprensibile es.</p> C<pre><code>if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {\nazione;\n}\n</code></pre> <p>\u00e8 inutile spiegare la condizione, \u00e8 gi\u00e0 chiaro.</p> <p>se si utilizzano formule o altro presi da altre fonti, sarebbe meglio linkare queste fonti o con un url, nome del libro, etc.</p> <p>Alcune cose vanno spiegate sempre, ovvero le funzioni. ogni funzione ha un blocco di commenti che spiega cosa fa la funzione e ogni param di input e ogni param di output. ci sono sistemi che permettono di documentare automaticamente il codice utilizzando questi commendi (Doxygen). se non si riesce a spiegare una funzione, sarebbe meglio spezzarla in pi\u00f9 funzioni differenti.</p> <p>I commenti vanno aggiornati assieme al codice.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-23-2023/#esercizio","title":"Esercizio","text":"<p>rivedere l'esercizio di ieri in funzione di ci\u00f2 che \u00e8 stato detto oggi.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-29-2023/","title":"Appunti del 29/03/2023","text":"<p>num giocatori da 2 a 6, anche 4</p> <p>tabella min 40, max 90 caselle. che sia a spirale \u00e8 ininfluente, forma non importante.</p> <p>ogni giocatore deve avere un id (pedina). si potrebbe fare che ogni giocatore si da il proprio simbolo, per\u00f2 lui non consiglia.</p> <p>facciamo decidere a caso chi inizia a giocare e non al pi\u00f9 giovane. il programma stabilisce l'ordine.</p> <p>per i dadi bisogna fare una f che generi 2 num casuali tra 1 e 6.</p> <p>in base alla lunghezza del percorso si stabilisce quali caselle particolari ci sono.</p> <p>le caselle speciali indicate sono messe in quelle posizioni, se la len del tabellone cambia anche queste pos devono adattarsi.</p> <p>la casella finale va \"centrata\" altrimenti si retrocede.</p> <p>il gioco fornisce delle scelte di default (es. 2 gioc, 90 caselle di default) se si acecttano quelle di default parte il game, altrimenti le cambia e poi parte il game. inizia nuova partita, impostazioni.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-29-2023/#impostazioni","title":"Impostazioni","text":"<ul> <li>n giocatori: 2 &lt;= n &lt;= 4 (ma decidiamo noi)</li> <li>len percorso: 40 &lt;= len &lt;= 90 (ma decidiamo noi)</li> <li>pos caselle particolari (sia oca che non): non viene scelto dal player, per\u00f2   \u00e8 dipendente dalla len del percorso.</li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-29-2023/#schermate","title":"Schermate","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-29-2023/#logo","title":"Logo","text":"<p>come schermata 0 logo (facoltativo)</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-29-2023/#prima-schermata","title":"Prima schermata","text":"<p>prima schermata il men\u00f9 principale</p> <ol> <li>nuova partita;</li> <li>carica partita (le impostazioni sono state gi\u00e0 date in precedenza);</li> <li>aiuto;</li> <li>classifica (in dubbio, dobbiamo decidere noi, va stabilito criterio);</li> <li>fine.</li> </ol> <p>criterio pu\u00f2 essere legato al numero di lanci, o un'altra cosa. la classifica serve a manipolare i file di testo, scriverci e poi aggiornarli. (decidiamo noi).</p> <p>altri valori verranno ignorati. implementazione irrilevante, basta che si abbiano queste impostazioni.</p> <p>men\u00f9 nuova partita</p> <ol> <li>inizia partita;</li> <li>salva partita;</li> <li>abbandona partita;</li> <li>esci (men\u00f9 principale).</li> </ol> <p>implementazione come meglio si crede ma player deve poter accedere sempre a questo men\u00f9. l'ha messo in men\u00f9 ma non \u00e8 proprio un men\u00f9.</p> <p>per il carica partita, non \u00e8 proprio un men\u00f9. se ci sono pi\u00f9 partita bisogna poter sapere quale scegliere. se si salva solo l'ultima partita, si mostra l'ultima partita salvata. suggerisce max 10 partite salvate. escono tutte le partite salvate e se ne sceglie una. DEVE essere presente l'opzione esci per tornare al men\u00f9 principale. se c'\u00e8 n'\u00e8 una sola di salvata, carica partita deve caricare direttamente la partita.</p> <p>l'importante \u00e8 che le scelte iniziali siano uguali per tutti.</p> <p>per quanto riguarda l'aiuto.</p> <p>men\u00f9 aiuto</p> <ol> <li>regole del gioco;</li> <li>manuale del gioco.</li> <li>esci</li> </ol> <p>men\u00f9 aiuto \u00e8 un file di testo che non cambia, men\u00f9 carica e nuova partita sono file binari.</p> <p>il gioco \u00e8 semplice, l'obiettivo \u00e8 realizzare un proj che abbia delle caratteristiche.</p> <p>avremo dei moduli che costituiscono il progetto. non \u00e8 un sorgente unico. ci saranno da fare i test. si deve adottare uno stile di programmazione che sia quello dato. non \u00e8 necessario andare oltre il testuale.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/","title":"Appunti del 30/03/2023","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/#stile-di-programmazione","title":"Stile di programmazione","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/#kr-coding-style","title":"K&amp;R coding style","text":"<p>Kernigan &amp; Richie</p> <p>Prevedevano 4/8 spazi per l'indentazione per evitare l'annidamento eccessivo. Troppo annidamento \u00e8 in genere segnale di cattiva progettazione.</p> C<pre><code>int compare(int x, int y) {\nif (x &lt; y) {\nreturn -1;\n} else if (x &gt; y) {\nreturn 1;\n} else {\nreturn 0;\n}\n}\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/#modularizzazione-e-strutturaione-dei-programmi-dei-files","title":"Modularizzazione e strutturaione dei programmi dei files","text":"<p>bisogna prima definire le interfacce tra i moduli.</p> <p>ci\u00f2 che succede nel modulo 1 non interessa al modulo 2. ci\u00f2 che conta \u00e8 sapere che ricever\u00e0 quella struttura dati A organizzata in quel modo. questa \u00e8 l'indipendenza.</p> <p>la suddivisione in moduli va pensata ovviamente. bisogna quindi pensare quali saranno i moduli indipendenti da creare.</p> <p>obv prima in pseudo e poi in C.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/#programmazione-in-grande","title":"Programmazione in grande","text":"<p>riguarda i programmi costituiti da pi\u00f9 moduli, ovvero pi\u00f9 files/librerie/altro. il file C non \u00e8 un file singolo ma ce ne saranno di pi\u00f9. bisgona individuare la struttura migliore che permetta di mantenere la struttura che garantisca leggibilit\u00e0, modificabilit\u00e0 e correttezza.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/#progetto-modulare","title":"Progetto modulare","text":"<p>\u00e8 un insieme di moduli separati ma cooperanti tra loro secondo l'architettura del sistema sotfware.</p> <p>modulo: interfaccia e implementazione.</p> <p>interfaccia:</p> <ul> <li>le risorse esportate dal modulo</li> <li>\u00e8 la parte pubblica, ovvero il \"cosa\". definisce cosa fa il modulo</li> <li>\u00e8 il file header <code>.h</code></li> </ul> <p>implementazione (o corpo)</p> <ul> <li>meccanismi che realizzano le funzioni</li> <li>parte \"privata\", ossia il \"come\"</li> <li>chi utilizza il modulo non deve sapere il come ma solo il cosa.</li> <li>\u00e8 il file sorgente <code>.c</code></li> </ul> <p>dunque <code>modulo1.h</code> e <code>modulo1.c</code> costituiscono un modulo. In <code>modulo1</code>.h si mettono tutte le intestazioni di tutte le funzioni o varaibili che si vuole che vengano utilizzate. nel <code>modulo1.c</code> si mette tutto, corpo e tutto il resto che sia pubblico o privato.</p> <p>ad esempio</p> mat.h<pre><code>int somma(int a, int b);\nint prodotto(int, int);\n</code></pre> mat.c<pre><code>int somma(int a, int b) { return a + b; }\nint prodotto(int a, int b) { return a * b; }\n</code></pre>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/#cosa-contiene-un-header","title":"Cosa contiene un header","text":"<p>dichiarazioni dei metori da implementare, dette forward reference</p> <p>variabili, dette variabili extern ossia var pubbliche definite in altri moduli.</p> <p>costanti definite con la direttiva <code>#define</code></p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/03-30-2023/#vantaggi-della-programmazione-modulare","title":"Vantaggi della programmazione modulare","text":"<p>team di programmatori possono lavorare sui programmi.</p> <p>ogni file definisce un particolare tipo di oggetto come un tipo di dati e di operazioni su tale oggetto.</p> <p>separare la dichiarazione del modulo dalla sua implementazione rende un programma ben strutturato e di facile manutenzione.</p> <p>un file pu\u00f2 mantenere tutte le funzioni/operazioni su matrici ed essere usato da un prog di biblioteca.</p> <p>\u00e8 buona pratica iniziare un file <code>.h</code> con il seguente blocco per evitare inclusioni multiple</p> example.h<pre><code>#ifndef EXAMPLE_H\n#define EXAMPLE_H\n// corpo di example.h\n#endif /* ifndef EXAMPLE_H */\n</code></pre> <p>\u00e8 un grave errore quello di scrivere codice in un file <code>.h</code> e poi includerlo nel file <code>.c</code>.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/04-20-2023/","title":"Appunti del 20/04/2023","text":"<p>si parlava ieri di avere un modulo di funzioni globali, il raggruppamento non \u00e8 presente e andrebbe evitato in generale.</p> <p>non ci sono funzioni globali, quindi niente moduli del genere.</p> <p>inizia partita inizia partita, anche se in game. salva partita, salva la partita corrente senza tornare al men\u00f9 principale. abbandona partita, la partita corrente viene abbandonata senza salvare tornando al men\u00f9 principale, se ho salvato la partita rimane. esci fa tornare al men\u00f9 precedente e deve essere presente in qualsiasi men\u00f9. \u00e8 una sorta di indietro.</p> <p>indietro deve essere presente anche nei sottomen\u00f9 perch\u00e9 devo poter tornare indietro se ho cliccato una voce per errore.</p> <p>se le regole del gioco sono presentate su pi\u00f9 pagine, allora deve essere presente l'indietro per ogni singola pagina.</p> Men\u00f9<pre><code>MAIN MEN\u00d9\n[n]ew game\n[s]aved games\n[h]elp\n[l]eaderboard\n[q]uit.\n\nPAUSE MEN\u00d9\n[s]ave game\n[l]eave game\ngo [b]ack\n\nNEW GAME MEN\u00d9 (chiede conferma prima di partire)\nscegli num giocatori\nscegli num caselle\ngo [b]ack\n\nSAVED GAMES MEN\u00d9\nmostra file e chiedi quale\ngo [b]ack\n\nHELP MEN\u00d9\n[m]anual\n[r]ules\ngo [b]ack\n\nLEADERBOARD\nstampa classifica\ngo [b]ack\n</code></pre> <p>prossima consegna:</p> <ol> <li>dire che moduli servono e cosa fanno. nome+funzione del modulo.</li> <li>pseudocodice relativo a tutte le funzioni del gioco vero e proprio (si    riconsegnano anche le vecchie), tutto ci\u00f2 che riguarda una partita    dall'inizio alla fine. generazione e stampa percorso, lancio dadi, etc.</li> </ol> <p>no pseudo generazione di un numero casuale, per\u00f2 si da un nome suo</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/04-26-2023/","title":"Appunti del 26/04/2023","text":""},{"location":"Anno_I/Laboratorio_di_Informatica/notes/05-10-23/","title":"Appunti del 10/05/2023","text":"<ul> <li>Appunti del 10/05/2023</li> <li>Algoritmi di ricerca<ul> <li>lineare</li> <li>binaria</li> </ul> </li> <li>Algoritmi di ordinamento<ul> <li>Selection sort</li> </ul> </li> </ul>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/05-10-23/#algoritmi-di-ricerca","title":"Algoritmi di ricerca","text":"<p>analizziamo due tipi, binaria e lineare o esaustiva.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/05-10-23/#lineare","title":"lineare","text":"Text Only<pre><code>trovato := 0\ni := 0\nESEGUI\n  SE (elemento in posizione i di a = x)\n    ALLORA trovato := 1\n  FINE\n  i := i + 1\nFINCH\u00c9 (trovato = 0 AND i &lt; n)\nFINE\n</code></pre> <p>L'efficienza indica quanto l'algoritmo sia \"buono\" a cercare.</p> Indice iniziale Numero di confronti 0 1 1 2 2 3 ... ... n-1 n <p>con n numero di elementi dell'insieme.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/05-10-23/#binaria","title":"binaria","text":"<p>SOLO se l'insieme di partenza \u00e8 ordinato.</p> <p>confrontare valore x con elmeneto a[m] del vv a. se non sono uguali, ripetere con la parte di vettore a destra o sinistra dell'elemento centrale, in base al confronto.</p> Text Only<pre><code>trovato := 0\ninf, sup inizializzati\nMENTRE (inf &lt;= sup) AND (trovato = 0)\n  m := parte_intera((inf + sup) / 2)\n  SE (a &gt; elemento in posizione m di a)\n    ALLORA inf := m + 1\n    ALTRIMENTI SE (x &lt; elemento in posizione m di a)\n      ALLORA trovato := 1\n    FINE\n  FINE\nFINE\n</code></pre> Passi Numero elementi 1 n = n/2^0 2 n/2 = n/2^1 <p>la complessit\u00e0 \u00e8 logaritmica \u00e8 pi\u00f9 bassa della lineare. n = 2^(k-1), k = log_2 n+1</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/05-10-23/#algoritmi-di-ordinamento","title":"Algoritmi di ordinamento","text":"<p>prendere insieme di partenza ma restituirlo in ordine.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/05-10-23/#selection-sort","title":"Selection sort","text":"<p>a ogni passo k cerca la posizione del minimo e scambia il cal minimo con a[k].</p> <p>se il vettore fosse gi\u00e0 ordinato, avremmo comunque lo stesso numero di confronti. per ottenere complessit\u00e0 inferiori bisogna fare supposizioni sull'insieme di partenza.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/consegna0/","title":"Correzione della prima consegna","text":"<p>1o il percorso \u00e8 un array a una dimensione, non di pi\u00f9.</p> <p>2a cosa i nomi dei file che non rispettano le indicazioni del primo semestre.</p> <p>3o errore comune, moltissimi hanno ignorato le indicazioni sullo stile di programmazione. vanno seguite le indicazioni.</p> <p>4o errore, parecchi usano simboli o nomi di funzioni del C nello pseudocodice.</p>"},{"location":"Anno_I/Laboratorio_di_Informatica/notes/consegna0/#correzione-gruppo-11","title":"Correzione gruppo 11","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/","title":"Linguaggi di Programmazione","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/#informazioni-generali","title":"Informazioni generali","text":"<ul> <li>Insegnamento: Linguaggi di Programmazione (corso A)</li> <li>Docente: Giovanni Semeraro</li> <li>Cultori della materia/Supporto didattico: C. Musto, M. Polignano, Luigi   Quaranta</li> <li>Ricevimento (previa prenotazione per email): Marted\u00ec h. 16:00-19:00 (\u2105   ufficio 757 piano 7 DIB)</li> <li>Email: giovanni.semeraro@uniba.it</li> </ul> <p>Consultare https://www.uniba.it/docenti/semeraro-giovanni/attivita-didattica</p> <p>Piattaforma e-learning ADA https://elearning.di.uniba.it/.</p> <p>Codice Iscrizione al corso: lingprog1920.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#prove-desame","title":"Prove d\u2019esame","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/#prova-scritta","title":"Prova scritta","text":"<p>La prova scritta prevede:</p> <ul> <li>esecuzione di esercizi sulla teoria dei linguaggi formali;</li> <li>enunciazione di definizioni;</li> <li>dimostrazione di teoremi della teoria dei linguaggi formali;</li> <li>quesiti su linguaggi di programmazione e compilatori.</li> </ul> <p>La prova scritta intermedia:</p> <ul> <li>durante l\u2019interruzione prevista da manifesto;</li> <li>stessi argomenti delle prove d'appello.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#organizzazione-e-valutazione-prove-desame","title":"Organizzazione e valutazione prove d\u2019esame","text":"<p>La valutazione sar\u00e0 in trentesimi e si supera con una valutazione minima di 18.</p> <p>Prova intermedia</p> <ul> <li>Valutazione in trentesimi</li> <li>Si supera con un minimo di 16</li> <li> <p>Esonera dallo svolgimento di una parte della prova finale, LIMITATAMENTE AL   PRIMO APPELLO DI GIUGNO</p> </li> <li> <p>Valutazione COMPLESSIVA = media delle valutazioni delle due prove (itinere +   primo appello giugno)</p> </li> </ul> <pre><code>IF (valutazione COMPLESSIVA &gt;= 18) THEN\n    esame_superato\n</code></pre>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#programma-dellinsegnamento","title":"Programma dell\u2019insegnamento","text":"<ul> <li> <p>Tempi</p> <ul> <li>56 ore di lezioni frontali equivalenti a 7 crediti T1</li> <li>30 ore di esercitazioni equivalenti a 2 crediti T2</li> <li>119 ore di studio individuale</li> <li>Totale crediti 9 (7 T1 + 2 T2)</li> </ul> </li> <li> <p>Pre-requisiti</p> <ul> <li>Matematica discreta.</li> <li>Programmazione.</li> <li>Conoscenza del linguaggio C.</li> </ul> </li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#programma-preliminare-dellinsegnamento","title":"Programma preliminare dell\u2019insegnamento","text":"<p>https://tinyurl.com/y4ypuvhp</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#obiettivi-formativi","title":"Obiettivi formativi","text":"<p>Fornire gli strumenti fondamentali, formali e pratici, per la definizione di linguaggi di programmazione (linguaggi formali) e la progettazione dei loro traduttori.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#strutturazione-del-corso","title":"Strutturazione del corso","text":"<p>Si illustrano gli aspetti pi\u00f9 significativi dei linguaggi di programmazione, la loro evoluzione ed i concetti che stanno alla base della traduzione dei linguaggi di alto livello.</p> <p>Si forniscono i concetti pi\u00f9 significativi della teoria dei linguaggi formali, enfatizzando gli aspetti generativi e riconoscitivi dei linguaggi formali.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#obiettivi-professionalizzanti","title":"Obiettivi professionalizzanti","text":"<ul> <li>Comprensione profonda dei linguaggi di programmazione e dei principali   paradigmi di programmazione;</li> <li>Conoscenza delle tecniche di analisi e traduzione dei linguaggi di programmazione;</li> <li>Conoscenza delle espressioni regolari e delle grammatiche.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#testi-consigliati","title":"Testi consigliati","text":"<ul> <li>Semeraro, G., Elementi di Teoria dei Linguaggi Formali, ilmiolibro.it, 2017.   (http://ilmiolibro.kataweb.it/libro/informatica-e-internet/317883/elementi-di-teoria-dei-linguaggi-formali/);</li> <li>Maurizio Gabbrielli, Simone Martini, Linguaggi di Programmazione, Principi e   paradigmi. 2\u00b0 ed., McGraw-Hill, 2011;</li> <li>Deitel, H.M., and Deitel, P.J., C: Corso Completo di Programmazione, Apogeo, 2000;</li> <li>Dispense del corso</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/#altri","title":"Altri","text":"<ul> <li>Hopcroft, Motwani, Ullman, Automi, linguaggi e calcolabilit\u00e0. Addison-Wesley,   2009;</li> <li>Aho, A. V., Sethi, R., and Ullman, J. D., Compilers, Principles, Techniques   and Tools, Addison-Wesley, 1988;</li> <li>Zarrella, J., Concetti dei Linguaggi di Programmazione, Scienze Tecnologiche   Informatiche, Franco Angeli, 1989;</li> <li>Sethi, R., Linguaggi di Programmazione, Zanichelli, 1994.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/","title":"Introduzione ai linguaggi di programmazione","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#apprendimento-di-un-linguaggio-di-programmazione","title":"Apprendimento di un linguaggio di programmazione","text":"<p>Una delle competenze fondamentali di un buon informatico \u00e8 quella di apprendere un nuovo linguaggio di programmazione con naturalezza e velocit\u00e0. Questa competenza non la si acquisisce soltanto imparando ex novo molti linguaggi diversi.</p> <p>Nelle lingue naturali esistono delle analogie, delle somiglianze dovute dalla genealogia. Ad esempio tra l'italiano e il rumeno: cioccolata/ciocolata, insalata/salata, treno/tren.</p> <p>\u00c8 invece difficile conoscere un gran numero di linguaggi di programmazione in modo approfondito, \u00e8 per\u00f2 possibile conoscerne a fondo i meccanismi che ne ispirano il progetto e l'implementazione.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#implementazione-dei-linguaggio-di-programmazione","title":"Implementazione dei linguaggio di programmazione","text":"<p>Che significa implementare un linguaggio di programmazione?</p> <p>Si tratta di un concetto strettamente legato a quello di macchina astratta.</p> <p>Un calcolatore \u00e8 una macchina fisica che:</p> <ul> <li>consente di eseguire algoritmi opportunamente formalizzati<sup>1</sup> perch\u00e9 siano   \"comprensibili\" all'esecutore;</li> <li>la formalizzazione consiste nella codifica degli algoritmi in un certo   linguaggio \\(\\lng\\) definito da una specifica sintassi;</li> <li>la sintassi di \\(\\lng\\) permette di utilizzare determinati costrutti per   comporre programmi in \\(\\lng\\);</li> <li>Un programma in \\(\\lng\\) \u00e8 una sequenza di istruzioni del linguaggio \\(\\lng\\).</li> </ul> <p>Una macchina astratta \u00e8 un'astrazione del concetto di calcolatore fisico.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#macchina-astratta-e-linguaggio-macchina","title":"Macchina astratta e linguaggio macchina","text":"<p>Una macchina astratta per \\(\\lng\\) \u00e8 un insieme di algoritmi e strutture dati che permettono di memorizzare ed eseguire programmi scritti in \\(\\lng\\).</p> <p>Si denota con \\(\\ml\\) ed \u00e8 composta da:</p> <ul> <li>una memoria per immagazzinare dati e programmi;</li> <li>un interprete che esegue le istruzioni contenute nei programmi.</li> </ul> <p>Linguaggio Macchina</p> <p>Data una macchina astratta \\(\\ml\\), il linguaggio \\(\\lng\\) \"compreso\" dall'interprete di \\(\\ml\\) \u00e8 detto linguaggio macchina di \\(\\ml\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#struttura-di-una-macchina-astratta","title":"Struttura di una macchina astratta","text":"<p>Vediamo la struttura di una macchina astratta:</p> <pre><code>flowchart LR\n    subgraph Memoria\n    direction LR;\n        d(Dati); prog(Programma);\n    end\n\n    subgraph Interprete\n    direction LR;\n        cseq(Controllo Sequenza);\n        cdata(Controllo dati);\n        gmem(Gestione memoria);\n    end\n\n    subgraph Operazioni\n    end\n\n    Memoria --- Interprete --- Operazioni;</code></pre> <p>La memoria viene utilizzata per contenere sia i programmi che i dati utili a questi ultimi. l'interprete ha tre moduli e ha anche accesso ad una serie di operazioni. Queste sono operazioni sui tipi e sui parametri dei dati, ma anche operazioni e istruzioni per il controllo della sequenza di esecuzione.</p> <p>Dunque, operazioni per l'elaborazione dei dati primitivi: numeri interi, reali, operazioni aritmetiche.</p> <p>Le operazioni e strutture dati per il controllo della sequenza di esecuzione:</p> <ul> <li>servono per gestire il flusso di controllo delle istruzioni;</li> <li>strutture dati per memorizzare l'indirizzo della prossima istruzione;</li> <li>operazioni per manipolare le strutture dati (es. calcolo dell'indirizzo   della prossima istruzione).</li> </ul> <p>Operazioni e strutture dati per il controllo del trasferimento dei dati:</p> <ul> <li>gestiscono il trasferimento dei dati dalla memoria all'interprete e viceversa   (es.: recupero degli operandi);</li> <li>possono far uso di strutture dati ausiliarie (es. pila).</li> </ul> <p>Operazioni e strutture dati per la gestione della memoria, relative all'allocazione di memoria per dati e programmi.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#ciclo-di-esecuzione-del-generico-interprete","title":"Ciclo di esecuzione del generico interprete","text":"<pre><code>flowchart TD\n    start((Start)) --&gt; AcqProx(Acquisisci la&lt;br&gt;prossima istruzione)\n                   --&gt; Decode(Decodifica)\n                   --&gt; AcqOps(Acquisisci gli operandi)\n                   --&gt; Choose(Seleziona);\n\n    Choose --&gt; Eop1(\"Esegui \ud835\udc42\ud835\udc43\u2099\") &amp;  Eop2(\"Esegui \ud835\udc42\ud835\udc43\u2082\") &amp; Eopn(\"Esegui \ud835\udc42\ud835\udc43\u2081\")\n           --&gt; MemRes(Memorizza il risultato)\n           --&gt; start;\n\n    Choose --&gt; Halt(\"Esegui HALT\")\n           --&gt; stop((Stop));</code></pre>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#realizzazione-di-una-macchina-astratta","title":"Realizzazione di una macchina astratta","text":"<p>Per essere effettivamente utilizzata, \\(\\ml\\) dovr\u00e0 prima o poi utilizzare qualche dispositivo fisico, ovvero mediante una realizzazione \"fisica\" in hardware. In questo caso gli algoritmi di \\(\\ml\\) sono realizzati direttamente mediante dispositivi fisici.</p> <p>\u00c8 possibile pensare a delle realizzazioni che fanno uso di livelli intermedi tra \\(\\ml\\) e il dispositivo fisico:</p> <ul> <li>simulazione mediante software;</li> <li>emulazione mediante firmware (microprogrammi in linguaggi di basso livello).</li> </ul> <p>La realizzazione hardware \u00e8 la pi\u00f9 semplice ma al contempo la pi\u00f9 onerosa a livello di costi. \u00c8 necessario realizzare delle macchine fisiche che, al termine della vita del linguaggio di programmazione saranno obsolete.</p> <p>I metodi pi\u00f9 convenienti sono quelli software o firmware<sup>2</sup>. La grande maggioranza simula via software e in questo modo viene svincolata la macchina astratta da quella fisica.</p> <p>Una macchina astratta non \u00e8 altro che l'insieme di linguaggio e software di base che permettono di eseguire il linguaggio su varie piattaforme.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#realizzazione-mediante-software","title":"Realizzazione mediante software","text":"<p>Per poter realizzare via software una macchina astratta \u00e8 necessario realizzare degli algoritmi e delle strutture dati di \\(\\ml\\) in un altro linguaggio \\(\\lng'\\) che sia gi\u00e0 implementato. Dunque, \\(\\ml\\) viene realizzata mediante dei programmi in \\(\\lng'\\) che simulino le funzionalit\u00e0 di \\(\\ml\\).</p> <p>La macchina \\(\\ml\\) viene realizzata attraverso la macchina \\(\\mlprime\\). Quest'ultima viene detta macchina ospite e si denota con \\(\\molo\\).</p> <p>Intuitivamente l'implementazione di \\(\\lng\\) sulla macchina ospite avviene mediante una qualche \"traduzione\" di \\(\\lng\\) in \\(\\llo\\);</p> <p>A seconda di come avvenga la traduzione di parla di implementazione</p> <ul> <li>interpretativa;</li> <li>compilativa.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#i-programmi-definiscono-funzioni-parziali3","title":"I programmi definiscono funzioni parziali<sup>3</sup>","text":"<p>Prendiamo ad esempio la seguente funzione in Pascal:</p> Delphi<pre><code>read(x);\nif x == 1 then print(x) else\nwhile (x &lt;&gt; 1) do skip;\n</code></pre> <p>La seguente relazione \u00e8 presente:</p> \\[     f(x) =  \\begin{cases}                 1 &amp; \\text{se } x = 1  \\\\                 \\nexists &amp; \\text{se } x \\in \\R \\setminus \\{1\\}             \\end{cases} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#definizione-di","title":"Definizione di","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#interprete","title":"...interprete","text":"<p>In generale un programma scritto in \\(\\lng\\) si pu\u00f2 vedere come una funzione parziale<sup>3</sup>:</p> \\[ \\prgm^\\lng\\colon D \\times D \\tc \\prgm^\\lng(Input) = Output \\] <p>Possiamo dare la seguente definizione di interprete di \\(\\lng\\) in \\(\\llo\\):</p> \\[     \\intr^\\llo_\\lng\\colon (\\prgm^\\lng \\times D) \\to D \\tc     \\intr^\\llo_\\lng(\\prgm^\\lng, Input) = \\prgm^\\lng(Input) \\] <p>In un interprete non vi \u00e8 una traduzione esplicita dei programmi scritti in \\(\\lng\\) ma solamente un procedimento di decodifica dello stesso.</p> <p>L'interprete per eseguire un'istruzione \\(i\\) di \\(\\lng\\),fa corrispondere a questa un insieme di istruzioni di \\(\\llo\\). Tale decodifica non \u00e8 una traduzione esplicita poich\u00e9 il codice corrispondente ad \\(i\\) \u00e8 eseguito direttamente e non prodotto in uscita.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#compilatore","title":"...compilatore","text":"<p>Un compilatore da \\(\\lng\\) a \\(\\llo\\) \u00e8 un programma che realizza la funzione:</p> \\[ \\cmp_{\\lng,\\ \\llo}\\colon \\prgm^\\lng \\to \\prgm^\\llo \\] \\[     \\cmp_{\\lng,\\ \\llo}(\\prgmcmp^\\llo)     \\qquad     \\prgm^\\lng(Input) = \\prgmcmp^\\llo(Input) \\] <p>Questo significa che avviene una traduzione esplicita dei programmi scritti in \\(\\lng\\) in programmi scritti in \\(\\llo\\).</p> <p>Per poter eseguire \\(\\prgm^\\lng\\) su \\(Input\\) bisogna eseguire \\(\\cmp_{\\lng,\\ \\llo}\\) con \\(\\prgm^\\lng\\) come input. Si avr\u00e0 come risultato un programma compilato \\(\\prgmcmp^\\llo\\) scritto in \\(llo\\) che sar\u00e0 eseguito su \\(\\molo\\) con il dato di ingresso \\(Input\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#interpretazione-vs-compilazione","title":"Interpretazione vs. Compilazione","text":"<p>L'interpretazione ha una scarsa efficienza perch\u00e9 la decodifica dei costrutti avviene a runtime<sup>4</sup> e inoltre viene rieseguita la decodifica di un comando che viene ripetuto. Per\u00f2 l'interpretazione presenta una grande flessibilit\u00e0, rendendo il debugging pi\u00f9 semplice.</p> <p>Al contrario, la compilazione offre un'efficienza superiore poich\u00e9 la decodifica di un'istruzione avviene una singola volta, indipendente da quante volte viene eseguita. Offre per\u00f2 meno flessibilit\u00e0 dato che varie informazioni vengono perse rispetto al programma sorgente, \u00e8 difficile tracciare errori e dunque maggiori difficolt\u00e0 nel debugging.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#gerarchie-di-macchine-astratte","title":"Gerarchie di macchine astratte","text":"<p>\u00c8 possibile pensare ad una gerarchie di macchine astratte \\(\\mm_{\\lng_0},\\ \\mm_{\\lng_1},\\ \\dots,\\ \\mm_{\\lng_n}\\). In questo modo la macchina \\(\\mm_{\\lng_i}\\) viene implementata sfruttando il linguaggio della macchina sottostante \\(\\mm_{\\lng_{i-1}}\\). A sua volta la macchina \\(\\mm_{\\lng_i}\\) fornisce a sua volta il proprio linguaggio alla macchina sottostante \\(\\mm_{\\lng_{i+1}}\\).</p> <p>Questo permette di avere una indipendenza tra livelli, ovvero le modifiche interne alle funzionalit\u00e0 di un livello non hanno alcuna influenza sugli altri livelli.</p> <pre><code>flowchart TD\n    subgraph mWEB[Macchina WEB]\n        subgraph mLAL[Macchina Linguaggio Alto Livello]\n            subgraph mSO[Macchina Sistema Operativo]\n                subgraph mFM[Macchina Firmware]\n                    subgraph mHW[Macchina Hardware]; end\n                end\n            end\n        end\n    end</code></pre> <p>Un linguaggio di programmazione non \u00e8 altro che un formalismo per portare al livello della macchina fisica l'algoritmo solutivo \\(A_P\\) per un certo problema \\(P\\). In generale:</p> <pre><code>flowchart LR\n    alg([Algoritmo AP&lt;br&gt;descrizione del metodo solutivo]) --&gt; esecutor;\n    data([Dati d'istanza di P]) --&gt; esecutor[Esecutore]\n                                --&gt; res([Risultati&lt;br&gt;Soluzione dell'istanza di P]);</code></pre> <p>L'esecutore deve essere in grado di interpretare la descrizione del metodo solutivo.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#il-problema-della-fermata","title":"Il problema della fermata","text":"<p>Esistono dei problemi i quali non possono essere risolti tramite l'uso di un programma? La risposta dipende dal linguaggio di programmazione?</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#funzioni-parziali-calcolabili","title":"Funzioni parziali calcolabili","text":"<p>Una funzione parziale \\(f\\colon A \\to B\\) \u00e8 calcolabile nel linguaggio \\(\\lng\\) se esiste un programma \\(\\prgm\\) scritto in \\(\\lng\\) tale che:</p> <ul> <li>se \\(f(a) = b\\) allora \\(\\prgm(a)\\) termina e produce come output \\(b\\);</li> <li>se \\(f(a)\\) non \u00e8 definita allora \\(\\prgm(a)\\) va in ciclo.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#il-problema","title":"Il problema","text":"<p>Si vuole stabilire se un programma \\(H\\) termina su un dato input. Il programma \\(H\\) riceve in ingresso un qualsiasi programma \\(\\prgm\\) scritto nel linguaggio \\(\\lng\\) ed \u00e8 un generico input \\(x\\) per tale programma:</p> Delphi<pre><code>Boolean H(P, x)\nboolean term;\nif (P(x) termina) then term = true;\nelse term = false;\nreturn term;\n</code></pre> <p>dunque</p> \\[     H(P,\\ x) \\text{ restituisce }     \\begin{cases}         \\text{true}  &amp; \\text{se } P(x) \\text{ termina}  \\\\         \\text{false} &amp; \\text{se } P(x) \\text{ va in loop}     \\end{cases} \\] <p>\u00c8 possibile costruire un altro programma \\(K\\), scritto in \\(\\lng\\), che prenda in input un programma \\(\\prgm\\) (sempre scritto in \\(\\lng\\)). Il programma \\(K\\) sfrutta \\(H\\) per decidere sulla terminazione di \\(\\prgm\\).</p> Delphi<pre><code>K(P)\nif (H(P, P) = false) then print(\"LOOP\");\nelse while (true) do print(\"TERMINA\");\n</code></pre> <p>quindi si ha che</p> \\[     K(P)     \\begin{cases}         \\text{stampa 'LOOP'}  &amp; \\text{se } P(\\prgm) \\text{ non termina}  \\\\         \\text{va in loop}     &amp; \\text{se } P(\\prgm) \\text{ termina}     \\end{cases} \\] <p>in pratica la terminazione di \\(K\\) \u00e8 opposta rispetto a quella del suo input.</p> <p>Cosa accadrebbe se \\(K\\) ricevesse in input se stesso?</p> <p>otterremmo un assurdo perch\u00e9:</p> <ul> <li>\\(K(K)\\) termina con una stampa se \\(K(K)\\) non termina;</li> <li>\\(K(K)\\) non termina se \\(K(K)\\) termina;</li> </ul> <p>l'assurdo deriva dall'aver supposto l'esistenza del programma \\(H\\).</p> <p>Il problema della terminazione \u00e8 indecidibile: non \u00e8 possibile costruire e formalizzare un algoritmo che sia in grado di risolverlo.</p> <p>Dunque la prima domanda diventa: \"Esistono funzioni non calcolabili?\" e la risposta \u00e8 s\u00ec, infatti il problema della terminazione \u00e8 uno di questi. Questo risultato dipende dal linguaggio \\(\\lng\\)? Ovvero, dipende dal formalismo usato per descrivere l'algoritmo? Per rispondere, introduciamo la macchina di Turing.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#macchina-di-turing","title":"Macchina di Turing","text":"<p>Esse si basano su un modello matematico di computazione introdotto negli anni '20, ed \u00e8 stato il primo formalismo col quale \u00e8 stato dimostrato l'indecidibilit\u00e0 del problema della fermata.</p> <p>La macchina di Turing \u00e8 costituita da:</p> <ul> <li>un nastro potenzialmente infinito diviso in celle (memoria), dove ogni cella   contiene un simbolo preso da un alfabeto finito;</li> <li>una testina di lettura/scrittura che, a sua volta:<ul> <li>pu\u00f2 leggere/scrivere una cella per volta;</li> <li>pu\u00f2 spostarsi a destra o a sinistra di una cella per volta;</li> <li>viene gestita da un controllo espresso sotto forma di un numero finito   di stati;</li> </ul> </li> <li>unit\u00e0 di controllo, che decodifica e esegue comandi rivolti alla testina.</li> </ul> <p>L'unit\u00e0 di controllo esegue un programma \\(\\prgm\\) sui dati memorizzati sul nastro. Le istruzioni del programma \\(\\prgm\\) sono del tipo:</p> Text Only<pre><code>&lt;simbolo_letto, stato corrente, simbolo_da_scrivere, Sx, Dx, nuovo_stato&gt;\n</code></pre>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#il-modello-matematico","title":"Il modello matematic$o","text":"<p>Una Macchina di Turing definita dalla quintupla \\(M = (X,\\ Q,\\ f_m,\\ f_d,\\ \\delta)\\), dove:</p> <ul> <li>\\(X\\) \u00e8 un insieme finito di simboli che comprende anche blank ovvero la cella   vuota;</li> <li>\\(Q\\) \u00e8 un insieme finito di stati che comprende \\(\\HALT\\) che definisce la   terminazione;</li> <li>\\(f_m\\) \u00e8 la funzione macchina, definita come \\(f_m\\colon Q \\times X \\to X\\) che   determina il simbolo da scrivere sul nastro;</li> <li>\\(f_d\\) \u00e8 la funzione di direzione, definita come   \\(f_d\\colon Q \\times X \\to \\set{\\sx,\\ \\dx,\\ F}\\) che determina lo spostamento   della testina, dove \\(F\\) sta per \"ferma\";</li> <li>\\(\\delta\\) \u00e8 la funzione di transizione di stato, definita come   \\(\\delta\\colon Q \\times X \\to Q\\), questa definisce lo stato successivo della   computazione.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#scrivere-algoritmi-per-macchina-di-turing","title":"Scrivere algoritmi per Macchina di Turing","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#nastro","title":"Nastro","text":"<p>\u00c8 necessario definire un'opportuna configurazione iniziale del nastro e codificare i dati. Ad esempio, il nastro iniziale per il problema della sottrazione di interi, in particolare \\(4 - 2\\):</p> Configurazione iniziale<pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502 ^ \u2502 | \u2502 | \u2502 | \u2502 | \u2502 * \u2502 | \u2502 | \u2502 ^ \u2502 ^ \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>gli operandi sono codificati con <code>|</code> e separati da <code>*</code>, il blank \u00e8 rappresentato da <code>^</code>.</p> <p>Successivamente bisogna definire un'opportuna configurazione finale del nastro che rappresenti la soluzione</p> Configurazione finale<pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502 ^ \u2502 ^ \u2502 ^ \u2502 | \u2502 | \u2502 ^ \u2502 ^ \u2502 ^ \u2502 ^ \u2502 ^ \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#controllo","title":"Controllo","text":"<p>Bisogna ora definire le funzioni \\(f_m,\\ f_d,\\ \\delta\\), in modo da trasformare la configurazione iniziale in quella che rappresenta la soluzione. Come detto, il programma per una Macchina di Turing \u00e8 una sequenza di quintuple:</p> \\[     \\langle x_i \\in X,\\ q_j \\in Q,\\ x_{ij} \\in X,\\ \\set{S,\\ D,\\ F},\\ q_{ij} \\in Q\\rangle \\] <p>In corrispondenza di un simbolo letto \\(x_i\\) e dello stato \\(q_j\\) in cui si trova l'unit\u00e0 di controllo, si determinano:</p> <ul> <li>il simbolo \\(x_{ij} = f_m(x_i,\\ q_j)\\) da scrivere nella cella corrente;</li> <li>lo spostamento della testina \\(f_d(x_i,\\ q_j)\\);</li> <li>il nuovo stato \\(q_{ij} = \\delta(x_i\\ q_j)\\) in cui la Macchina di Turing   continuer\u00e0 la computazione.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#sottrazione-tra-interi","title":"Sottrazione tra interi","text":"<p>Progettiamo un algoritmo per eseguire la sottrazione tra due numeri interi \\(n,\\ m \\geq 0\\) e per semplicit\u00e0 e convenienza assumiamo che \\(n \\geq m\\).</p> <p>La testina \u00e8 posizionata sulla prima cella vuota a destra dell'ultimo simbolo del sottraendo:</p> <pre><code>                                  \u2193\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502 ^ \u2502 | \u2502 | \u2502 | \u2502 | \u2502 * \u2502 | \u2502 | \u2502 ^ \u2502 ^ \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>Il modello di calcolo obbliga a pensare all'algoritmo in base alle operazioni possibili</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#un-possibile-algoritmo","title":"Un possibile algoritmo","text":"<p>Bisogna cancellare un egual numero di simboli \\(n\\) e da \\(m\\) in modo che sul nastro resti solo il risultato finale.</p> <ol> <li>Diminuire di un'unit\u00e0 \\(m\\), ricordando di aver cancellato un simbolo da \\(m\\);</li> <li>Spostarsi a \\(\\sx\\) in cerca del primo simbolo di \\(n\\);</li> <li>Cancellarlo, ricordando che entrambi gli operandi son stati diminuiti di    un'unit\u00e0;</li> <li>Spostarsi a \\(\\dx\\) in cerca dell'ultimo simbolo di \\(m\\)</li> <li>Se non sono presenti pi\u00f9 simboli da cancellare da \\(m\\), allora cancellare il    separatore e terminare (\\(\\HALT\\)), altrimenti tornare al punto 1.</li> </ol>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#le-quintuple-di-una-macchina-di-turing-per-la-sottrazione","title":"Le quintuple di una Macchina di Turing per la sottrazione","text":"<p>Dato l'insieme finito di simboli \\(X = \\set{|,\\ \\ast,\\ \\caret}\\) e l'insieme finito di stati \\(Q = \\set{q_0,\\ q_1,\\ q_2,\\ q_3,\\ \\HALT}\\), con:</p> <ul> <li>\\(q_0 \\equiv\\) stato iniziale della computazione, ovvero la ricerca dell'ultimo   simbolo di \\(m\\);</li> <li>\\(q_1 \\equiv\\) diminuito di \\(m\\);</li> <li>\\(q_2 \\equiv\\) raggiunto il simbolo di \\(n\\);</li> <li>\\(q_3 \\equiv\\) diminuiti entrambi gli operandi.</li> </ul> <p>Si ottengono le seguenti quintuple:</p> \\[     \\begin{align}     &amp; \\langle \\caret,\\ q_0,\\ \\caret,\\  \\sx,\\  q_0   \\rangle,  &amp;     &amp; \\langle |,\\      q_0,\\ \\caret,\\  \\sx,\\  q_1   \\rangle,  &amp; \\\\     &amp; \\langle \\ast,\\   q_0,\\ \\caret,\\  F,\\    \\HALT \\rangle,  &amp;     &amp; \\langle \\caret,\\ q_1,\\ \\caret,\\  \\dx,\\  q_2   \\rangle,  &amp; \\\\     &amp; \\langle |,\\      q_1,\\ |,\\       \\sx,\\  q_1   \\rangle,  &amp;     &amp; \\langle \\ast,\\   q_1,\\ \\ast,\\    \\sx,\\  q_1   \\rangle,  &amp; \\\\     &amp; \\langle |,\\      q_2,\\ \\caret,\\  \\dx,\\  q_3   \\rangle,  &amp;     &amp; \\langle \\caret,\\ q_3,\\ \\caret,\\  \\sx,\\  q_0   \\rangle,  &amp; \\\\     &amp; \\langle |,\\      q_3,\\ |,\\       \\dx,\\  q_3   \\rangle,  &amp;     &amp; \\langle \\ast,\\   q_3,\\ \\ast,\\    \\dx,\\  q_3   \\rangle.  &amp; \\\\     \\end{align} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#la-matrice-funzionale","title":"La matrice funzionale","text":"\\(X \\setminus Q\\) \\(q_0\\) \\(q_1\\) \\(q_2\\) \\(q_3\\) \\(\\caret\\) \\(\\caret \\sx q_0\\) \\(\\caret \\dx q_2\\) \\(\\caret \\sx q_0\\) \\(\\mid\\) \\(\\caret \\sx q_1\\) \\(\\mid\\sx q_1\\) \\(\\caret \\dx q_3\\) \\(\\mid\\dx q_3\\) \\(\\ast\\) \\(\\caret F \\HALT\\) \\(\\ast \\sx q_1\\) \\(\\ast \\dx q_3\\) <p>Per quale motivo alcune transizioni non sono definite? Perch\u00e9 semplicemente non sono possibili.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#tesi-di-church-turing","title":"Tesi di Church-Turing","text":"<p>La classe delle funzioni calcolabili coincide con la classe delle funzioni calcolabili dalla Macchina di Turing.</p> <p>Questo significa che ogni funzione calcolabile \u00e8 calcolata da una Macchina di Turing. Non \u00e8 presente alcun formalismo in grado di risolvere una classe di problemi pi\u00f9 ampia di quella che si pu\u00f2 risolvere con la Macchina di Turing.</p> <p>Attenzione</p> <p>Dunque le funzioni calcolabili con dei linguaggi di programmazione sono di  pi\u00f9 di quelle calcolabili con la Macchina di Turing? No.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#macchina-di-turing-vs-processori-moderni","title":"Macchina di Turing vs. Processori Moderni","text":"Macchina di Turing CPU legge/scrive su nastro legge/scrive su RAM/ROM transita in un nuovo stato nuova configurazione deiregistri della CPU sosta sul nastro di cella in cella scelta della cella di memoriasu cui operare esegue un programma specifico,cablato nella macchina \u00e8 generale, pu\u00f2 eseguireprogrammi diversi"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#la-macchina-di-turing-universale","title":"La Macchina di Turing Universale","text":"<p>La Macchina di Turing universale legge dal nastro sia i dati che il programma, dunque il programma non \u00e8 pi\u00f9 cablato nell'unit\u00e0 di controllo ma \u00e8 codificato sul nastro come i dati. In pratica le quintuple che definiscono l'algoritmo risolutivo sono rappresentate sul nastro.</p> <p>Questo significa che la Macchina di turing universale \u00e8 una macchina programmabile poich\u00e9 effettua un fetch delle quintuple dal nastro, dopodich\u00e9 un decode e infine un execute. Insomma, altro non \u00e8 che un interprete.</p> <p>La macchina di Turing universale \u00e8 un modello della macchina di Von Neumann, ovvero un modello degli attuali calcolatori, l'unica cosa che non possiede \u00e8 la parte I/O.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/00_introduzione_linguaggi/#recap","title":"Recap","text":"<p>Un linguaggio di programmazione \\(\\lng\\) \u00e8 un formalismo per portare al livello di macchina fisica gli algoritmi. Implementare \\(\\lng\\) significa realizzarne l\u2019interprete, ovvero il programma che esegue la traduzione di \\(\\lng\\) per la macchina ospite.</p> <p>La possibilit\u00e0 di risolvere un problema non dipende da \\(\\lng\\). Tutti i linguaggi di programmazione calcolano esattamente le stesse funzioni calcolate dalle macchine di Turing. Tutti i linguaggi di programmazione sono Turing-completi.</p> <ol> <li> <p>Si intende la codifica degli algoritmi in un certo linguaggio \\(\\lng\\) che \u00e8 definito da una certa sintassi. Questa deve consentire di usare solo determinati costrutti.\u00a0\u21a9</p> </li> <li> <p>Nasce poich\u00e9 esistono chip programmabili che permettono di bruciare/mantenere connessioni attraverso dei flussi di corrente. Vantaggioso rispetto all'hardware poich\u00e9 non \u00e8 necessario progettare una macchina fisica dato che si usa una general-purpose.\u00a0\u21a9</p> </li> <li> <p>Una funzione parziale \u00e8 una relazione binaria tra due insiemi che associa ogni elemento del primo insieme ad al pi\u00f9 un elemento del secondo insieme. Generalizza il concetto di funzione (totale) poich\u00e9 non richiede che ogni elemento del primo insieme sia associato ad esattamente un elemento del secondo insieme.\u00a0\u21a9\u21a9</p> </li> <li> <p>Runtime indica il momento in cui un programma per computer viene eseguito, in contrapposizione ad altre fasi del ciclo di vita del software.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/","title":"Introduzione alla teoria dei linguaggi formali","text":"<p>La teoria dei linguaggi formali rappresenta spesso uno scoglio per gli studenti di informatica a causa della sua forte dipendenza dalla notazione.</p> <p>L'argomento, d'altra parte, non pu\u00f2 essere evitato perch\u00e9 ogni laureato in informatica deve possedere una buona comprensione dell'operazione di compilazione e questa, a sua volta, si fonda pesantemente sulla teoria dei linguaggi formali.</p> <p>Vi sono diversi livelli di descrizione di un linguaggio:</p> <ul> <li>grammatica, indica quali frasi sono corrette;</li> <li>semantica, indica il significato di una frase corretta;</li> <li>pragmatica, indica come fare uso di una frase corretta e sensata;</li> <li>implementazione (per i linguaggi di programmazione), indica come eseguire una   frase corretta in modo da rispettarne il significato.</li> </ul> <p>Le grammatiche sono uno strumento utile per descrivere la sintassi di un linguaggio di programmazione. \u00c8 costituita dall'alfabeto del linguaggio, ovvero un insieme di simboli con cui \"costituire\" le parole del linguaggio (es. alfabeto latino con \\(22\\) o \\(26\\) lettere), il lessico costituisce le parole del linguaggio (es. informatica), la sintassi determina quali sequenze di parole costituiscono frasi legali (o corrette).</p> <p>Questa prima parte del programma ha l'obiettivo di fornire una base sufficiente alla comprensione delle tecniche di compilazione, oggetto della seconda parte del corso.</p> <p>\u00c8 per questa ragione che ci si concentrer\u00e0 quasi esclusivamente su due tipi di grammatiche:</p> <ul> <li>regolari;</li> <li>libere da contesto.</li> </ul> <p>poich\u00e9 i linguaggi formali utilizzati in informatica sono per lo pi\u00f9 di questi tipi.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#introduzione","title":"Introduzione","text":"<p>L'informatica teorica \u00e8 la scienza degli algoritmi, in tutti i loro aspetti, poich\u00e9 \u00e8 il concetto di algoritmo che \u00e8 in qualche modo comune a tutti i settoridell'informatica.</p> <pre><code>flowchart LR\n    elab[Scienza degli elaboratori];\n    info[Scienza dell'informazione];\n    prgm[Scienza dei programmi];\n\n    Informatica ----&gt; elab &amp; info &amp; prgm;</code></pre> <p>Gli elaboratori sono macchine che eseguono degli algoritmi; l'informazione \u00e8 la materia su cui lavorano gli algoritmi; i programmi sono algoritmi descritti in un particolare linguaggio.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#aree-di-ricerca-dellinformatica-teorica","title":"Aree di ricerca dell'informatica teorica","text":"<p>Lo schema riportato in figura fornisce una panoramica delle aree di ricerca che ricadono nell'ambito pi\u00f9 generale dell'informatica teorica. Tali aree sono le seguenti:</p> <pre><code>flowchart LR\n    mcomp[\"Modello di computazione&lt;br&gt;(macchina astratta)\"];\n    prbl[Problema];\n    alg[Algoritmo di soluzione];\n    automi[Teoria degli automi];\n\n    comp[Teoria della computabilit\u00e0] ---&gt; prbl &amp; mcomp &amp; alg &amp; automi;</code></pre> <pre><code>flowchart LR\n    par1[Rapporto tra gli algoritmi e&lt;br&gt;linguaggi di programmazione];\n    par2[\"Propriet\u00e0 dei programmi&lt;br&gt;(completezza, terminazione, etc.)\"];\n\n    comp[Teoria matematica&lt;br&gt;della computazione] ---&gt; par1 &amp; par2;</code></pre> <pre><code>flowchart LR\n    par1[Rapporto tra gli algoritmi e&lt;br&gt;risorse necessarie per eseguirli];\n    par2[Aspetti quantitativi del procedimento&lt;br&gt;di soluzione di un problema];\n\n    comp[Teoria della&lt;br&gt;complessit\u00e0 computazionale] ---&gt; par1 &amp; par2;</code></pre> <p>Particolarmente feconda si \u00e8 rivelata l'interazione tra la Teoria degli Automi e la Teoria dei Linguaggi Formali.</p> <p>Quest'ultima, nata in ambito linguistico per caratterizzare i linguaggi naturali, \u00e8 stata sviluppata e utilizzata dagli informatici teorici, che avevano l'esigenza di descrivere gli algoritmi con linguaggi di programmazione comprensibili dalla macchina, ma non troppo difficili per l'uomo e soprattutto non ambigui.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#studio-dei-linguaggi","title":"Studio dei linguaggi","text":"<p>Quando si inizia a studiare un linguaggio, formale o meno, tutti quanti sono esperti di un linguaggio, quello con cui si comunica con altre persone.</p> <p>Oltre ad essere competenti in uno (o pi\u00f9) linguaggi naturali, lo studente in informatica ha familiarit\u00e0 con diversi linguaggi di programmazione, come FORTRAN, PASCAL, C, PROLOG, etc.</p> <p>Questi linguaggi vengono (o venivano) usati per scrivere programmi e quindi per comunicare con il computer. Chiunque utilizzi un computer potr\u00e0 notare che esso sia particolarmente limitato nel comprendere il significato desiderato dei programmi.</p> <p>In linguaggio naturale \u00e8 solitamente possibile comunicare anche attraverso frasi mal strutturate e incomplete, per il computer non \u00e8 cos\u00ec.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#sintassi-e-semantica","title":"Sintassi e Semantica","text":"<p>I programmi devono aderire rigorosamente a regole stringenti e anche differenze minori verranno rigettate come errate. Idealmente, ogni frase in un linguaggio dovrebbe essere corretta sia semanticamente (avere cio\u00e8 il corretto significato) sia sintatticamente (avere la corretta struttura grammaticale).</p> <p>Nell'italiano parlato, le frasi sono spesso sintatticamente sbagliate, ciononostante convogliano la semantica desiderata.</p> <p>In programmazione, comunque, \u00e8 essenziale che la sintassi sia corretta al fine di comunicare una qualsivoglia semantica. Quando si studia la semantica di una frase, ne si studia il significato.</p> <p>Tutte le frasi che seguono hanno la stessa interpretazione semantica, cio\u00e8 lo stesso significato, sebbene siano sintatticamente differenti:</p> <ul> <li>The man hits the dog;</li> <li>The dog is hit by the man;</li> <li>L'homme frappe le chien.</li> </ul> <p>Lo studio della sintassi \u00e8 lo studio della grammatica, cio\u00e8 della struttura delle frasi. La frase: \"The man hits the dog\" pu\u00f2 essere analizzata sintatticamente, cio\u00e8 risolta nelle parti grammaticali componenti, come segue:</p> \\[     \\underbrace{\\text{The man}}_{\\bnf{parte-nominale}} \\quad     \\underbrace{\\text{hits}}_{\\bnf{parte-verbale}}     \\quad     \\underbrace{\\text{the dog}}_{\\bnf{parte-nominale}} \\quad \\] <p>e ogni frase in questa forma \u00e8 sintatticamente valida in inglese.</p> <p>Possiamo descrivere un particolare insieme di tali frasi semplici in inglese usando le seguenti regole:</p> \\[     \\bnf{frase-semplice} \\Coloneqq \\bnf{parte-nominale}                                 \\bnf{parte-verbale}                                 \\bnf{parte-nominale} \\] <p>segue dunque</p> \\[     \\begin{align}         \\bnf{parte-nominale} &amp;\\Coloneqq \\bnf{articolo} \\bnf{nome}               \\\\         \\bnf{nome}           &amp;\\Coloneqq \\textbf{ car \\(\\mid\\) man \\(\\mid\\) dog} \\\\         \\bnf{articolo}       &amp;\\Coloneqq \\textbf{ The \\(\\mid\\) a}                \\\\         \\bnf{parte-verbale}  &amp;\\Coloneqq \\textbf{ hits \\(\\mid\\) eats}     \\end{align} \\] <p>Le precedenti regole sono scritte in BNF, una notazione usata comunemente per descrivere la sintassi dei linguaggi di programmazione. BNF sta per Backus-Naur Form, ed \u00e8 un metalinguaggio.</p> <p>Nell'esempio, \\(\\bnf{frase-semplice}\\) \u00e8 definita come una \\(\\bnf{parte-nominale}\\) seguita da una \\(\\bnf{parte-verbale}\\) seguita, a sua volta, da un'altra \\(\\bnf{parte-nominale}\\).</p> <p>Ciascuna delle due occorrenze di \\(\\bnf{parte nominale}\\) deve essere espansa in \\(\\bnf{articolo}\\) seguito da un \\(\\bnf{nome}\\).</p> <p>Scegliendo di espandere la prima occorrenza di \\(\\bnf{articolo}\\) in The, la prima occorrenza di \\(\\bnf{nome}\\) in man, la \\(\\bnf{parte-verbale}\\) in hits, il secondo \\(\\bnf{articolo}\\) in the e infine l'ultimo \\(\\bnf{nome}\\) in dog, si dimostra che la frase The man hits the dog \u00e8 una frase semplice.</p> <p>Tutto ci\u00f2 si pu\u00f2 riassumere nel seguente Albero di derivazione:</p> <pre><code>flowchart TD\n    frsm[\"#10216;frase-semplice#10217;\"];\n    ptnm[\"#10216;parte-nominale#10217;\"]; ptn1[\"#10216;parte-nominale#10217;\"];\n    ptvb[\"#10216;parte-verbale#10217;\"];\n    artc[\"#10216;articolo#10217;\"]; art1[\"#10216;articolo#10217;\"];\n    nome[\"#10216;nome#10217;\"]; nom1[\"#10216;nome#10217;\"];\n\n    frsm --&gt; ptnm &amp; ptvb &amp; ptn1;\n\n    ptnm --&gt; artc --&gt; The;\n    ptnm --&gt; nome --&gt; man;\n\n    ptvb ---&gt; hits;\n\n    ptn1 --&gt; art1 --&gt; the;\n    ptn1 --&gt; nom1 --&gt; dog;</code></pre> <p>La definizione data di \\(\\bnf{frase-semplice}\\) d\u00e0 luogo a \\(72\\) diverse frasi derivabili. Sebbene tutte siano sintatticamente corrette, in base alla nostra definizione, alcune non hanno un'interpretazione semantica sensata (non hanno senso compiuto). Una di queste \u00e8 la frase: The car eats the man. Non necessariamente una frase corretta ha senso.</p> <p>Consideriamo la seguente frase (non derivabile da \\(\\bnf{frase-semplice}\\) utilizzando le regole date in precedenza): They are flying planes.</p> <p>Un'analisi sintattica di questa frase \u00e8:</p> \\[     \\underbrace{\\text{They}}_{\\bnf{pronome}} \\quad     \\underbrace{\\text{are}}_{\\bnf{verbo}} \\quad     \\underbrace{         \\underbrace{\\text{flying}}_{\\bnf{aggettivo}} \\quad         \\underbrace{\\text{planes}}_{\\bnf{nome}}     }_{\\bnf{parte-nominale}} \\] <p>Quest'analisi suggerisce che they si riferisce a planes (aerei nel cielo che volano). Un'analisi alternativa sarebbe:</p> \\[     \\underbrace{\\text{They}}_{\\bnf{pronome}} \\quad     \\underbrace{\\text{are flying}}_{\\bnf{verbo}} \\quad     \\underbrace{\\text{planes}}_{\\bnf{nome}} \\] <p>e questa implicherebbe un'interpretazione semantica completamente differente, in cui they si riferisce a chiunque sia attualmente al controllo dei planes (essi stanno pilotando gli aerei).</p> <p>Nell'esempio, l'analisi sintattica \u00e8 di aiuto all'interpretazione semantica. Per quanto sia scelto \"ad hoc\" e mostri un fenomeno poco comune nel linguaggio naturale, l'esempio \u00e8 illustrativo di un concetto importante in computazione. Una fase cruciale nel processo di compilazione di un programma \u00e8 l'analisi sintattica, come passo essenziale per la sua interpretazione semantica.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#teoria-dei-linguaggi-formali","title":"Teoria dei linguaggi formali","text":"<p>Negli anni \\('50\\), N. Chomsky, linguista americano, cerca di descrivere la sintassi del linguaggio naturale secondo semplici regole di riscrittura e trasformazione. Chomsky considera alcune restrizioni sulle regole sintattiche e classifica i linguaggi in base alle restrizioni imposte alle regole che generano tali linguaggi. Una classe importante di regole che generano linguaggi formali va sotto il nome di grammatiche libere da contesto (prive di contesto) o context-free grammars.</p> <p>L'importanza di tale classe (e dei linguaggi da essa generati) risiede nel fatto che lo sviluppo dei primi linguaggi di programmazione di alto livello (ALGOL60), che segue di pochi anni il lavoro di Chomsky, dimostra che le grammatiche context-free sono strumenti adeguati a descrivere la sintassi di base di molti linguaggi di programmazione.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#esempio-di-linguaggio-context-free","title":"Esempio di linguaggio context-free","text":"<p>Un linguaggio context-free \u00e8, ad esempio, il linguaggio delle parentesi ben formate tutte le stringhe di parentesi aperte e chiuse bilanciate correttamente.</p> <p>Esempi</p> <p>\\(( )\\) \u00e8 ben formata;</p> <p>\\(( ( ) ( ) )\\) \u00e8 ben formata;</p> <p>\\(( ( ) ( )\\) non \u00e8 ben formata</p> <p>Questo linguaggio \u00e8 fondamentale in informatica come notazione per contrassegnare il \"raggio d'azione\" nelle espressioni matematiche e nei linguaggi di programmazione.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#definizione","title":"Definizione","text":"<ol> <li>La stringa \\(( )\\) \u00e8 ben formata;</li> <li>se la stringa di simboli \\(A\\) \u00e8 ben formata, allora lo \u00e8 anche \\((A)\\);</li> <li>se le stringhe \\(A\\) e \\(B\\) sono ben formate, allora lo \u00e8 anche la stringa    \\(AB\\)</li> </ol> <p>In corrispondenza di questa definizione induttiva, \u00e8 possibile considerare un sistema di riscrittura che genera esattamente l'insieme delle stringhe lecite di parentesi ben formate:</p> <p>I. \\(S \\to ()\\); II. \\(S \\to (S)\\); III. \\(S \\to SS\\).</p> <p>Le regole di riscrittura 1., 2. e 3. sono dette produzioni o regole di produzione. Queste stabiliscono che \"data una stringa si pu\u00f2 formare una nuova stringa sostituendo una \\(S\\) con \\(()\\) o con \\((S)\\) o con \\(SS\\)\".</p> <p>Confrontando la definizione di parentesi ben formate e le tre produzioni, si osserva una corrispondenza diretta tra le parti 1. e 2. della definizione e le produzioni 1. e 2. La produzione 3. \u00e8 apparentemente diversa dalla parte 3. della definizione. Sono stati utilizzati simboli distinti \\(A\\) e \\(B\\) nella definizione induttiva per evidenziare il fatto che le due stringhe di parentesi ben formate che consideriamo non sono necessariamente uguali. Nella produzione corrispondente non c'\u00e8 necessit\u00e0 di usare simboli distinti perch\u00e9 in le due \\(S\\) che compaiono a destra possono essere sostituite indipendentemente.</p> <p>Possiamo cio\u00e8 applicare una produzione ad una delle due \\(S\\) (alla prima o alla seconda) indifferentemente. Il risultato non cambia.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#esempio-di-generazione","title":"Esempio di generazione","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#primo-modo","title":"Primo modo","text":"\\[     \\begin{align}         S \\Uimplies{(3)} SS &amp;\\Uimplies{(2)} (S)S                              \\Uimplies{(1)} ((\\,))S             \\\\                             &amp;\\Uimplies{(2)} ((\\,))(S)                              \\Uimplies{(3)} ((\\,))(SS)          \\\\                             &amp;\\Uimplies{(1)} ((\\,))((\\,)S)                              \\Uimplies{(1)} ((\\,)((\\,)(\\,)))     \\end{align} \\] <p>La corrispondente sequenza di applicazione delle produzioni \u00e8:</p> \\[ (3) \\to (2) \\to (1) \\to (2) \\to (3) \\to (1) \\to (1) \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#secondo-modo","title":"Secondo modo","text":"\\[     \\begin{align}         S \\Uimplies{(3)} SS &amp;\\Uimplies{(2)} (S)S                              \\Uimplies{(3)} S(SS)           \\\\                             &amp;\\Uimplies{(1)} S((\\,)S)                              \\Uimplies{(1)} S((\\,)(\\,))     \\\\                             &amp;\\Uimplies{(2)} (S)((\\,)(\\,))                              \\Uimplies{(1)} ((\\,)((\\,)(\\,)))     \\end{align} \\] <p>La corrispondente sequenza di applicazione delle produzioni \u00e8:</p> \\[ (3) \\to (2) \\to (3) \\to (1) \\to (1) \\to (2) \\to (1) \\] <p>Una sequenza di applicazioni di regole di produzione prende il nome di derivazione.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/01_intro_teoria_linguaggi_formali/#notazione","title":"Notazione","text":"<p>Nei due esempi precedenti si \u00e8 fatto uso della notazione:</p> \\[ \\alpha \\Uimplies{n} \\beta \\] <p>L'interpretazione \u00e8 la seguente: \"da \\(\\alpha\\) si produce direttamente \\(\\beta\\) per effetto dell\u2019applicazione della regola di riscrittura \\(n\\)\". Ad esempio</p> \\[ SS \\Uimplies{(2)} (S)S \\] <p>si legge: \"\\(SS\\) produce direttamente \\((S)S\\) per effetto dell\u2019applicazione della regola di riscrittura \\((2)\\).</p> <p>Le derivazioni precedenti (modi 1 e 2) vengono riassunte attraverso la notazione:</p> \\[ S \\astimplies ((\\,))((\\,)(\\,)) \\] <p>che leggiamo come \"\\(S\\) produce \\(((\\,))((\\,)(\\,))\\)\".</p> <p>Nelle regole di produzione si \u00e8 fatto uso di due tipi di simboli: caratteri che possono apparire nelle derivazioni, ma non nelle stringhe finali, detti simboli non-terminali o variabili (nell\u2019esempio, \\(S\\) \u00e8 il solo non-terminale) e caratteri che possono apparire nelle stringhe finali, detti simboli terminali (nell\u2019esempio, e sono i simboli terminali).</p> <p>Nella notazione BNF si scrive:</p> \\[     \\begin{align}         &amp;S       &amp;\\bnf{S}           \\\\         &amp;\\!\\to   &amp;\\!\\!\\Coloneqq     \\end{align} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/","title":"Grammatiche e Linguaggi","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#linguaggi-formali-e-monoidi-liberi","title":"Linguaggi formali e Monoidi liberi","text":"<p>Il concetto di linguaggio formale \u00e8 strettamente correlato a quello di monoide libero (generato da un insieme).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#definizioni","title":"Definizioni","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#alfabeto","title":"Alfabeto","text":"<p>Un insieme \\(X\\) finito e non vuoto di simboli \u00e8 un alfabeto.</p> <p>Esempi</p> <ul> <li>L'alfabeto latino, con l'aggiunta dei simboli di interpunzione e dello   spazio bianco: \\(\\set{a\\ b\\ \\ldots\\ z\\ ;\\ ,\\ .\\ :}\\);</li> <li>L'insieme delle dieci cifre arabe \\(\\set{0\\ 1\\ \\dots\\ 9}\\).</li> </ul> <p>Con i simboli primitivi dell'alfabeto si formano le parole (es. abc, 127, casa, etc.).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#parola-o-stringha","title":"Parola o stringha","text":"<p>Una sequenza finita di simboli \\(\\oneton{x}\\), dove ogni \\(x_i\\) \u00e8 preso da uno stesso alfabeto \\(X\\) \u00e8 una parola su \\(X\\).</p> <p>Esempio</p> <p>Sia \\(X = \\set{0,\\ 1}\\) un alfabeto, allora \\(001110\\) \u00e8 una parola su \\(X\\);</p> <p>Una parola \u00e8 ottenuta giustapponendo o concatenando simboli (caratteri) dell'alfabeto. Se una stringa ha \\(m\\) simboli non necessariamente distinti, allora diciamo che ha lunghezza \\(m\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#lunghezza-di-una-parola-o-stringa","title":"Lunghezza di una parola o stringa","text":"<p>La lunghezza di una stringa \\(w\\) \u00e8 denotata con \\(\\abs{w}\\). Le parole di lunghezza \\(1\\) sono i simboli di \\(X\\). Quindi \\(001110\\) \u00e8 una parola di lunghezza \\(6\\):</p> \\[ \\abs{001110} = 6 \\] <p>La parola vuota (o stringa vuota), denotata con \\(\\lambda\\), \u00e8 una stringa priva di simboli e ha lunghezza \\(0\\):</p> \\[ \\abs{\\lambda} = 0 \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#uguaglianza-tra-stringhe","title":"Uguaglianza tra stringhe","text":"<p>Due stringhe sono uguali se i loro caratteri, letti ordinatamente da sinistra a destra, coincidono.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#xast","title":"\\(X^\\ast\\)","text":"<p>L'insieme di tutte le stringhe di lunghezza finita sull'alfabeto \\(X\\) si denota con \\(X^\\ast\\).</p> <p>Esempio</p> <p>Sia \\(X = \\set{0,\\ 1}\\) un alfabeto, allora \\(X^\\ast = \\set{\\lambda,\\ 0,\\ 1,\\ 00,\\ 01,\\ 10,\\ 11, \\dots}\\).</p> <p>L'insieme \\(X^\\ast\\) ha un numero di elementi che \u00e8 un infinito numerabile. Dalla definizione, segue che \\(\\lambda \\in X^\\ast\\) per ogni insieme \\(X\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#concatenazione-o-prodotto","title":"Concatenazione o prodotto","text":"<p>Siano \\(\\alpha,\\, \\beta \\in X^\\ast\\) due stringhe di lunghezza rispettivamente \\(m\\), \\(n\\). La concatenazione di \\(\\alpha\\) e \\(\\beta\\), denotata con \\(\\alpha\\beta\\) o \\(\\alpha \\cdot \\beta\\), \u00e8 definita come la stringa di lunghezza \\(m + n\\), i cui primi \\(m\\) simboli sono gli stessi di quelli di \\(\\alpha\\) e gli ultimi \\(n\\) simboli sono gli stessi di \\(\\beta\\).</p> <p>Quindi se \\(\\alpha = x_1\\,x_2 \\dots x_m\\) e \\(\\beta = y_1\\,y_2 \\dots y_n\\), si ha:</p> \\[ \\alpha\\beta = x_1\\,x_2 \\dots x_m\\,y_1\\,y_2 \\dots y_n \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#operazione-di-concatenazione","title":"Operazione di concatenazione","text":"<p>La concatenazione di stringhe su \\(X\\) \u00e8 una operazione binaria su \\(X^\\ast\\):</p> \\[ \\cdot : X^\\ast \\times X^\\ast \\to X^\\ast \\] <ul> <li>\u00e8 associativa, infatti:   \\((\\alpha\\beta)\\gamma = \\alpha(\\beta\\gamma) = \\alpha\\beta\\gamma\\),   \\(\\;\\forall \\alpha,\\beta,\\gamma \\in X^\\ast\\);</li> <li>non \u00e8 commutativa, infatti:   \\(\\exists \\alpha,\\beta \\in X^\\ast \\tc \\alpha\\beta \\neq \\beta\\alpha\\);</li> <li>ha elemento neutro \\(\\lambda\\): \\(\\lambda\\alpha = \\alpha\\lambda = \\alpha\\),   \\(\\;\\forall \\alpha \\in X^\\ast\\).</li> </ul> <p>Dunque \\((X^\\ast,\\ \\cdot)\\) \u00e8 un monoide non commutativo.</p> <p>Osservazione</p> <p>In base alla definizione di prodotto, ogni parola vuota  \\(\\alpha = \\oneton{x}\\) si pu\u00f2 scrivere in uno ed un solo modo come prodotto di parole di lunghezza \\(1\\), cio\u00e8 elementi di \\(X\\).</p> <p>Ci\u00f2 si esprime dicendo che \\(\\left(X^\\ast,\\ \\cdot\\right)\\) \u00e8 il monoide libero generato dall'insieme \\(X\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#prefisso-suffisso","title":"Prefisso, suffisso","text":"<p>Se \\(\\lambda \\in X^\\ast\\) \u00e8 della forma \\(\\gamma = \\alpha\\beta\\), dove \\(\\alpha,\\,\\beta \\in X^\\ast\\), allora \\(\\alpha\\) \u00e8 un prefisso di \\(\\gamma\\) e \\(\\beta\\) \u00e8 un suffisso di \\(\\gamma\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#sottostringa","title":"Sottostringa","text":"<p>Se \\(\\delta,\\,\\beta \\in X^\\ast\\), con \\(\\delta\\) della forma \\(\\delta = \\alpha\\beta\\gamma\\), dove \\(\\alpha,\\beta,\\gamma \\in X^\\ast\\) allora \\(\\beta\\) \u00e8 una sottostringa di \\(\\delta\\).</p> <p>Esempio</p> <p>Sia \\(\\gamma = 001100\\), allora:</p> <ul> <li>\\(\\set{\\lambda,\\ 0,\\ 00,\\ 001,\\ 0011,\\ \\gamma}\\) \u00e8 l'insieme dei prefissi   di \\(\\gamma\\);</li> <li>\\(\\set{\\lambda,\\ 0,\\ 10,\\ 110,\\ 0110,\\ \\gamma}\\) \u00e8 l'insieme dei suffissi   di \\(\\gamma\\);</li> <li>\\(\\set{     \\lambda,\\ 0,\\ 1,\\ 00,\\ 01,\\ 10,\\ 11,\\ 001,\\ 011,\\ 110,\\ 0011,\\ 0110,\\     \\gamma}   \\) \u00e8 l'insieme delle sottostringhe di \\(\\gamma\\).</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#potenza-di-una-stringa","title":"Potenza di una stringa","text":"<p>Data una stringa \\(\\alpha\\) su \\(X\\), la potenza \\(h\\)-esima di \\(\\alpha\\) \u00e8 definita induttivamente come segue:</p> \\[     \\alpha^h =  \\begin{cases}                     \\lambda             &amp;\\text{se } h = 0 \\\\                     \\alpha\\alpha^{h-1}  &amp;\\text{altrimenti}                 \\end{cases} \\quad     \\forall h \\in \\N \\] <p>La potenza \\(h\\)-esima di una stringa \u00e8 un caso speciale di concatenamento (in quanto la si ottiene concatenando una stringa \\(h\\) volte con se stessa).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#potenza-di-un-alfabeto","title":"Potenza di un alfabeto","text":"<p>Sia \\(X\\) un alfabeto, poniamo:</p> <ol> <li>\\(X^1 = X\\);</li> <li>\\(X^2 = \\set{x_1\\,x_2 \\mid x_1,x_2 \\in X, \\quad x_1\\,x_2 \\equiv x_1 \\cdot x_2}\\);</li> <li>\\(X^3 = \\set{         x_1\\,x_2\\,x_3 \\mid x_1,x_2 \\in X,\\; x_3 \\in X, \\quad         x_1 x_2 x_3 \\equiv x_1 x_2 \\cdot x_3}    \\);</li> </ol> <p>si ha dunque:</p> \\[     X^i = \\set{         x_1\\,x_2 \\dots x_{i-1}\\, x_i \\mid x_1\\,x_2 \\dots x_{i-1} \\in X^{i-1},\\,         x_i \\in X, \\quad         x_1\\,x_2 \\dots x_i \\equiv x_1\\,x_2 \\dots x_{i-1} \\cdot x_i} \\] <p>Se \\(i \\geq 2\\) si ha:</p> \\[ X^+ = X \\cup X^2 \\cup \\dots \\cup X^i \\cup \\dots = \\bigcup^{+\\infty}_{i=1}x^i \\] <p>Se \\(\\lambda\\) \u00e8 la parola vuota e si prende un \\(w \\in X^+\\) tale che \\(w \\cdot \\lambda = \\lambda \\cdot w = w\\) si ha:</p> \\[ X^\\ast = \\set{\\lambda} \\cup X^+ \\] <p>Inoltre si ha:</p> \\[     X^h = \\begin{cases}                 \\set{\\lambda}   &amp;\\text{se } h = 0 \\\\                 X \\cdot X^{h-1} &amp;\\text{altrimenti}           \\end{cases} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#linguaggio-formale","title":"Linguaggio formale","text":"<p>Un linguaggio formale \\(L\\) su un alfabeto \\(X\\) \u00e8 un sottoinsieme di \\(X^\\ast\\), ovvero \\(L \\subseteq X^\\ast\\).</p> <p>Esempio</p> <p>Il linguaggio delle parentesi ben formate \u00e8 un linguaggio formale in quanto, denotato con \\(M\\) tale linguaggio, si ha:</p> \\[ M \\subset \\set{(\\ )}^\\ast \\] <p>I linguaggi formali possono essere di natura molto diversa l'uno dall'altro.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#esempi-di-linguaggi-formali","title":"Esempi di linguaggi formali","text":"<p>Un linguaggio di programmazione pu\u00f2 essere costruito a partire dall'alfabeto \\(X\\) dei simboli sulla tastiera.</p> <p>L'insieme, finito o infinito, dei programmi ben costruiti sintatticamente (ossia, che rispettano la sintassi) costituisce un linguaggio.</p> <p>Consideriamo l'insieme dei teoremi di una teoria matematica. I teoremi sono particolari stringhe di simboli del nostro alfabeto. L'insieme dei teoremi \"ben formati\" rappresenta un linguaggio. Ad esempio, la stringa \"\\(ab = ba\\)\" non \u00e8 un teorema della teoria dei gruppi, ma della teoria dei gruppi abeliani.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#generazione-e-riconoscimento-di-linguaggi-formali","title":"Generazione e riconoscimento di linguaggi formali","text":"<p>Siamo interessati ai linguaggi formali da almeno due punti di vista: descrittivo e/o generativo, riconoscitivo.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#generazione-di-linguaggi-formali","title":"Generazione di linguaggi formali","text":"<p>Com'\u00e8 possibile generare gli elementi di un dato linguaggio \\(L\\)? Un linguaggio finito pu\u00f2 essere descritto/generato per elencazione degli elementi (se il numero non \u00e8 troppo grande). Un linguaggio infinito non \u00e8 elencabile.</p> <p>Questi sono i pi\u00f9 interessanti perch\u00e9 devono essere specificati necessariamente attraverso una propriet\u00e0 che ne caratterizza gli elementi, che ne definisce l'intensione. Tale propriet\u00e0 pu\u00f2 essere vista come una regola da seguire per generare gli elementi del linguaggio. Il vero problema \u00e8 trovare le o la regola generativa, o di produzione di un linguaggio.</p> <p>\u00c8 quello che accade quando si impara una lingua dato che non \u00e8 possibile memorizzare tutte le frasi della lingua.</p> <p>Esempio</p> <ul> <li>Non \u00e8 possibile \"elencare\" tutti i teoremi della teoria dei gruppi, dato   dato che sono infiniti i teoremi realizzabili combinando quelli noti;</li> <li>Un libro di teoria dei gruppi non \u00e8 l'elencazione dei teoremi, ma fornisce   una serie di assiomi e regole con le quali, a partire dagli assiomi, \u00e8   possibile costruire tutti i teoremi della teoria dei gruppi;</li> </ul> <p>Per descrivere la regola di produzione di un linguaggio, verr\u00e0 utilizzata una notazione insiemistica.</p> <p>Esempio</p> <p>Sia \\(L\\) il linguaggio su \\(X = \\set{0}\\) costituito da tutte e sole le stringhe che hanno un numero pari di \\(0\\), ovvero:</p> \\[ L = \\set{\\lambda,\\ 00,\\ 0000\\, \\dots} \\] <p>La regola di produzione di \\(L\\) viene espressa come segue:</p> \\[ L = \\set{\\lambda} \\cup \\set{w^n \\mid w = 00,\\ n = 1,2,\\dots} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#riconoscimento-di-linguaggi-formali","title":"Riconoscimento di linguaggi formali","text":"<p>Com'\u00e8 possibile riconoscere gli elementi di un dato linguaggio \\(L\\)? Questo secondo punto di vista ha come obiettivo la costruzione di \"macchine\" in grado di decidere o stabilire se una stringa \u00e8 un elemento di \\(L\\) oppure no. Si intende costruire una \"macchinetta\" cui dare in ingresso una particolare parola e che produca una tra due possibili risposte:</p> <ul> <li>\\(s\u00ec \\equiv parola \\in L'\\)</li> <li>\\(no \\equiv parola \\notin L'\\)</li> </ul> <p>Esempio</p> <p>L'esecuzione di un programma errato sintatticamente viene inibita. Questo \u00e8 indice dell'esistenza di una \"macchinetta\" che stabilisce se il programma appartiene o no all'insieme dei programmi sintatticamente ben costruiti.</p> <p>Analizziamo il problema della generazione di \\(L\\).</p> <p>Sia dato l'alfabeto: \\(X = \\set{0,\\ 1,\\ 2, \\dots,\\ 9,\\ +,\\ -}\\). Si vuole generare il linguaggio \\(L\\) dei numeri interi relativi. Ovviamente \\(L \\subseteq X^\\ast\\), pi\u00f9 precisamente \\(L \\subset X^\\ast\\) poich\u00e9 ad esempio \\(1++-5 \\notin L\\).</p> <p>Non \u00e8 possibile elencare gli elementi di \\(L\\). \u00c8 dunque necessario trovare una serie di regole mediante le quali \u00e8 possibile produrre tutti e soli gli elementi di \\(L\\).</p> <p>Sia assunto, per semplicit\u00e0, che un numero relativo sia costituito da una serie di cifre precedute da \\(+\\) o \\(-\\).</p> <p>Adottata la BNF per descrivere le produzioni, si ha:</p> \\[     \\begin{align}         \\bnf{S} &amp;\\Coloneqq +\\bnf{I} \\mid -\\bnf{I}               \\\\         \\bnf{I} &amp;\\Coloneqq \\bnf{D} \\mid \\bnf{I} \\bnf{D}         \\\\         \\bnf{D} &amp;\\Coloneqq 0 \\mid 1 \\mid 2 \\mid 3 \\mid 4 \\mid 5                              \\mid 6 \\mid 7 \\mid 8 \\mid 9     \\end{align} \\] <p>Queste regole generano tutti gl interi relativi, purch\u00e9 si parta dal simbolo non-terminale \\(S\\). Il simbolo non-terminale \\(I\\) \u00e8 anche detto categoria sintattica e sta ad indicare la classe dei numeri interi. Questo \u00e8 definito ricorsivamente o come una cifra o come un intero seguito da una cifra. Dunque ogni intero relativo \u00e8 generato da queste regole e niente che non sia un intero relativo pu\u00f2 essere generato da queste regole.</p> <p>Esempio</p> <p>Si vuole generare ad albero l'intero relativo \\(-375\\). Tale albero prende il nome di albero di derivazione.</p> <pre><code>flowchart TD\n    S ------&gt; -;\n    S --&gt; I --&gt; I1[I] --&gt; I2[I] --&gt; D --&gt; 3;\n    I1 --&gt; D1[D] ---&gt; 7;\n    I --&gt; D2[D] ----&gt; 5;</code></pre> \\[ S \\astimplies -375 \\iff -375 \\in L \\] <p>Nella notazione vista per il linguaggio delle parentesi ben formate, tipica dei linguaggi formali, la grammatica diventa:</p> \\[ \\begin{align}     S &amp;\\to +I \\mid -I   \\\\     I &amp;\\to  D \\mid I\\;D  \\\\     D &amp;\\to  0 \\mid 1 \\mid 2 \\mid 3 \\mid 4 \\mid 5 \\mid 6 \\mid 7 \\mid 8 \\mid 9 \\end{align} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#grammatiche-generative","title":"Grammatiche generative","text":"<p>Dagli esempi di linguaggi visti, \u00e8 possibile trarre le seguenti conclusioni. Per generare un linguaggio sono necessari:</p> <ul> <li>un insieme \\(X\\) di simboli primitivi con cui si formano le parole del   linguaggio, detto alfabeto dei simboli terminali o alfabeto terminale;</li> <li>un insieme \\(V\\) di simboli ausiliari o variabili con cui si identificano   le categorie sintattiche del linguaggio, detto alfabeto dei simboli   non-terminali (ausiliari) o alfabeto non-terminale o alfabeto delle   variabili;</li> <li>un simbolo speciale \\(S\\), scelto tra i non-terminali, da cui far partire la   generazione delle parole del linguaggio. Tale simbolo \u00e8 detto assioma o   scopo o simbolo distintivo o simbolo di partenza o simbolo   iniziale;</li> <li>un insieme \\(P\\) di produzioni, espresse in un formalismo quali: regole di   riscrittura, BNF \\((a \\Coloneqq b)\\), carte sintattiche, etc.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#definizione","title":"Definizione","text":"<p>Una grammatica generativa o a struttura di frase di \\(G\\) \u00e8 una quadrupla</p> \\[ \\grammar \\] <p>dove:</p> <ul> <li>\\(X\\) \u00e8 l'alfabeto terminale per la grammatica;</li> <li>\\(V\\) \u00e8 l'alfabeto non-terminale o delle variabili per la grammatica;</li> <li>\\(S\\) \u00e8 il simbolo di partenza per la grammatica;</li> <li>\\(P\\) \u00e8 l'insieme delle produzioni della grammatica.</li> </ul> <p>Valgono inoltre le seguenti condizioni:</p> <ul> <li>\\(\\XiV = \\emptyset\\);</li> <li>\\(S \\in V\\).</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#altre-definizioni","title":"Altre definizioni","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#produzione","title":"Produzione","text":"<p>Una produzione \u00e8 una coppia \\((v,\\ w)\\), dove \\(v \\in \\XuVplus\\) e \\(V\\) contiene un simbolo non-terminale se e solo se \\(v \\in \\XuVast V \\XuVast\\) e \\(w \\in \\XuVast\\), quindi \\(w\\) pu\u00f2 essere anche \\(\\lambda\\).</p> <p>Un elemento \\((v,\\ w)\\) di \\(P\\) \u00e8 comunemente scritto nella forma:</p> \\[ v \\to w \\] <p>Una produzione deve, in qualche modo, riscrivere un simbolo non-terminale.</p> <p>Per convenzione, gli elementi di \\(X\\) sono rappresentati di solito con lettere minuscole (con o senza pedici e di solito sono le prime lettere dell'alfabeto) o cifre ed operatori (connettivi), mentre gli elementi di \\(V\\) sono rappresentati con lettere maiuscole (con o senza pedici) o con stringhe delimitate dalle parentesi angolari \"\\(\\langle\\)\" e \"\\(\\rangle\\)\".</p> <p>La notazione \\(\\prodto[k]{a}{b}\\) \u00e8 impiegata come abbreviazione della seguente:</p> \\[     \\begin{align}         a &amp;\\to b_1              \\\\         a &amp;\\to b_2              \\\\           &amp;\\hspace{0.7em}\\vdots \\\\         a &amp;\\to b_k     \\end{align} \\] <p>Esempi di grammatiche</p> <ul> <li>La grammatica per il linguaggio della parentesi ben formate \u00e8 la seguente:</li> </ul> \\[     G_1 = \\left(         \\set{(\\ )},\\ \\set{S},\\ S,\\ \\set{S \\to (\\;),\\ S \\to (S),\\ S \\to SS}     \\right) \\] <ul> <li>La grammatica per il linguaggio dei numeri interi relativi \u00e8 la seguente:</li> </ul> \\[     G_2 = \\left(         \\set{0, 1, \\dots, 9, +, -}, \\set{S, I, D}, S,         \\set{S \\to +I,\\ S \\to -I,\\ I \\to D,\\ I \\to ID,\\              D \\to 0,\\ D \\to 1, \\dots, D \\to 9}     \\right) \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#derivazione-o-produzione-diretta","title":"Derivazione o produzione diretta","text":"<p>Sia \\(\\grammar\\) una grammatica e siano \\(y\\) e \\(z\\) su \\(\\XuV\\) due stringhe finite di simboli sia terminali che non-terminali, tali che:</p> \\[ y = \\gamma\\alpha\\delta \\quad\\text{ e }\\quad z = \\gamma\\beta\\delta \\] <p>dove \\(y \\in \\XuVplus\\), \\(z \\in \\XuVast\\), \\(\\alpha,\\beta,\\gamma \\in \\XuVast\\).</p> <p>Si scrive</p> \\[ y \\implies z \\] <p>e si dice che \\(y\\) produce direttamente \\(z\\) o che \\(z\\) \u00e8 derivata direttamente da \\(y\\) se:</p> \\[ \\alpha \\to \\beta \\in P \\] <p>ossia se esiste in \\(G\\) un produzione \\(\\alpha \\to \\beta\\).</p> <p>Si scrive, invece:</p> \\[ y \\astimplies z \\] <p>e si dice che \\(y\\) produce \\(z\\) o che \\(z\\) \u00e8 derivabile da \\(y\\) se \\(y = z\\) o se esiste una sequenza di stringhe \\(\\oneton{w}\\), con \\(\\oneton[n-1]{w} \\in \\XuVplus\\) e \\(w_n \\in \\XuVast\\), avendo \\(w_1 = y\\) e \\(w_n = z\\) tali che \\(\\forall i,\\; i = 1,\\, 2,\\, \\dots,\\, n - 1 : w_i \\Uimplies{G} w_{i+1}\\), ovvero \\(w_i\\) produce direttamente \\(w_{i+1}\\), cio\u00e8:</p> \\[     y \\astimplies z \\iff     \\begin{align}         &amp;y = z              \\\\         &amp;\\text{oppure }     \\\\         &amp;w_1 = y \\implies w_2 \\implies \\dots \\implies w_{n-1} \\implies w_n = z     \\end{align} \\] <p>La notazione di derivazione diretta stabilisce una relazione binaria in \\(\\XuVast\\).</p> <p>Date due stringhe \\(y,z\\), il simbolo \\(\\implies\\) pu\u00f2 esserci o meno, dipende dall'esistenza di una produzione. Allora \u00e8 possibile anche definire una composizione di relazioni:</p> \\[      y \\Oimplies{2} z \\deff \\exists x : y \\implies w \\land w \\implies z \\] <p>dove \\(2\\) \u00e8 il numero di trascrizioni necessarie per passare da \\(y\\) a \\(z\\), ossia la lunghezza della derivazione.</p> <p>Da ci\u00f2 si ha che \\(\\astimplies\\) non \u00e8 altro che:</p> \\[     I \\cup \\implies \\cup \\Oimplies{2} \\cup \\Oimplies{3} \\cup \\cdots \\] <p>dove \\(I\\) \u00e8 la relazione identica e \\(\\Oimplies{n}\\) indica la composizione della relazione \\(\\implies\\) \\(n\\) volte con se stessa. Dunque:</p> <ul> <li>\\(\\astimplies\\) \u00e8 la chiusura riflessiva e transitiva della relazione di   derivazione diretta;</li> <li>\\(\\Oimplies{+}\\) \u00e8 la chiusura transitiva della stessa relazione.</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#linguaggio-generato-da-una-grammatica","title":"Linguaggio generato da una grammatica","text":"<p>Sia \\(\\grammar\\) una grammatica. Il linguaggio generato da \\(G\\), denotato con \\(L(G)\\), \u00e8 l'insieme delle stringhe di simboli terminali derivabili dal simbolo di partenza \\(S\\):</p> \\[     L(G) = \\set{w \\in X^\\ast\\ \\middle|\\ \\OUimplies{\\ast}{G} w} \\] <p>Sono, dunque, stringhe di \\(L(G)\\) le stringhe che:</p> <ul> <li>consistono di soli simboli terminali;</li> <li>possono essere derivate da \\(S\\) in \\(G\\).</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#forma-di-frase","title":"Forma di frase","text":"<p>Sia \\(\\grammar\\) una grammatica. Una stringa \\(w \\in \\XuVast\\) \u00e8 un forma di frase di \\(G\\) se</p> \\[ S \\OUimplies{\\ast}{G} w \\] <p>Alle forme di frasi si applicano le stesse definizioni (es. potenza) e gli stessi operatori (es. concatenazione) dati per le stringhe.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#proposizione","title":"Proposizione","text":"<p>Data una grammatica \\(\\grammar\\), \\(L(G)\\) \u00e8 l'insieme delle forme di frase terminali (o frasi) di \\(G\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#grammatiche-equivalenti","title":"Grammatiche equivalenti","text":"<p>Due grammatiche \\(G\\) e \\(G'\\) si dicono equivalenti se generano lo stesso linguaggio, ossia se</p> \\[ L(G) = L(G') \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#esempio","title":"Esempio","text":"<p>Sia \\(\\grammar\\), con:</p> \\[     X = \\set{a,\\ b},\\quad V = \\set{S},\\quad     P = \\set{S \\supto{(1)} aSb,\\ S \\supto{(2)} ab} \\] <p>Si determini \\(L(G)\\). Si ha \\(ab \\in L(G)\\), poich\u00e9 \\(S \\Uimplies{(2)} ab\\).</p> <p>Se si numerano le produzioni, \u00e8 possibile indicare la produzione usata immediatamente al di sotto del simbolo \\(\\implies\\):</p> <ul> <li>\\(\\Uimplies{n}\\) equivale a dire che \u00e8 stata applicata la produzione \\(n\\);</li> <li>\\(y \\Oimplies{k} z\\) equivale a dire che  \\(y\\) produce \\(z\\) in \\(k\\) passi,   dove \\(k\\) non \u00e8 altro che la lunghezza della derivazione.</li> </ul> <p>Si ha \\(a^2b^2 \\in L(G)\\) dato che \\(S \\Uimplies{(1)} aSb \\Uimplies{(2)} a^2b^2\\), inoltre \\(a^3b^3 \\in L(G)\\) poich\u00e9 \\(S \\Oimplies{3} a^3b^3\\), e dunque</p> \\[ \\set{a^n b^n \\mid n &gt; 0} \\subseteq L(G) \\] <p>Inoltre, qualsiasi derivazione da \\(S\\) in \\(G\\) produce frasi del tipo \\(a^nb^n\\), dunque \\(L(G) \\subseteq \\set{a^nb^n \\mid n &gt; 0}\\), e quindi:</p> \\[ L(G) = \\set{a^n b^n \\mid n &gt; 0} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#notazione","title":"Notazione","text":"<p>Per rendere pi\u00f9 concisa la descrizione di una grammatica, spesso ci si limiter\u00e0 a elencarne le produzioni, quando sia chiaro quale sia il simbolo di partenza e quali siano i simboli terminali e quelli non-terminali.</p> <p>Inoltre, le produzioni con la stessa parte sinistra vengono accorpate attraverso l'uso del simbolo \"\\(\\mid\\)\" (preso in prestito dalla BNF).</p> <p>Infine, verr\u00e0 omessa l'indicazione della grammatica dalla simbologia di derivazione e derivazione diretta quando sia chiaro dal contesto a quale grammatica si fa riferimento.</p> <p>Esempio</p> <p>Sia data la seguente grammatica:</p> \\[     S \\to \\sup{A}{(1)}  \\mid \\sup{B}{(2)},\\qquad     A \\to \\sup{aA}{(3)} \\mid \\sup{a}{(4)},\\qquad     B \\to \\sup{bB}{(5)} \\mid \\sup{b}{(6)} \\] <p>Determinare \\(L(G)\\).</p> <p>Non si sa se applicare \\(S \\supto{(1)} A\\) oppure \\(S \\supto{(2)} B\\) inizialmente. I meccanismi di costruzione di un linguaggio sono generalmente non deterministici, poich\u00e9 pu\u00f2 non essere univoca la sostituzione da  operare ad una forma di frase se uno stesso simbolo non-terminale si trova a sinistra di due o pi\u00f9 produzioni, come illustrato nella figura seguente</p> <pre><code>flowchart LR\n    S ==&gt;|\"(2)\"| B ==&gt;|\"(5)\"| bB;\n                 B ==&gt;|\"(6)\"| b[\"b \u2208 L(G)\"];\n\n    S ==&gt;|\"(1)\"| A ==&gt;|\"(4)\"| a[\"a \u2208 L(G)\"];\n                 A ==&gt;|\"(3)\"| aA ==&gt;|\"(4)\"| aa[\"aa \u2208 L(G)\"];\n                              aA ==&gt;|\"(3)\"| aaA ==&gt;|\"(4)\"| aaa[\"aaa \u2208 L(G)\"];\n                                            aaA ==&gt;|\"(3)\"| aaaA;</code></pre> <p>Ne consegue che</p> \\[ L(G) = \\set{a^n \\mid n &gt; 0} \\cup \\set{b^n \\mid n &gt; 0} \\] <p>Dunque, una grammatica \u00e8 uno strumento generativo di un linguaggio perch\u00e9, data una qualsiasi parola di quel linguaggio, \u00e8 possibile risalire mediante le produzioni al simbolo di partenza della grammatica.</p> <p>Viceversa, dato il simbolo di partenza di una grammatica, seguendo uno qualsiasi dei cammini dell'albero di derivazione, si produce una parola \"valida\" del linguaggio.</p> <p>in generale, dato un linguaggio \\(L\\) e una grammatica \\(G\\), non esiste un algoritmo in grado di dimostrare che la grammatica genera il linguaggio, ossia che \\(L = L(G)\\).</p> <p>Pi\u00f9 specificamente, non esiste un algoritmo che stabilisce se una data stringa \u00e8 generata o no dalla grammatica presa in considerazione.</p> <p>Tutto ci\u00f2 si riassume nella seguente proposizione:</p> <p>Proposizione</p> <p>Il problema di dimostrare la correttezza di una grammatica non \u00e8 risolubile algoritmicamente, in generale.</p> <p>In molti casi importanti, per\u00f2, \u00e8 possibile dimostrare per induzione che una particolare grammatica genera proprio un particolare linguaggio.</p> <p>Queste dimostrazioni consentono di stabilire se, data una grammatica \\(G\\) e un linguaggio \\(L\\), risulta:</p> <ol> <li>\\(w \\in L(G) \\implies w \\in L\\) ovvero \\(L(G) \\subseteq L\\);</li> <li>\\(w \\in L \\implies w \\in L(G)\\) ovvero \\(L \\subseteq L(G)\\).</li> </ol> <p>Il punto 1. afferma che la grammatica \\(G\\) genera solo stringhe appartenenti al linguaggio \\(L\\), ovvero coerenza o consistenza di \\(G\\). Il secondo punto afferma che il linguaggio \\(L\\) comprende solo parole generabili dalla grammatica \\(G\\), ovvero la completezza di \\(G\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/02_grammatiche_linguaggi/#principio-di-induzione-extra","title":"Principio di Induzione (extra)","text":"<p>Sia \\(n_0\\) un intero e sia \\(P = P(n)\\) un enunciato che ha senso per ogni intero maggiore o uguale a \\(n_0\\). Se</p> \\[     P(n_0) \\text{ \u00e8 vero } \\land     \\forall n &gt; n_0,\\; P(n-1) \\text{ \u00e8 vero } \\implies P(n) \\text{ \u00e8 vero} \\] <p>allora \\(P(n)\\) \u00e8 vero \\(\\forall n \\geq n_0\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/","title":"Linguaggi liberi da contesto e linguaggi dipendenti da contesto","text":""},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#grammatica-libera-da-contesto","title":"Grammatica libera da contesto","text":"<p>Una grammatica \\(\\grammar\\) \u00e8 libera da contesto (o context-free) se, per ogni produzione, \\(v \\to w\\) \u00e8 un simbolo non-terminale.</p> \\[     G \\text{ context-free } \\deff \\forall v \\to w \\in P : v \\in V \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#linguaggio-context-free","title":"Linguaggio context-free","text":"<p>Un linguaggio \\(L\\) su un alfabeto \\(X\\) \u00e8 libero da contesto se pu\u00f2 essere generato da una grammatica libera da contesto</p> \\[     L \\text{ context-free } \\deff \\exists G \\text{ context-free} \\tc L(G) = L \\] <p>Se si ha una grammatica context-free che genera \\(L\\), non \u00e8 detto che non esista un'altra grammatica che generi lo stesso linguaggio.</p> <p>La maggior parte dei linguaggi di programmazione sono context-free. Il termine context-free nasce dal fatto che la sostituzione di un simbolo non-terminale non \u00e8 condizionata dal contesto, ossia dai caratteri adiacenti in cui compare.</p> <p>Un simbolo non-terminale \\(A\\) in una forma di frase pu\u00f2 sempre essere sostituito usando una produzione del tipo \\(A \\to \\beta\\). La sostituzione \u00e8 sempre valida.</p> <p>Viceversa, se \\(L = L(G)\\) e \\(G\\) non \u00e8 context-free, non \u00e8 possibile concludere che \\(L\\) non \u00e8 context-free perch\u00e9 non \u00e8 possibile escludere che esista una grammatica context-free \\(G'\\) per cui \\(L = L(G')\\).</p> <p>Esempi</p> <ul> <li>Il linguaggio delle parentesi ben formate o quello dei numeri interi   relativi o il linguaggio delle stringhe con egual numero di \\(0\\) e \\(1\\);</li> <li>Il linguaggio \\(L = \\set{a^n b^n \\mid n &gt; 0}\\) o il linguaggio   \\(L = \\set{a^n b^{2n} \\mid n &gt; 0}\\);</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#grammatica-dipendente-da-contesto","title":"Grammatica dipendente da contesto","text":"<p>Una grammatica \\(\\grammar\\) \u00e8 dipendente da contesto (o context-sensitive), se ogni produzione \u00e8 in una delle seguenti forme:</p> <ol> <li>\\(yAz \\to ywz\\) con \\(A \\in V\\), \\(y,z \\in \\XuVast\\), \\(w \\in \\XuVplus\\) che    si legge: \"\\(A\\) pu\u00f2 essere sostituita con \\(w\\) nel contesto \\(y{-}z\\)\"    (contesto sinistro \\(y\\) e contesto destro \\(z\\));</li> <li>\\(S \\to \\lambda\\) purch\u00e9 \\(S\\) non compaia nella parte destra di alcuna    produzione.</li> </ol>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#linguaggio-dipendente-da-contesto","title":"Linguaggio dipendente da contesto","text":"<p>Un linguaggio \\(L\\) \u00e8 dipendente da contesto se pu\u00f2 essere generato da una grammatica dipendente da contesto.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#linguaggi-context-free-e-context-sensitive","title":"Linguaggi context-free e context-sensitive","text":"<p>La relazione \u00e8 la seguente</p> <pre><code>flowchart TD\n    subgraph null[\" \"]\n        subgraph CS[context-sensitive]\n            subgraph CF[context-free]; end\n        end\n    end\nclassDef sub rx:10,ry:10\nclass null,CS,CF sub</code></pre> <p>Tale relazione sussiste perch\u00e9 le regole di produzione context-sensitive sono una generalizzazione di quelle context-free. Le produzioni context-free sono un caso particolare delle produzioni di tipo 1. delle grammatiche context-sensitive, che si verifica quando \\(y = z = \\lambda\\), ovvero il contesto destro e sinistro sono equivalenti alla parola vuota.</p> <p>Eccezione</p> <p>Osservando con attenzione la definizione di grammatica context-free, si nota che \\(w \\in \\XuVast\\) mentre nella definizione di grammatica context-sensitive \\(w \\in \\XuVplus\\).</p> <p>Dunque le grammatiche context-free ammettono produzioni del tipo \\(A \\to \\lambda\\) con \\(A\\) che pu\u00f2 anche non essere il simbolo iniziale, mentre le grammatiche context-sensitive non ammettono tali produzioni.</p> <p>Verranno chiamate tutte le produzioni del tipo \\(\\lambda\\)-produzioni o \\(\\lambda\\)-regole.</p> <p>Alcuni esempi di produzioni contestuali sono i seguenti:</p> <ul> <li>\\(bC \\to bc\\);</li> <li>\\(baACba \\to baAabA\\).</li> </ul> <p>Esempi di grammatica contestuale sono i seguenti:</p> <ul> <li>\\(S \\to \\lambda \\mid bC\\)<sup>1</sup>;</li> <li>\\(bC \\to bC\\)</li> </ul> <p>Un esempio di produzione non context-sensitive (n\u00e9 context-free) \u00e8 il seguente:</p> \\[ CB \\to BC \\] <p>Quest'ultima non \u00e8 n\u00e9 context-sensitive n\u00e9 context-free. \u00c8 una produzione monotona perch\u00e9 del tipo \\(v \\to w\\) con \\(\\abs{v} \\leq \\abs{w}\\).</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#grammatica-monotona","title":"Grammatica monotona","text":"<p>Una grammatica \\(\\grammar\\) \u00e8 monotona se ogni sua produzione \u00e8 monotona, ovvero se</p> \\[ \\forall v \\to w \\in P : \\abs{v} \\leq \\abs{w} \\]"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#linguaggio-monotono","title":"Linguaggio monotono","text":"<p>Un linguaggio \\(L\\) \u00e8 monotono se pu\u00f2 essere generato da una grammatica monotona.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#esempio","title":"Esempio","text":"<p>Produzioni monotone:</p> <ul> <li>\\(AB \\to CDEF\\);</li> <li>\\(CB \\to BC\\).</li> </ul> <p>Una produzione monotona pu\u00f2 essere sostituita da una sequenza di produzioni contestuali senza alterare il linguaggio generato; la prima produzione pu\u00f2 essere sostituita dalle seguenti produzioni contestuali:</p> <ul> <li>\\(AB \\to AG\\);</li> <li>\\(AG \\to CG\\);</li> <li>\\(CG \\to CDEF\\).</li> </ul> <p>La seconda produzioni, pu\u00f2 essere sostituita dalle seguenti produzioni contestuali:</p> <ul> <li>\\(CB \\to XB\\);</li> <li>\\(XB \\to XC\\);</li> <li>\\(XC \\to BC\\);</li> </ul> <p>oppure</p> <ul> <li>\\(CB \\to X_1 B\\)</li> <li>\\(X_1 B \\to X_1 X_2\\);</li> <li>\\(X_1 X_2 \\to X_1 C\\);</li> <li>\\(X_1 C \\to BC\\);</li> </ul>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#proposizione","title":"Proposizione","text":"<p>La classe dei linguaggi contestuali coincide con la classe dei linguaggi monotoni.</p> <p>Tale proposizione deriva immediatamente dal teorema seguente</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#teorema","title":"Teorema","text":"<p>Sia \\(G\\) una grammatica monotona, ovvero tale che ogni produzione di \\(G\\) \u00e8 della forma \\(v \\to w\\), con \\(\\abs{v} \\to \\abs{w}\\), eccetto che \u00e8 possibile un'unica \\(\\lambda\\)-produzione \\(S \\to \\lambda\\) se \\(S\\) non appare alla destra di una produzione. Esiste allora una grammatica context-sensitive \\(G'\\) equivalente a \\(G\\), ovvero tale che \\(L(G) = L(G')\\).</p> <p>\u00c8 possibile enunciare il teorema nel seguente modo:</p> <p>Un linguaggio \\(L\\) \u00e8 dipendente da contesto se e solo se \\(\\exists G : L = L(G)\\) e ogni produzione di \\(G\\) nella forma \\(u \\to v\\) ha la propriet\u00e0 \\(0 &lt; \\abs{u} \\leq \\abs{v}\\), con una sola eccezione: se \\(\\lambda \\in L(G)\\) allora \\(S \\to \\lambda\\) \u00e8 una produzione di \\(G\\) e in tal caso \\(S\\) non pu\u00f2 comparire nella parte destra di altre produzioni.</p>"},{"location":"Anno_I/Linguaggi_di_Programmazione/03_linguaggi_CF_e_non/#dimostrazione","title":"Dimostrazione","text":"<p>\\(\\implies\\)</p> <p>Se \\(L\\) \u00e8 dipendente da contesto allora, per definizione, esiste \\(G\\) dipendente da contesto tale che \\(L = L(G)\\):</p> \\[     L \\text{ context-sensitive} \\deff     \\exists G \\text{ context-sensitive } : L = L(G) \\] <p>allora ogni produzione di \\(G\\) \u00e8 in una delle seguenti due forme:</p> <ol> <li>\\(yAz \\to ywy\\) con \\(A \\in V,\\; y,z \\in \\XuVast,\\; w \\in \\XuVplus\\);</li> <li>\\(S \\to \\lambda\\) con \\(S\\) che non compare nelle parte destra di alcuna    produzione.</li> </ol> <p>Dunque, ogni produzione di \\(G\\) verifica la condizione \\(u \\to v\\), con \\(0 &lt; \\abs{u} \\leq \\abs{v}\\) se \u00e8 del tipo 1., mentre con \\(S\\) che non compare a destra di alcuna produzione se \u00e8 del tipo 2. ricade nell'eccezione. Pertanto la grammatica \\(G\\) \u00e8 quella cercata.</p> <p>\\(\\impliedby\\)</p> <p>Sia \\(G\\) una grammatica in cui ogni produzione \u00e8 nella forma \\(u \\to v\\) con \\(0 &lt; \\abs{u} \\leq \\abs{v}\\). Senza ledere alla generalit\u00e0 della dimostrazione, \u00e8 possibile supporre che una generica produzione di \\(G\\) sia del tipo:</p> \\[     A_1 A_2 \\dots A_m \\to B_1 B_2 \\dots B_n \\; m \\leq n \\] <p>con \\(A_i \\in V,\\; i = 1, 2, \\dots, m\\). \u00c8 legittimo affermare ci\u00f2 in quanto, se \\(A_j\\) fosse un simbolo terminale, sarebbe possibile sostituirlo nella produzione con un nuovo simbolo non-terminale e aggiungere la nuova produzione \\(A_j' \\to A_j\\).</p> <p>Si denotino con \\(C_1,\\, C_2,\\, \\dots,\\, C_m\\) gli \\(m\\) simboli non-terminali non presenti in \\(G\\). Utilizzando i \\(C_k\\) simboli, con \\(k = 1, 2, \\dots, m\\) per costruire le nuove regole contestuali che riscrivono la stringa \\(A_1 A_2 \\dots A_m\\) con \\(B_1 B_2 \\dots B_n\\), si ha:</p> \\[     \\left.\\begin{array}{@{}ll@{}}         A_1\\, A_2 \\dots A_m \\to C_1\\, A_2 \\dots A_m                 \\\\         C_1\\, A_2 \\dots A_m \\to C_1\\, C_2\\, A_3 \\dots A_m           \\\\         \\vdots                                                      \\\\         C_1\\, C_2 \\dots C_{m-1}\\, A_m \\to               C_1\\, C_2 \\dots C_{m-1}\\, C_m\\, B_{m+1} \\dots B_n     \\\\         C_1\\, C_2 \\dots C_{m-1}\\, C_m\\, B_{m+1} \\dots B_n \\to               C_1\\, C_2 \\dots C_{m-1}\\, C_m\\, B_{m+1} \\dots B_n     \\\\         \\vdots                                                      \\\\         C_1\\, B_2\\, \\dots B_n \\to B_1\\, B_2 \\dots B_n     \\end{array}\\right\\} \\] <p>La nuova grammatica che incorpora queste produzioni \u00e8 contestuale e si pu\u00f2 dimostrare che \\(L(G) = L(G')\\).</p> <ol> <li> <p>\\(S \\to \\lambda\\) \u00e8 una produzione context-sensitive e \\(S\\) non compare a destra di un'altra produzione.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Programmazione/","title":"Appunti del corso di Programmazione","text":"<p>Corso tenuto da Fabio Abbattista (fabbattista@gmail.com).</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/","title":"Introduzione ai calcolatori","text":""},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistemi-di-elaborazione-dellinformazione","title":"Sistemi di elaborazione dell'informazione","text":"<p>Gli elementi principali di un sistema di calcolo si suddividono in 2 categorie:</p> Hardware La parte fisica dell'elaboratore che \u00e8 costituita da componenti elettronici e   elettromagnetici Software Tutti i programmi che consentono all'Hardware di realizzare specifici compiti <p>Senza Hardware il Software \u00e8 inutile e viceversa. Questi si completano.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#software","title":"Software","text":"<p>Vi sono due tipi di software</p> Software di base Funzionale all'utilizzo dell'elaboratore e di tutte le sue periferiche, questo   comprende sia il sistema operativo, che i programmi che traducono i linguaggi   di programmazione. Software applicativo Mostra all'utente il calcolatore come una macchina virtuale che \u00e8 possibile   utilizzare per la risoluzione di problemi specifici. <p>Il Software applicativo comprende tutte le applicazioni che l'utente utilizza come giochi, fogli elettronici, editor di testo, etc.</p> <p>\u00c8 necessario saper utilizzare correttamente il sistema operativo poich\u00e9 saper impostare la macchina al meglio \u00e8 fondamentale.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#architettura-di-un-calcolatore","title":"Architettura di un calcolatore","text":"<p>I componenti fondamentali dell'architettura dei calcolatori sono:</p> <ul> <li>Unit\u00e0 centrale di elaborazione (CPU) che preleva le istruzioni dalla memoria   e le esegue, dunque legge e/o scrive dati dalla memoria;</li> <li>Memoria principale (RAM, ROM) che contiene i dati e le istruzioni dei   programmi;</li> <li>Memoria secondaria o di massa (HDD, CD, DVD, ecc.) per memorizzare dati e   programmi in maniera permanente;</li> <li>Dispositivi di input (tastiera, mouse, touch pad, ecc.) per l\u2019inserimento dei   dati;</li> <li>Dispositivi di output (monitor, stampante, ecc.) per ricevere i risultati.</li> </ul> <p>Ogni calcolatore \u00e8 progettato secondo l'architettura di Von Neumann</p> <pre><code>flowchart LR\n  mem[Memory] &lt;--&gt; CPU;\n  in[Input] --&gt; CPU;\n  CPU --&gt; out[Output];\n\n  subgraph CPU\n    co[Control Unit] &lt;--&gt; alu[ALU];\n  end</code></pre> <p>Dove ALU sta per Unit\u00e0 Logica Aritmetica.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria","title":"Memoria","text":"<p>Vi sono due tipi di memoria: memoria principale, chiamata RAM (Random Access Memory) e la memoria ROM (Read Only Memory).</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria-principale-ram","title":"Memoria Principale (RAM)","text":"<p>La memoria principale contiene i dati e le istruzioni che il processore deve elaborare. Se lo spazio della RAM \u00e8 esaurito, il programma verr\u00e0 eseguito molto lentamente oppure non verr\u00e0 eseguito. L'elemento base della memoria principale \u00e8 la cella di memoria, la quale ha delle caratteristiche specifiche:</p> <ul> <li>Pu\u00f2 assumere solo due stati: \\(0\\) oppure \\(1\\);</li> <li>\u00c8 possibile scrivere nella cella per cambiarne lo stato;</li> <li>\u00c8 possibile leggere lo stato della cella.</li> </ul> <p>La cella di memoria da sola non \u00e8 molto utile ed \u00e8 per questo motivo che vengono organizzate in locazioni di memoria da \\(8\\), \\(16\\) o anche pi\u00f9 celle. Lavorando con questi dati si ha a che fare con \\(8\\), \\(16\\), etc. byte. La singola cella viene chiamata bit, dunque una cella equivale a \\(1\\bbit\\). Ogni locazione di memoria \u00e8 individuata da un indirizzo univoco che permette di specificarne la posizione. Lavorando con le locazioni di memoria si lavora indirettamente anche con questo indirizzo.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria-rom","title":"Memoria ROM","text":"<p>La ROM \u00e8 una memoria a sola lettura e contiene delle informazioni permanenti e non modificabili. Spesso utilizzata per memorizzare istruzioni di sistema, ad esempio le istruzioni necessarie per avviare il sistema operativo e per il riconoscimento delle periferiche.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#memoria-di-massa","title":"Memoria di Massa","text":"<p>Detta anche memoria secondaria, viene utilizzata per memorizzare grandi volumi di dati in modo persistente.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#codici-di-caratteri","title":"Codici di caratteri","text":"<p>Un codice di caratteri \u00e8 un codice alfabetico, ovvero un insieme di caratteri e pu\u00f2 comprendere caratteri alfabetici (minuscoli e maiuscoli), caratteri numerici, segni di punteggiatura, altri simboli stampabili e caratteri di controllo.</p> <p>I due principali codici di caratteri sono ASCII e UNICODE.</p> <p>Questi codici di caratteri servono alla macchina per capire come interpretare le stringhe di \\(0\\) e \\(1\\) in caratteri.</p> <p>Con il codice ASCII si hanno a disposizione \\(256\\) simboli distinti</p> <p>I primi \\(32\\) simboli sono caratteri di controllo e hanno codici che vanno da \\(0\\) a \\(31\\), sempre sotto forma di \\(0\\) e \\(1\\). I simboli sono \\(256\\) poich\u00e9 con \\(8\\) bit \u00e8 possibile rappresentare da \\(0\\) a \\(255\\) combinazioni differenti. Inizialmente il codice ASCII utilizzava \\(7\\bbit\\), in seguito l'ASCII esteso porta il numero di bit a \\(8\\).</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistemi-di-numerazione","title":"Sistemi di numerazione","text":"<p>\u00c8 un insieme di simboli (cifre) e regole che assegnano ad ogni sequenza di cifre uno e un solo valore numerico. Questo pu\u00f2 essere:</p> <ul> <li>non posizionale, come ad esempio il sistema di numerazione degli antichi romani;</li> <li>posizionale, come ad esempio il sistema di numerazione decimale.</li> </ul>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistema-di-numerazione-posizionale","title":"Sistema di numerazione posizionale","text":"<p>Il sistema di numerazione posizionale \u00e8 un sistema di numerazione in cui ogni cifra ha un valore diverso a seconda della sua posizione. Il sistema di numerazione decimale \u00e8 un sistema di numerazione posizionale. Dato un numero \\(b &gt; 1\\) detto base e un insieme di \\(n\\) cifre \\(I = \\{0, 1, 2, \\dots, n-1\\}\\), una stringa di \\(n\\) simboli \\(x_{n-1}, x_{n-2}, \\cdots, x_1, x_0\\) si interpreta come:</p> \\[     x_{n-1} \\cdot b^{n-1} + x_{n-2} \\cdot b^{n-2}                           + \\cdots + x_1 \\cdot b^1                           +  x_0 \\cdot b^0 \\]"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistema-di-numerazione-decimale","title":"Sistema di numerazione decimale","text":"<p>Nel sistema di numerazione decimale la base \u00e8 \\(10\\) e le cifre sono \\(0,\\ 1, \\dots, 9\\). Ad esempio la stringa \\(2014\\) rappresenta il numero</p> \\[ 2 \\cdot 10^3 + 0 \\cdot 10^2 + 1 \\cdot 10^1 + 4 \\cdot 10^0 \\]"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#sistema-di-numerazione-binario","title":"Sistema di numerazione binario","text":"<p>Nel sistema di numerazione binario la base \u00e8 \\(2\\) e le cifre sono \\(0, 1\\). Ad esempio la stringa \\(11110\\) rappresenta il numero</p> \\[ 1 \\cdot 2^4 + 1 \\cdot 2^3 + 1 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0 \\] <p>che equivale a \\(30\\) nel sistema decimale.</p>"},{"location":"Anno_I/Programmazione/00_introduzione_ai_calcolatori/#conversione-da-decimale-a-binario","title":"Conversione da decimale a binario","text":"<p>La conversione di un numero da base \\(10\\) a base \\(2\\) \u00e8 un processo iterativo che consiste nel dividere il numero per \\(2\\) e prendere il resto della divisione. Il risultato della divisione viene utilizzato come nuovo numero da dividere per \\(2\\) e cos\u00ec via fino a quando il risultato della divisione non \u00e8 \\(0\\). I resti delle divisioni vengono riportati in ordine inverso.</p> <p>Esempio</p> <p>Convertiamo:</p> Numero \\(7\\)Numero \\(14\\) Text Only<pre><code>7/2 = 3, resto 1\n3/2 = 1, resto 1\n1/2 = 0, resto 1\n</code></pre> <p>Il numero \\(7\\) in binario \u00e8 \\(111\\)</p> Text Only<pre><code>14/2 = 7 resto 0\n7/2 = 3 resto 1\n3/2 = 1 resto 1\n1/2 = 0 resto 1\n</code></pre> <p>Il numero \\(14\\) in binario \u00e8 \\(1110\\).</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/","title":"Problem Solving","text":""},{"location":"Anno_I/Programmazione/01_problem_solving/#il-metodo-di-sviluppo-del-software","title":"Il metodo di sviluppo del Software","text":"<p>Per sviluppare Software \u00e8 necessario seguire i seguenti passaggi:</p> <ol> <li>Specificare i requisiti del problema;</li> <li>Analizzare il problema;</li> <li>Progettare la sequenza di istruzioni per risolvere il problema;</li> <li>Realizzare la sequenza di azioni;</li> <li>Fare il test e la verifica del programma;</li> <li>Fare la manutenzione e l'aggiornamento del programma.</li> </ol> <p>Analizziamo questi passaggi in dettaglio.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#specificare-i-requisiti-del-problema","title":"Specificare i requisiti del problema","text":"<p>\u00c8 necessario specificare il problema in maniera non ambigua eliminando tutti gli aspetti non importanti e specificando tutti quelli che sono necessari per risolvere il problema.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#analizzare-il-problema","title":"Analizzare il problema","text":"<p>L'analisi del problema \u00e8 una fase fondamentale per risolvere il problema. In questa fase si devono identificare i dati da elaborare (input), i risultati desiderati (output), gli eventuali vincoli tra i dati e, infine, il formato di presentazione dei risultati.</p> <p>In questo modo si individuano i dati utili e quelli inutili, si individuano i vincoli tra i dati e si individuano i dati che possono essere calcolati a partire da altri dati.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#progettare-la-sequenza-di-istruzioni-per-risolvere-il-problema","title":"Progettare la sequenza di istruzioni per risolvere il problema","text":"<p>Una volta individuati i dati utili e quelli inutili, i vincoli tra i dati e i dati che possono essere calcolati a partire da altri dati, si pu\u00f2 procedere al progetto della sequenza di istruzioni per risolvere il problema.</p> <p>Per fare ci\u00f2 \u00e8 necessario individuare la sequenza di azioni da eseguire per risolvere il problema, ovvero l'algoritmo. \u00c8 inoltre necessario verificare manualmente che l'algoritmo sia corretto.</p> <p>Nello scrivere l'algoritmo \u00e8 preferibile procedere in maniera Top-Down, individuando inizialmente i passi principali e poi risolvere ognuno di questi separatamente.</p> <p>\u00c8 importante non utilizzare termini ambigui e non utilizzare termini tecnici che non siano stati definiti, come ad esempio sintassi di altri linguaggi di programmazione.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#realizzare-la-sequenza-di-azioni","title":"Realizzare la sequenza di azioni","text":"<p>Una volta individuato l'algoritmo, si pu\u00f2 procedere alla realizzazione del programma. Per fare ci\u00f2 \u00e8 necessario tradurre l'algoritmo in un linguaggio di programmazione.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#fare-il-test-e-la-verifica-del-programma","title":"Fare il test e la verifica del programma","text":"<p>\u00c8 sicuramente l'operazione pi\u00f9 costosa a livello di tempo e risorse. \u00c8 necessario testare il programma in modo da verificare che questo risolva il problema in maniera corretta.</p> <p>Ad esempio, un programma che calcola la somma di due numeri deve essere testato con numeri positivi, negativi, decimali, con numeri molto grandi e con numeri molto piccoli. \u00c8 possibile dire che funzioner\u00e0 con tutti i numeri? \u00c8 impossibile dirlo con certezza poich\u00e9 i numeri sono infiniti; \u00e8 per\u00f2 possibile essere certi che il programma funzioner\u00e0 nel \\(99.9\\%\\) dei casi.</p> <p>Un altro esempio \u00e8 il programma Microsoft PowerPoint. Quest'ultimo presenta innumerevoli funzionalit\u00e0 e questo porta ad avere altrettanti problemi.</p> <p>A volte questa fase pu\u00f2 impiegare mesi per programmi molto complessi e imponenti.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#fare-la-manutenzione-e-laggiornamento-del-programma","title":"Fare la manutenzione e l'aggiornamento del programma","text":"<p>Una volta che il programma \u00e8 stato testato, verificato e rilasciato al pubblico, \u00e8 necessario fare la manutenzione e l'aggiornamento del programma.</p> <p>Ad esempio, tempo fa, i programmi di contabilit\u00e0 codificavano al loro interno il valore dell'IVA. Questo comportava che ogni volta che l'IVA venisse modificata, tutti i programmi di contabilit\u00e0 dovevano essere modificati.</p> <p>L'alternativa sarebbe quella di lasciare che l'utenza inserisca il valore dell'IVA e di utilizzare questo valore per calcolare i prezzi. Se invece si vuole mantenere il pieno controllo del programma, codificarlo \u00e8 l'unico modo.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#metodi-di-descrizione-degli-algoritmi","title":"Metodi di descrizione degli algoritmi","text":"<p>I metodi di descrizione degli algoritmi sono molteplici e sono semplicemente delle convenzioni. Il metodo che utilizzeremo \u00e8 lo pseudo-codice. Sono presenti anche flowchart, etc.</p> <p>Lo -pseudo che utilizzeremo possiede una sintassi ben precisa e, ad esempio, non \u00e8 presente l'istruzione <code>goto</code>. \u00c8 possibile inserire un numero per ogni riga ma non \u00e8 obbligatorio.</p> <p>Come prima cosa bisogna elencare i dati in ingresso e in uscita.</p> <p>Ogni rigo ospita un dato differente con: nome del dato, descrizione dello stesso, tipo di dato<sup>1</sup> e vincoli, in questo preciso ordine.</p> <p>Il nome del dato \u00e8 arbitrario, per\u00f2 \u00e8 necessario che sia rappresentativo del dato stesso. \u00c8 possibile utilizzare lettere singole, anche se non \u00e8 consigliabile<sup>2</sup>.</p> <p>Example</p> <p>Ad esempio, nel convertire un numero da binario a decimale, scriveremo:</p> <p>\u274c numero binario, numero binario</p> <p>\u2714\ufe0f numero binario, numero binario da convertire a decimale</p> <p>In generale, la descrizione del dato deve essere pi\u00f9 dettagliata possibile e pi\u00f9 lunga del nome del dato. Dopo aver scritto la descrizione \u00e8 consigliabile rileggerla circa due volte e cercare di aggiungere informazioni.</p> <p>Per poter scrivere queste informazioni \u00e8 necessario un minimo lavoro di analisi poich\u00e9 non \u00e8 scontato che la traccia del problema fornisca tutte le informazioni necessarie.</p>"},{"location":"Anno_I/Programmazione/01_problem_solving/#esempio-convertire-da-miglia-a-chilometri","title":"Esempio: convertire da miglia a chilometri","text":"<p>Problema:</p> <p>convertire da miglia a chilometri.</p> <p>Analisi:</p> <p>\u00c8 necessario capire cosa fare: dobbiamo convertire dei valori da un sistema di misura ad un altro, ovvero da miglia a chilometri. Il dato da elaborare \u00e8 quindi una distanza in miglia. Il risultato desiderato \u00e8 la distanza in chilometri.</p> <p>Per poter risolvere il problema \u00e8 necessario conoscere la relazione esistente tra miglia e chilometri: \\(1\\,{\\rm mi} = 1.609\\,{\\rm km}\\).</p> INPUT miglio, la distanza espressa in miglia OUTPUT chilometro, la distanza espressa in chilometri VINCOLI \\(1\\,{\\rm mi} = 1.609\\,{\\rm km}\\) <p>Progettazione:</p> <p>Un algoritmo iniziale potrebbe essere simile al seguente:</p> Algoritmo iniziale<pre><code>Acquisire la distanza in miglia\nConvertire la distanza in chilometri\nVisualizzare la distanza in chilometri\n</code></pre> <p>Il primo e ultimo passo non necessitano di ulteriori raffinamenti, per\u00f2 il secondo passo pu\u00f2 essere migliorato. \u00c8 possibile scrivere: la distanza in chilometri \u00e8 uguale a \\(1.609\\) volte la distanza in miglia.</p> Algoritmo con raffinamenti<pre><code>Acquisire la distanza in miglia\nConvertire la distanza in chilometri\n    La distanza in chilometri \u00e8 uguale a 1.609 volte la distanza in miglia\nVisualizzare la distanza in chilometri\n</code></pre> <p>(Esercizio analisi e progettazione di come cucinare la pasta al forno)</p> <ol> <li> <p>Con tipo di dato non si intendono i tipi del C o di altri linguaggi di programmazione, ma semplicemente il tipo di dato che si vuole utilizzare (numero intero, numero reale, stringa, etc.).\u00a0\u21a9</p> </li> <li> <p>Questo \u00e8 generalmente vero, ma nei casi dei contatori \u00e8 possibile utilizzare lettere singole.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Programmazione/02_algoritmo_euclide/","title":"Algoritmo di Euclide","text":"<p>L'algoritmo di Euclide \u00e8 un algoritmo per calcolare il massimo comun divisore di due numeri interi positivi. Dunque, dati due numeri interi \\(a, b\\) calcolare \\(\\mcd(a, b)\\).</p> Input \\(a, b\\) \u2013 coppia di numeri interi maggiori di zero Output \\(\\mcd{}\\) \u2013 massimo comun divisore di \\(a\\) e \\(b\\), numero intero maggiore   di zero <p>L'algoritmo di Euclide si basa sulle seguenti propriet\u00e0:</p> <ol> <li>Se \\(a = b\\) allora \\(\\mcd(a, b) = a = b\\);</li> <li>Se \\(a &gt; b\\) allora \\(\\mcd(a, b) = \\mcd(a - b, b)\\);</li> <li>Se \\(a &lt; b\\) allora \\(\\mcd(a, b) = \\mcd(a, b - a)\\).</li> </ol>"},{"location":"Anno_I/Programmazione/02_algoritmo_euclide/#considerazioni","title":"Considerazioni","text":"<p>La prima propriet\u00e0 afferma che il massimo comun divisore di due numeri uguali \u00e8 uno qualunque dei due numeri. La seconda e terza propriet\u00e0 affermano che il massimo comun divisore di due numeri diversi si pu\u00f2 ricondurre al calcolo del massimo comun divisore del pi\u00f9 piccolo dei due numeri e della differenza tra il pi\u00f9 grande e il pi\u00f9 piccolo.</p> <p>Queste propriet\u00e0 non sono l'algoritmo di risoluzione del problema, ma sono un'idea di come risolvere il problema. Queste propriet\u00e0 non dicono quando fermarsi o quando ripetere un'operazione.</p>"},{"location":"Anno_I/Programmazione/02_algoritmo_euclide/#pseudo-codifica","title":"Pseudo codifica","text":"<p>Poich\u00e9 valgono le propriet\u00e0 precedenti, nel caso generale si possono calcolare tante differenze in modo da riportarsi al caso \\(a = b\\), per il quale il problema \u00e8 risolto. Il calcolo delle differenze deve essere ripetuto se risulta vero che \\(a\\) sia diverso da \\(b\\). Si pu\u00f2 utilizzare una iterazione a condizione iniziale.</p> <p>Dunque:</p> Algoritmo di Euclide<pre><code>MENTRE (a != b)\n    SE (a &gt; b)\n        ALLORA assegna ad a il valore di a - b\n        ALTRIMENTI assegna ad b il valore di b - a\n    FINE\nFINE\n</code></pre> <p>Il blocco <code>MENTRE</code> indica una ripetizione di un blocco di istruzioni. Viene ripetuto tutto ci\u00f2 che \u00e8 contenuto fra <code>MENTRE</code> e <code>FINE</code> fino a quando la condizione non risulti falsa. Nel caso in cui il mentre provochi un ciclo infinito, l'algoritmo \u00e8 errato. \u00c8 comunque presente un salto ma non \u00e8 paragonabile a quello del <code>GOTO</code> poich\u00e9 \u00e8 nascosto, non arbitrario e controllato da una condizione. Nel blocco <code>MENTRE</code> si verifica la condizione iniziale, se \u00e8 vera allora si procede col ciclo, altrimenti si esce dal ciclo; una volta terminata la prima iterazione si verifica nuovamente la condizione iniziale, se \u00e8 vera si ripete il ciclo, altrimenti si esce dal ciclo e cos\u00ec via.</p> <p>Ad esempio, se i due numeri fossero minori di zero, il ciclo non terminerebbe mai. In questo caso, l'algoritmo \u00e8 errato. \u00c8 necessario che, durante la stesura dell'algoritmo, si verifichi che non ci siano cicli infiniti. Questo \u00e8 possibile verificando che la condizione di uscita dal ciclo si avveri.</p> <p>Il blocco <code>SE</code> presenta una condizione che pu\u00f2 essere vera o falsa. Se la condizione \u00e8 vera, allora viene eseguito il blocco <code>ALLORA</code> e il blocco <code>ALTRIMENTI</code> viene ignorato. Se la condizione \u00e8 falsa, allora viene eseguito il blocco <code>ALTRIMENTI</code> e il blocco <code>ALLORA</code> viene ignorato. Il blocco <code>SE</code> pu\u00f2 essere utilizzato anche senza il blocco <code>ALTRIMENTI</code>.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/","title":"Notazione Lineare","text":"<p>Chiamiamo algoritmo un metodo risolutivo per un problema, descritto da un insieme di operazioni elementari o istruzioni. In altre parole un algoritmo \u00e8 una sequenza finita di passi elementari che definiscono un procedimento mediante il quale \u00e8 possibile risolvere un problema. Un passo elementare \u00e8 chiamato anche operazione elementare oppure azione elementare oppure istruzione.</p> <p>Una operazione si dice elementare se:</p> <ul> <li>\u00e8 interpretata in modo univoco dall'esecutore;</li> <li>\u00e8 direttamente eseguita dall'esecutore (uomo o macchina).</li> </ul> <p>Cio\u00e8 l'esecutore comprende in modo univoco che cosa deve fare e sa come farlo.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#proprieta-di-un-algoritmo","title":"Propriet\u00e0 di un algoritmo","text":"<p>Un algoritmo gode necessariamente delle seguenti propriet\u00e0:</p> Non ambiguit\u00e0 ogni operazione descritta nell'algoritmo deve essere interpretata in modo univoco dall'esecutore. Eseguibilit\u00e0 l'esecutore deve essere in grado di eseguire ogni operazione descritta nell'algoritmo in un tempo finito. Finitezza Il numero di operazioni descritte nell'algoritmo deve essere finito e l'esecuzione di quest'ultimo deve terminare in un tempo finito. Generalit\u00e0 Deve produrre un risultato per ogni valore attribuito ai dati iniziali, cio\u00e8 un algoritmo deve risolvere tutti i problemi di una stessa classe"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#specifica-di-un-algoritmo","title":"Specifica di un algoritmo","text":"<p>In un algoritmo il risolutore descrive le operazioni necessarie per risolvere un problema ed anche l'ordine con cui le istruzioni devono essere eseguite</p> <p>In un algoritmo occorre specificare:</p> <ul> <li>L'elenco degli oggetti da manipolare (dati iniziali) e l'elenco delle   informazioni finali (risultati)</li> <li>L'insieme delle azioni da eseguire</li> <li>L'ordine esatto con cui le azioni devono essere eseguite e le condizioni che   devono essere verificate perch\u00e9 ad una azione ne segua una piuttosto che un   altro.</li> </ul> <p>Un algoritmo pu\u00f2 essere specificato mediante:</p> <ul> <li>linguaggio naturale (pseudo-codice);</li> <li>diagrammi di flusso (descrizione grafica);</li> <li>linguaggio di programmazione (codifica).</li> </ul> <p>Per specificare un algoritmo \u00e8 necessario evidenziare:</p> <ul> <li>i dati di ingresso e di uscita;</li> <li>le operazioni elementari;</li> <li>l'ordine in cui le operazioni elementari devono essere eseguite.</li> </ul>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#linguaggio-naturale","title":"Linguaggio naturale","text":"<p>Un algoritmo viene descritto con frasi di un linguaggio naturale (italiano, inglese). Le operazioni elementari sono descritte tramite l'utilizzo di nomi, verbi ed espressioni. Le operazioni sono scelte in relazione al problema da risolvere. I nomi, invece, denotano i dati.</p> <p>Le strutture di controllo o schemi di composizione delle istruzioni sono definite mediante l'utilizzo di parole chiave ben definite che vedremo in seguito.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#strutture-di-controllo","title":"Strutture di controllo","text":"<p>Esse hanno lo scopo di comporre le istruzioni in modo da ottenere un algoritmo, definiscono cio\u00e8 l'ordine in cui le istruzioni devono essere eseguite.</p> <p>Le strutture fondamentali di controllo sono le seguenti:</p> <ul> <li>sequenza;</li> <li>selezione;</li> <li>iterazione.</li> </ul>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#sequenza","title":"Sequenza","text":"<p>La sequenza permette di comporre ede eseguire le istruzioni una di seguito all'altra. Le istruzioni vengono sempre eseguite nell'ordine in cui sono state poste.</p> <p>Un esempio di sequenza \u00e8 il seguente:</p> Text Only<pre><code>sollevare il ricevitore\nattendere il segnale di linea\ncomporre il numero\nattendere la risposta\ncondurre la conversazione\ndeporre il ricevitore\n</code></pre> <p>Il precedente \u00e8 un algoritmo per effettuare una telefonata.</p> <p>Questo termina in un tempo finito? Nonostante il numero di operazioni sia finito, l'esecuzione dell'algoritmo non termina in un tempo finito. Infatti, l'algoritmo non specifica il caso in cui la linea sia occupata e non si possa effettuare la chiamata o ancora, il caso in cui il numero chiamato non risponda. In questi casi l'algoritmo non termina mai.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#selezione-binaria","title":"Selezione binaria","text":"<p>La selezione binaria permette di comporre ed eseguire le istruzioni in base ad una condizione. Se la condizione \u00e8 vera, allora viene eseguita una sequenza di istruzioni, altrimenti viene eseguita un'altra sequenza di istruzioni.</p> <p>La scelta viene effettuata sulla base di un'istruzione booleana o di una condizione<sup>1</sup>.</p> <p>Il costrutto della selezione binaria \u00e8 il seguente:</p> Text Only<pre><code>SE (condizione)\n    ALLORA &lt;istruzioni&gt;\n    ALTRIMENTI &lt;istruzioni&gt;\nFINE\n</code></pre> <p>Le istruzioni che seguono la parola chiave <code>SE</code> vengono eseguite se la condizione \u00e8 vera, altrimenti vengono eseguite le istruzioni che seguono la parola chiave <code>ALTRIMENTI</code>.</p> <p>Un esempio di selezione binaria \u00e8 il seguente:</p> Text Only<pre><code>SE (a &lt; b)\n    ALLORA massimo := b\n    ALTRIMENTI massimo := a\nFINE\n</code></pre> <p>Il precedente algoritmo determina il massimo tra due numeri interi.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#iterazione-a-condizione-iniziale","title":"Iterazione a condizione iniziale","text":"<p>L'iterazione a condizione iniziale permette di comporre ed eseguire le istruzioni ripetutamente fino a quando una condizione diventa falsa. La condizione viene verificata prima dell'esecuzione della sequenza di istruzioni. Se la condizione \u00e8 falsa, allora le istruzioni non vengono eseguite.</p> <p>Il costrutto dell'iterazione a condizione iniziale \u00e8 il seguente:</p> Text Only<pre><code>MENTRE (&lt;condizione&gt;)\n    &lt;istruzioni&gt;\nFINE\n</code></pre> <p>Un esempio di iterazione a condizione iniziale \u00e8 il seguente:</p> Text Only<pre><code>p := 1\nmassimo := p-esimo elemento di E\nMENTRE (p &lt;= n)\n    p = p + 1\n    SE (massimo &lt; p-esimo elemento di E)\n        ALLORA massimo := p-esimo elemento di E\n    FINE\nFINE\n</code></pre> <p>Il precedente algoritmo determina il massimo tra i numeri interi contenuti in un insieme, con l'ipotesi che l'insieme non sia vuoto. Nell'algoritmo, <code>p</code> \u00e8 un contatore che indica l'elemento corrente dell'insieme, <code>n</code> \u00e8 il numero di elementi dell'insieme, <code>E</code> \u00e8 l'insieme di numeri interi.</p>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#iterazione-a-condizione-finale","title":"Iterazione a condizione finale","text":"<p>L'iterazione a condizione finale permette di comporre ed eseguire le istruzioni ripetutamente fino a quando una condizione diventa falsa. La condizione viene, per\u00f2, controllata dopo l'esecuzione della sequenza di istruzioni.</p> <p>Il costrutto dell'iterazione a condizione finale \u00e8 il seguente:</p> Text Only<pre><code>ESEGUI\n    &lt;istruzioni&gt;\nFINCH\u00c9 (&lt;condizione&gt;)\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/03_notazione_lineare/#equivalenza","title":"Equivalenza","text":"<p>Due algoritmi si dicono equivalenti se:</p> <ul> <li>hanno lo stesso dominio di definizione;</li> <li>hanno lo stesso dominio immagine;</li> <li>in corrispondenza degli stessi valori nel dominio di definizione producono gli   stessi valori nel dominio immagine.</li> </ul> <p>Dunque, due algoritmi equivalenti, nonostante possano essere diversi e avere diversa efficienza, forniranno lo stesso risultato.</p> <ol> <li> <p>Una condizione \u00e8 un'espressione che pu\u00f2 assumere il valore vero o falso.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/","title":"Algebra Booleana","text":"<p>L'algebra do Bool opera su delle variabili, per l'appunto booleane, e su dei valori costanti. I valori costanti sono due: vero e falso. Quest'ultimi possono essere rappresentati con 1 e 0, V e F, true e false ma anche T e F.</p> <p>Questi valori costanti sono detti valori booleani e sono molto utili per le condizioni dei costrutti <code>SE</code> e <code>MENTRE</code>.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#operatori","title":"Operatori","text":"<p>Per poter concatenare tra loro pi\u00f9 condizioni si possono utilizzare gli operatori booleani. Questi operatori sono essenzialmente dei costrutti che operano su valori booleani e restituiscono un valore booleano. Questi operatori sono:</p> <ul> <li><code>NOT</code>: negazione, inverte il valore booleano e si scrive con il simbolo <code>\u00ac</code>;</li> <li><code>AND</code>: congiunzione, restituisce vero se entrambi i valori sono veri,   altrimenti restituisce falso e si scrive con il simbolo <code>\u2227</code>;</li> <li><code>OR</code>: disgiunzione, restituisce vero se almeno uno dei due valori \u00e8 vero,   altrimenti restituisce falso e si scrive con il simbolo <code>\u2228</code>;</li> </ul> A B A \u2227 B A \u2228 B V V V V V F F V F V F V F F F F <p>Come \u00e8 possibile constatare, l'operazione <code>AND</code> \u00e8 molto pi\u00f9 restrittiva delle altre, infatti restituisce vero solo se entrambi i valori sono veri. L'operazione <code>OR</code> invece \u00e8 molto pi\u00f9 permissiva, infatti restituisce vero se almeno uno dei due valori \u00e8 vero.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#esempi","title":"Esempi","text":"<p>Con le variabili booleane \u00e8 possibile costruire delle semplici espressioni che restituiscono dei valori booleani, ad esempio:</p> Text Only<pre><code>\u00acB\n\u00ac(A \u2228 B)\n</code></pre> <p>L'operatore <code>NOT</code> \u00e8 s\u00ec utile per negare una condizione, ma \u00e8 molto pi\u00f9 comodo e leggibile utilizzare le condizioni al \"positivo\", ovvero senza negare la condizione. Ad esempio:</p> Text Only<pre><code>\u00ac(a &gt; b) = (a &lt;= b)\n</code></pre> <p>Bisogna fare attenzione alle condizioni booleane, poich\u00e9 \u00e8 possibile che queste non diventino mai false, ad esempio:</p> Text Only<pre><code>(a &gt; 5 ) \u2227 (a &lt;= 10)\n</code></pre> <p>In questo caso si ha che \\(a \\in \\,]5,\\ 10[\\) e nel caso in cui fosse presente un <code>OR</code> al posto dell'<code>AND</code> la condizione non diventerebbe mai falsa.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#asserzioni","title":"Asserzioni","text":"<p>Le asserzioni in un linguaggio di programmazione sono delle espressioni booleane che possono essere utilizzate per:</p> <ul> <li>documentare un programma, descrivendone la semantica;</li> <li>verificare un programma, provandone la correttezza formale.</li> </ul> <p>Le asserzioni possono essere pre-condizioni e post-condizioni</p> <p>La pre-condizione o premessa, \u00e8 un'espressione booleana che deve essere verificata prima di un'istruzione o di un blocco di istruzioni. La post-condizione o conseguenza, \u00e8 un'espressione booleana che deve essere verificata dopo un'istruzione o un blocco di istruzioni.</p>"},{"location":"Anno_I/Programmazione/04_algebra_booleana/#esercizi","title":"Esercizi","text":"<p>Scrivere le espressioni equivalenti alle seguenti senza utilizzare la negazione:</p> <ol> <li><code>(a &gt; b) = (a &lt;= b)</code>;</li> <li><code>((a &lt;= b) \u2227 (c &lt;= d)) = ((a &gt;= b) \u2228 (c &gt;= d))</code>;</li> <li><code>((a &lt; 1) \u2228 (b &lt; 2) \u2227 (c &lt; 3)) = ((a &gt; 1) \u2227 (b &gt; 2) \u2228 (c &gt; 3))</code>.</li> </ol>"},{"location":"Anno_I/Programmazione/05_dati/","title":"I Dati","text":"<p>I dati rappresentano oggetti e propriet\u00e0 della realt\u00e0 rilevanti per il problema in esame. I dati sono un'astrazione degli oggetti del mondo reale, nel senso che:</p> <p>N. Wirth, Algoritmi e strutture dati</p> <p>Alcune propriet\u00e0 e caratteristiche degli oggetti in esame vengono ignorate perch\u00e9 sono irrilevanti e marginali per il particolare problema considerato</p> <p>Il concetto di dati \u00e8 estremamente importante in informatica e la sua comprensione \u00e8 fondamentale per la progettazione di un programma. Durante il processo di progettazione di un programma \u00e8 necessario individuare i dati che sono rilevanti per il problema in esame e descriverli, fornendo una descrizione il quanto pi\u00f9 completa e appropriata possibile.</p> <p>Le caratteristiche che vanno descritte sono solo alcune, come ad esempio il tipo di dato, la quantit\u00e0 dello stesso, etc.</p> <p>Se, ad esempio, si volesse descrivere un algoritmo utile a gestire i dati anagrafici e la carriera degli studenti universitari, un dato fondamentale sarebbe, ovviamente, lo studente stesso. Dati non fondamentali sono, ad esempio: altezza, colore degli occhi o dei capelli, etc. Dati che invece sono fondamentali sono, ad esempio: nome, cognome, data di nascita, luogo di nascita, residenza, sesso, reddito, etc.</p> <p>All'anagrafe, invece, risultano essere utili tutti i dati che riguardano le caratteristiche fisiche dello studente, in pratica l'opposto dell'algoritmo.</p> <p>Informazioni</p> <p>A seconda della situazione, l'oggetto viene descritto (con dei dati), in modo diverso.</p>"},{"location":"Anno_I/Programmazione/05_dati/#dati-semplici","title":"Dati semplici","text":"<p>I dati semplici o elementari rappresentano oggetti, entit\u00e0, propriet\u00e0 elementari o atomiche non decomponibili. Ad esempio:</p> <ul> <li>la misura di un lato di un poligono;</li> <li>il numero di matricola di uno studente;</li> <li>il voto di un esame.</li> </ul>"},{"location":"Anno_I/Programmazione/05_dati/#dati-strutturati","title":"Dati strutturati","text":"<p>I dati strutturati rappresentano oggetti, entit\u00e0, propriet\u00e0 pi\u00f9 complesse, decomponibili in dati elementari. Essi sono aggregati di dati semplici.</p> <p>Esempio</p> StudenteDataPersona Text Only<pre><code>Studente:\n    Matricola;\n    Nome e cognome;\n    Corso di laurea;\n    Universit\u00e0.\n</code></pre> Text Only<pre><code>Data:\n    Giorno;\n    Mese;\n    Anno.\n</code></pre> Text Only<pre><code>Persona:\n    Informazioni fisiche:\n        Altezza;\n        Colore degli occhi;\n        Colore dei capelli;\n        Peso;\n    Informazioni anagrafiche:\n        Nome;\n        Cognome;\n        Data di nascita;\n        Stato civile;\n        Residenza.\n</code></pre> <p>I dati strutturati possono a loro volta essere descritti con altri dati strutturati.</p>"},{"location":"Anno_I/Programmazione/05_dati/#tipi-di-dati","title":"Tipi di dati","text":"<p>Ogni dato \u00e8 caratterizzato da un nome (o identificatore) e da un tipo. Il nome viene utilizzato per identificare univocamente il dato<sup>1</sup> Il tipo di dato \u00e8 legato al contenuto dello stesso, nel caso di dato semplice si tratta del dato stesso, nei casi di dati strutturati si tratta di una descrizione dei dati semplici che lo compongono. Il tipo indica anche le operazioni che possono essere eseguite sul dato.</p> <p>Sui tipi di dati definiti dall'utente, \u00e8 ques'ultimo che deve definire le operazioni che possono essere eseguite.</p> <p>Inoltre, i dati possono essere:</p> <ul> <li>Dati di input</li> <li>Dati di output</li> <li>Dati di lavoro (utilizzati durante l'esecuzione dell'algoritmo)</li> </ul> <ol> <li> <p>\u00c8 consigliabile utilizzare nomi che ricordino il contenuto del dato.\u00a0\u21a9</p> </li> </ol>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/","title":"Metodologia Top-Down","text":"<p>La metodologia di sviluppo di un programma Top-Down riguarda i metodi di risoluzione di un problema, basati sulla decomposizione del problema.</p> <p>Lo stepwise refinement (ovvero raffinamento per passi successivi), \u00e8 una strategia di sviluppo Top-Down proposta da N. Wirth nell'ambito della programmazione strutturata, nell'articolo \"Program Development by Stepwise Refinement\", 1971.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#metodologia-top-down-nellanalisi-del-problema","title":"Metodologia Top-Down nell'analisi del problema","text":"<p>L'analisi Top-Down prevede la scomposizione del problema generale da risolvere in pi\u00f9 sotto-problemi.</p> <p>La scomposizione del problema in sotto-problemi, si ottiene attraverso la decomposizione del problema in sotto-problemi, che a loro volta possono essere decomposti in altri sotto-problemi, e cos\u00ec via.</p> <p>Ognuno di questi sotto-problemi, va analizzato e risolto in modo indipendente dal problema principale. In questo modo, si ottiene una soluzione al problema generale risolvendo i sotto-problemi.</p> <p>Cos\u00ec facendo, il problema generale viene decomposto in sotto-problemi pi\u00f9 semplici del principale. Questi possono essere rappresentati come un albero, in cui il nodo radice rappresenta il problema generale, e i nodi foglia rappresentano i sotto-problemi pi\u00f9 semplici. Quest'albero viene chiamato albero di decomposizione funzionale.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#albero-di-decomposizione","title":"Albero di decomposizione","text":"<p>L'albero di decomposizione funzionale, \u00e8 un albero che rappresenta la scomposizione del problema in sotto-problemi. Ad esempio, il problema iniziale \\(P\\), pu\u00f2 essere decomposto in \\(P_1\\), \\(P_2\\) e \\(P_3\\):</p> <pre><code>flowchart TD\n  P --&gt; P1 &amp; P2 &amp; P3;</code></pre> <p>Nel caso in cui i sotto-problemi \\(P_1\\), \\(P_2\\) e \\(P_3\\) siano a loro volta troppo complessi, possono essere decomposti in altri sotto-problemi.</p> <pre><code>flowchart TD\n  P --&gt; P1 &amp; P2 &amp; P3;\n  P1 --&gt; P1.1 &amp; P1.2;\n  P3 --&gt; P3.1 &amp; P3.2;</code></pre> <p>Quindi si ha che nella radice dell'albero di decomposizione, si ha il problema principale \\(P\\), e i nodi foglia \\(P_{1.1}\\), \\(P_{1.2}\\), \\(P_2\\), \\(P_{3.1}\\) e \\(P_{3.2}\\) si hanno i sotto-problemi pi\u00f9 semplici, considerati pi\u00f9 facilmente risolvibili.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#come-comporre-le-soluzioni-dei-sotto-problemi","title":"Come comporre le soluzioni dei sotto-problemi","text":"<p>Lo scopo del processo di decomposizione, \u00e8 quello di scomporre la soluzione del problema principale nelle soluzioni di altri problemi, ma molto pi\u00f9 semplici e dunque pi\u00f9 facilmente risolvibili.</p> <p>La soluzione per un problema \\(P\\) si ottiene combinando le soluzioni dei suoi sotto-problemi utilizzando le strutture di controllo, ovvero sequenza, selezione e iterazione.</p> <p>La situazione \u00e8 differente se il problema ammette una soluzione ricorsiva.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#specifica-di-un-problema","title":"Specifica di un problema","text":"<p>La specifica di un problema, \u00e8 una descrizione formale del problema, che permette di definire il problema in modo univoco. La specifica di un problema, \u00e8 composta da:</p> <ul> <li>il compito o funzione che il problema richiede che sia svolto;</li> <li>i dati di input e di output.</li> </ul>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#soluzione","title":"Soluzione","text":"<p>La descrizione della soluzione del problema \\(P\\), \u00e8 basata sulla descrizione delle soluzioni dei suoi sotto-problemi, ovvero:</p> <ul> <li>la specifica di ogni singolo sotto-problema (compito/funzione);</li> <li>i dati di input e output di ciascun sotto-problema.</li> </ul>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#metodologia-bottom-up","title":"Metodologia Bottom-Up","text":"<p>La metodologia Bottom-Up, \u00e8 una metodologia di progettazione e sviluppo di un programma che riguarda i metodi di risoluzione di un problema per sintesi, ovvero basandosi sull'interconnessione di componenti gi\u00e0 disponibili.</p> <p>Questo porta alla creazione di componenti standard che possono essere riutilizzati.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#programmazione-in-grande-e-in-piccolo","title":"Programmazione in grande e in piccolo","text":"<p>Il compito della programmazione in grande \u00e8 quello di progettare la struttura del programma come se fosse un insieme di parti, detti moduli.</p> <p>La programmazione in piccolo \u00e8 la fase di sviluppo del programma, in cui si descrivono i singoli moduli, implementando e progettando i singoli algoritmi.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#pseudo-codifica","title":"Pseudo-codifica","text":"<p>Il linguaggio che viene utilizzato per descrivere i singoli algoritmi, \u00e8 detto pseudo-codice. Questo \u00e8 un linguaggio che non \u00e8 un vero linguaggio di programmazione, ma che \u00e8 molto simile ad esso.</p>"},{"location":"Anno_I/Programmazione/06_metodologia_TopDown/#livelli-di-astrazione","title":"Livelli di astrazione","text":"<p>L'algoritmo viene inizialmente espresso in maniera molto astratta, utilizzando il linguaggio naturale (con astrazioni sui controlli, sui tipi di dato e sulle funzioni). Successivamente, si passa ad un livello di astrazione pi\u00f9 basso, utilizzando lo pseudo-codice. Infine, si passa al linguaggio di programmazione</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/","title":"Funzioni e procedure","text":"<p>Come accennato in precedenza, un programma pu\u00f2 essere organizzato in un programma principale e un insieme di sotto-programmi. Ad esempio</p> <pre><code>flowchart TD\n  M --&gt; M1 &amp; M2 &amp; M3;</code></pre> <p>scomponiamo il problema \\(M\\) nei sotto-problemi \\(M_1, M_2, M_3\\)</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#struttura-di-un-programma-in-c","title":"Struttura di un programma in C","text":"<p>Nel C, un programma \u00e8 costituito da una sezione di dichiarazioni globali, dalla funzione <code>main() {}</code> e da altre funzioni, in questo caso \\(f_1\\) e \\(f_2\\).</p> <pre><code>flowchart TD\n  subgraph \"Dichiarazioni Globali\"\n  direction LR;\n    subgraph main; end\n    subgraph f1; end\n    subgraph f2; end\n  end</code></pre> <p>\u00c8 presente un'analogia tra la scomposizione di un problema e la struttura di un programma. Intuitivamente si pu\u00f2 affermare che la soluzione di ciascun sotto-problema sia un sotto-programma a s\u00e8 stante.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#sotto-programmi","title":"Sotto-programmi","text":"<p>Vari linguaggi di programmazione forniscono dei costrutti sintattici per</p> <ul> <li>creare delle unit\u00e0 di programma (sotto-programmi), dando un nome ad un gruppo   di istruzioni;</li> <li>Attivare tali unit\u00e0 con modalit\u00e0 di comunicazione stabilite con l'unit\u00e0   chiamante.</li> </ul>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#caratteristiche-di-un-sotto-programma","title":"Caratteristiche di un sotto-programma","text":"<p>Un sotto-programma \u00e8:</p> <ul> <li>identificato da un nome;</li> <li>costituito da istruzioni.</li> </ul> <p>Generalmente con gli stessi costrutti di un programma, ovvero dichiarazioni e blocco delle dichiarazioni eseguibili</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#attivazione-o-chiamata-di-un-sotto-programma","title":"Attivazione o chiamata di un sotto-programma","text":"<p>Un sotto-programma va in esecuzione solo se la sua attivazione viene richiesta da parte di un'altra unit\u00e0 di programma (che sia in grado di rilevare la presenza del sotto-programma).</p> <p>L'attivazione viene richiesta utilizzando il nome del sotto-programma. Tale nome va utilizzato ogni volta che si vuole eseguire quel determinato blocco di istruzioni.</p> <p>I programmi possono essere sia interni che esterni all'unit\u00e0 che li utilizza.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#parametri-di-un-sotto-programma","title":"Parametri di un sotto-programma","text":"<p>I sotto-programmi possono comunicare con l'unit\u00e0 chiamante attraverso i parametri.</p> <p>Il nome del sotto-programma e l'elenco dei suoi parametri vengono dichiarati esplicitamente nell'intestazione dei sotto-programmi, ovvero la prima istruzione del sotto-programma.</p> <p>I parametri consentono di rappresentare i dati di comunicazione tra il sotto-programma e il programma chiamante, ovvero i dati di ingresso e quelli di uscita del sotto-programma.</p> <p>Ogni parametro \u00e8 individuato da un nome e da un tipo. Inoltre, la lista dei parametri va definita in modo esplicito nell'intestazione del sotto-programma.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#attivazione-di-un-sotto-programma","title":"Attivazione di un sotto-programma","text":"<p>Al momento dell'attivazione del sotto-programma:</p> <ol> <li>viene sospesa l'esecuzione dell'unit\u00e0 contenente la richiesta di attivazione    e il controllo passa al sotto-programma attivato;</li> <li>al termine dell'esecuzione, l'attivazione viene terminata e il controllo    ritorna all'unit\u00e0 chiamante.</li> </ol>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#astrazione-funzionale-e-procedurale","title":"Astrazione funzionale e procedurale","text":"<p>Mediante i sotto-programmi \u00e8 possibile ampliare l'insieme degli operatori e delle istruzioni disponibili in un linguaggio di programmazione. I sotto-programmi sono di due tipi:</p> <ul> <li>Funzioni mediante le quali \u00e8 possibile introdurre nuovi operatori (astrazione   funzionale o astrazione della nozione di operatore);</li> <li>Procedure mediante le quali \u00e8 possibile introdurre nuove istruzioni   (astrazione procedurale o astrazione della nozione di istruzione).</li> </ul>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#funzioni-matematiche","title":"Funzioni matematiche","text":"<p>Un sotto-programma di tipo funzione consente di costruire una funzione matematica.</p> <p>Una funzione matematica \\(f\\) associa ad un valore del suo dominio \\(\\dom f\\) un valore del dominio del risultato, il \\(\\codom f\\). Ad esempio sia \\(f = \\sqrt{x}\\), si ha:</p> \\[ f \\colon \\R \\to \\R \\]"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#funzioni","title":"Funzioni","text":"<p>In un linguaggio di programmazione una funzione \\(f\\) pu\u00f2 essere vista come un operatore che opera su operandi, ovvero i parametri in input, e produce un risultato o valore di output</p> <pre><code>flowchart LR\n    Operandi --&gt; f --&gt; Risultato;</code></pre> <p>Ai parametri di input e al valore di output deve essere associato un tipo. Il valore di output \u00e8 necessariamente scalare.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#attivazione-di-una-funzione","title":"Attivazione di una funzione","text":"<p>Una funzione viene attivata (o chiamata) inserendo il nome della stessa e la sua lista dei parametri (se presente) in un'espressione dello stesso tipo della funzione.</p> <p>Per poter chiamare una funzione \u00e8 sufficiente conoscere il nome di quest'ultima e la sua lista di parametri, dunque una funzione pu\u00f2 essere vista come una scatola nera della quale si conoscono soltanto i dati d'ingresso e il risultato.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#astrazione-funzionale","title":"Astrazione funzionale","text":"<p>Una funzione \\(f\\) pu\u00f2 essere vista come un operatore che opera su tipi di dati primitivi o definiti dal programmatore.</p> <p>Con l'introduzione di una funzione viene ampliato l'insieme degli operatori del linguaggio utilizzato.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#funzioni-in-c","title":"Funzioni in C","text":"<p>Il linguaggio C fornisce il costrutto function per realizzare sia funzioni che procedure. Le differenze consistono essenzialmente nel modo di</p> <ul> <li>Modo di comunicare i dati di uscita</li> <li>Modo di chiamare il sotto-programmi</li> </ul> <p>Per poter utilizzare una funzione \u00e8 necessario:</p> <ul> <li>definire il sotto-programma, cio\u00e8 scrivere in C tutte le istruzioni necessarie;</li> <li>dichiarare il sotto-programma nella parte dichiarativa del programma.</li> </ul>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#definizione-di-una-funzione","title":"Definizione di una funzione","text":"<p>La definizione di una funzione \u00e8 costituita da: un'intestazione e un blocco di dichiarazioni e istruzioni, ovvero sezioni di:</p> <ol> <li>dichiarazioni di costanti, tipi e variabili</li> <li>di istruzioni</li> </ol> <p>La sintassi per definire una funzione nel C \u00e8 la seguente:</p> Funzione in C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;parametri&gt;) {\n&lt;dichiarazioni locali&gt;\n&lt;istruzioni&gt;\n}\n</code></pre> <p>Dopo l'intestazione della funzione vi sono:</p> <ul> <li>le dichiarazioni locali, cio\u00e8 le dichiarazioni di tutte le risorse (costanti,   tipi, variabili, funzioni) necessarie;</li> <li>il blocco delle istruzioni</li> </ul> <p>Infine \u00e8 presente l'istruzione <code>return &lt;valore&gt;;</code> che restituisce il valore calcolato dall'espressione</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#intestazione-di-una-funzione","title":"Intestazione di una funzione","text":"<p>Nell'intestazione di una funzione:</p> C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;parametri&gt;)\n</code></pre> <p>il <code>&lt;tipo&gt;</code> sarebbe il tipo del valore che la funzione restituisce, <code>&lt;identificatore&gt;</code> sarebbe il nome della funzione e <code>&lt;parametri&gt;</code> sarebbe la lista di parametri che la funzione accetta.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#lista-di-parametri-formali","title":"Lista di parametri formali","text":"<p>Ogni parametro della lista \u00e8 definito come tipo e identificatore</p> C<pre><code>(&lt;parametri&gt;) := (&lt;tipo&gt; &lt;identificatore&gt;)\n</code></pre> <p>I parametri sono tra loro separati da virgole.</p> <p>Esempi di intestazione</p> C<pre><code>int abs(int x);\n</code></pre> <p>oppure</p> C<pre><code>float somma(int a, int b);\n</code></pre>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#lista-di-parametri-attuali","title":"Lista di parametri attuali","text":"<p>I parametri attuali indicano i valori degli argomenti rispetto ai quali la funzione deve essere calcolata. Un parametro attuale pu\u00f2 essere:</p> <ul> <li>Una costante;</li> <li>Una variabile;</li> <li>Una espressione;</li> <li>Una chiamata ad una funzione;</li> </ul> <p>Esempi di attivazione</p> <p>Data la seguente funzione</p> C<pre><code>float somma(int a, int b);\n</code></pre> <p>esempi di attivazione della stessa sono i seguenti:</p> C<pre><code>z = somma(a, b);\nz = somma(2, 5*b);\nz = c + somma(a, b);\ny = somma(x, abs(z));\n</code></pre> <p>L'attivazione di una funzione pu\u00f2 essere inserita dovunque possa essere inserito un operatore sul tipo del parametro della funzione.</p>"},{"location":"Anno_I/Programmazione/07_funzioni_procedure/#prototipi","title":"Prototipi","text":"<p>Una funzione deve essere dichiarata prima del suo utilizzo. La dichiarazione \u00e8 costituita dal suo prototipo.</p> <p>Il prototipo \u00e8 uguale alla intestazione della funzione:</p> C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;parametri&gt;)\n</code></pre> <p>Nel prototipo gli identificatori dei parametri sono opzionali, si pu\u00f2 quindi avere:</p> C<pre><code>&lt;tipo&gt; &lt;identificatore&gt;(&lt;tipi&gt;)\n</code></pre> <p>Il prototipo di una funzione deve essere inserito nella parte dichiarativa del programma, prima del codice che utilizza la funzione stessa.</p> <p>In tal modo il compilatore pu\u00f2 facilmente controllare il numero ed il tipo dei parametri di input ed il tipo del valore restituito.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/","title":"Tipi semplici","text":""},{"location":"Anno_I/Programmazione/08_tipi_semplici/#linguaggi-di-programmazione","title":"Linguaggi di programmazione","text":"<p>Un linguaggio di programmazione rappresenta un elaboratore astratto, capace di comprendere i termini del linguaggio che, generalmente, sono delle astrazioni degli oggetti della macchina reale. Ad esempio una variabile \u00e8 un'astrazione della memoria centrale.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dati","title":"Dati","text":"<p>I dati rappresentano oggetti e propriet\u00e0 della realt\u00e0 rilevanti per il problema in esame. I dati sono una astrazione di oggetti del mondo reale.</p> <p>Che cosa si intende per astrazione? \u00c8 un processo per il quale si ignorano gli aspetti reali che non sono rilevanti, in modo tale da concentrarsi completamente sugli aspetti pi\u00f9 importanti. Una astrazione \u00e8 dunque una semplificazione.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dati-semplici-e-strutturati","title":"Dati semplici e strutturati","text":"<p>I dati semplici o elementari rappresentano oggetti, entit\u00e0, propriet\u00e0 elementari o atomiche non decomponibili.</p> <p>I dati strutturati rappresentano oggetti, entit\u00e0 o propriet\u00e0 pi\u00f9 complessi, sono dunque aggregati di dati elementari.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#identificatori-di-variabili-e-costanti","title":"Identificatori di variabili e costanti","text":"<p>Una variabile \u00e8 identificata da un nome, detto identificatore, ed assume un valore che pu\u00f2 essere modificato durante l\u2019esecuzione di un programma.</p> <p>Una costante \u00e8 identificata da un nome, detto identificatore, ed assume un valore che non pu\u00f2 essere modificato durante l\u2019esecuzione di un programma.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-di-dati","title":"Tipi di dati","text":"<p>Ad ogni dato, variabile o costante, deve essere associato un tipo. Generalmente tale associazione \u00e8 dichiarata nella sezione dichiarativa del programma.</p> <p>I tipi sono: numerici, logici, alfanumerici o caratteri:</p> <pre><code>flowchart LR\n  tipo --&gt; numerico &amp; carattere &amp; logico;\n  numerico --&gt; intero &amp; reale;</code></pre> <p>Un tipo di dato o semplicemente tipo indica:</p> <ul> <li>Un insieme di valori \\(D\\) (dominio);</li> <li>Un insieme di operazioni \\(O\\) che si applicano agli elementi di \\(D\\),   operatori e predicati;</li> <li>Un insieme di costanti, cio\u00e8 di simboli con cui si denotano i valori del   dominio \\(D\\).</li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dichiarazione-di-una-variabile","title":"Dichiarazione di una variabile","text":"<p>Per dichiarare una variabile <code>a</code> \u00e8 necessario associare ad essa un tipo che indichi:</p> <ul> <li>i valori che questa pu\u00f2 assumere;</li> <li>le operazioni che possono essere effettuate sull'insieme di tali valori;</li> <li>i simboli con cui si indicano tali valori all'interno di un programma.</li> </ul> <p>Dichiarazione di una variabile</p> <p>Un esempio di dichiarazione in C \u00e8 la seguente</p> C<pre><code>int a\n</code></pre>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#costanti","title":"Costanti","text":"<p>Dichiarazione di una costante</p> <p>Dichiarazione in C di una costante intera identificata da <code>n</code>:</p> C<pre><code>const int n = 100;\n</code></pre> <p>La parola chiave \u00e8 <code>const</code>, <code>int</code> \u00e8 lo specificatore del tipo, <code>100</code> \u00e8 il valore assegnato alla costante <code>n</code>.</p> <p>Una dichiarazione di costante associa permanentemente un identificatore ad un valore.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-e-linguaggi-di-programmazione","title":"Tipi e linguaggi di programmazione","text":"<p>I linguaggi di programmazione consentono di:</p> <ul> <li>Utilizzare tipi di dato predefiniti;</li> <li>Definire nuovi tipi;</li> <li>Convertire una variabile di un tipo in una variabile di altro tipo in modo   implicito o esplicito.</li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-primitivi","title":"Tipi primitivi","text":"<p>I tipi primitivi sono quelli direttamente disponibili nel linguaggio di programmazione. In C i tipi primitivi sono:</p> <ul> <li>Tipi predefiniti:<ul> <li><code>int</code>: per i numeri interi;</li> <li><code>float</code>: per i numeri reali;</li> <li><code>double</code>: per i reali in doppia precisione;</li> <li><code>char</code>: per i caratteri;</li> </ul> </li> <li>Tipi definiti dall'utente:<ul> <li>Tipi enumerati definiti tramite la parola chiave <code>enum</code>.</li> </ul> </li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipi-semplici-e-tipi-strutturati","title":"Tipi semplici e tipi strutturati","text":"<p>I tipi primitivi sono detti anche tipi semplici ovvero il loro dominio \u00e8 elementare, dunque costituito da elementi atomici non decomponibili (es. <code>int</code>).</p> <p>I tipi strutturati sono quelli il cui dominio \u00e8 composito, ovvero \u00e8 composto aggregando dati pi\u00f9 elementari (es. vettore e struttura).</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#dati-numerici-interi-e-reali","title":"Dati numerici interi e reali","text":"<p>I linguaggi di programmazione consentono di rappresentare ed elaborare dati numerici interi e reali. Il linguaggio C fornisce tre tipi predefiniti:</p> <ul> <li><code>int</code> per rappresentare ed elaborare un sottoinsieme dei numeri interi</li> <li><code>float</code> e double per rappresentare ed elaborare un sottoinsieme dei   numeri reali</li> </ul>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#tipo-int","title":"Tipo int","text":"<p>I dati di tipo int costituiscono un sottoinsieme dei numeri interi, positivi e negativi. Un <code>int</code> \u00e8 rappresentato generalmente in una parola, \\(2 {\\rm\\,byte}\\) o \\(4 {\\rm\\,byte}\\). Nel caso in cui la parola sia di \\(2 {\\rm\\,byte}\\) il dominio del tipo <code>int</code> \u00e8 costituito dall'insieme.</p> \\[ D = [-2^{15},\\ 2^{15} -1] = [-32768,\\ 32767] \\] <p>Il minimo e il massimo valore intero hanno una rappresentazione simbolica denominata <code>INT_MIN</code> e <code>INT_MAX</code>.</p> <p><code>INT_MIN</code> e <code>INT_MAX</code> sono identificatori di costanti predefinite e contengono il valore del pi\u00f9 piccolo e del pi\u00f9 grande intero rappresentabile.</p> <p>La definizione delle due costanti \u00e8 contenuta nel file <code>limits.h</code>.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#operatori-aritmetici","title":"Operatori aritmetici","text":"<p>Siano \\(a, b\\) due operandi di tipo <code>int</code>. Gli operatori aritmetici restituiscono un valore di tipo <code>int</code></p> Operatore Simbolo Addizione <code>+</code> Sottrazione <code>-</code> Moltiplicazione <code>*</code> Divisione <code>/</code> Modulo <code>%</code> <p>La divisione restituisce il quoziente della divisione, ovvero la parte intera. Il modulo restituisce il resto della divisione.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#operatori-relazionali","title":"Operatori relazionali","text":"<p>Restituiscono un valore vero (<code>1</code>) o falso (<code>0</code>)</p> Operatore Simbolo Uguale <code>==</code> Diverso <code>!=</code> Minore <code>&lt;</code> Maggiore <code>&gt;</code> Minore uguale <code>&lt;=</code> Maggiore uguale <code>&gt;=</code>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#costanti-intere","title":"Costanti intere","text":"<p>I valori del dominio del tipo <code>int</code> sono denotati, all\u2019interno di un programma, con un insieme di valori costanti (costanti intere).</p> <p>Ogni costate intera \u00e8 rappresentata come un numero intero decimale eventualmente con segno. Ad esempio: <code>0</code>, <code>-151</code>, <code>+41</code>.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#espressione-aritmetica","title":"Espressione aritmetica","text":"<p>Una espressione aritmetica intera \u00e8 costituita da termini separati dagli operatori <code>+</code> e <code>-</code>. Ogni termine \u00e8 costituito da fattori, variabili e costanti, separati dagli operatori <code>*</code>, <code>/,</code> <code>%</code>.</p> <p>Esempio</p> C<pre><code>int a, b, c;   // dichiarazione di variabili intere\nc = b / a - 1; // espressione costituita da un solo termine costante\na = 4, b = 2;  // espressione costituita da 2 termini\nc = b % a;     // espressione costituita da un termine\n</code></pre> <p>In ogni caso il risultato \u00e8 un intero.</p>"},{"location":"Anno_I/Programmazione/08_tipi_semplici/#compatibilita-tra-tipi","title":"Compatibilit\u00e0 tra tipi","text":"<p>Siano \\(T_1\\) e \\(T_2\\) due tipi differenti. Variabili di tipo differente possono comparire in una stessa espressione? Generalmente s\u00ec, se il linguaggio di programmazione fornisce delle regole di conversione implicite tra i due tipi.</p>"},{"location":"Anno_I/Programmazione/10_array/","title":"Array","text":""},{"location":"Anno_I/Programmazione/10_array/#dati-e-tipi-strutturati","title":"Dati e tipi strutturati","text":"<p>I dati strutturati sono aggregati di dati elementari, come vettori, matrici, dizionari, code, liste, pile, etc.</p> <p>I tipi strutturati possono essere costruiti da dei tipi costituenti che sono gi\u00e0 definiti. Gli elementi del dominio di un tipo di dato strutturato sono ottenuti aggregando gli elementi e/o le componenti, appartenenti ai domini dei tipi costituenti.</p>"},{"location":"Anno_I/Programmazione/10_array/#strutture-dati","title":"Strutture dati","text":"<p>Una struttura dati \u00e8 costituita da un insieme di componenti sui quelli sono definiti un insieme di operatori per: selezionare, cancellare, aggiungere, etc. un componente.</p>"},{"location":"Anno_I/Programmazione/10_array/#linearita","title":"Linearit\u00e0","text":"<p>Le strutture dati possono essere lineari, ovvero la struttura pu\u00f2 essere vista come una sequenza di dati in cui \u00e8 possibile individuare la \\(1^\\circ\\) componente, la \\(2^\\circ\\) componente e cos\u00ec via fino ad esaurire la lunghezza della sequenza, come ad esempio i vettori.</p> <p>Le strutture dati possono essere anche non lineari, come ad esempio una matrice.</p>"},{"location":"Anno_I/Programmazione/10_array/#gli-array","title":"Gli array","text":"<p>L\u2019array \u00e8 una struttura dati omogenea, cio\u00e8 costituita da componenti dello stesso tipo, che viene detto tipo base. L\u2019array \u00e8 una struttura ad accesso casuale, tutte le componenti possono essere selezionate a caso, nello stesso tempo, mediante un indice.</p> <p>Una variabile array \u00e8 individuata da un unico identificatore. Ogni componente \u00e8 selezionata mediante un indice.</p> <p>Array monodimensionale: un array ad una dimensione \u00e8 costituito da un insieme finito di elementi omogenei, in corrispondenza biunivoca con un insieme di indici.</p> <p>Array - dichiarazione \u2022 Nei linguaggi di alto livello \u00e8 necessario dichiarare: \u2013 Il tipo delle componenti o tipo base (pu\u00f2 essere semplice o strutturato) \u2013 Il numero delle componenti (costante o variabile) \u2013 Il tipo dell\u2019indice \u2022 Nel linguaggio C l\u2019indice deve essere un intero e variare nel dominio [0, n-1] se n \u00e8 il numero delle componenti</p> <p>Esempio in C</p> C<pre><code>#define DIM 100; // numero di elementi del vettore\n</code></pre> <p>int a[DIM]; // dichiarazione del vettore int i; // dichiarazione dell\u2019indice \u2022 In C e in Pascal non esiste il tipo array, ma la possibilit\u00e0 di costruirlo aggregando componenti omogenee \u2022 Gli operatori che si possono applicare sono soltanto quelli relativi al tipo delle componenti</p> <p>Array \u2013 selezione di una componente \u2022 Sia x un array di n elementi \u2013 Selezione: la selezione di una componente \u00e8 possibile mediante il nome della variabile array ed un valore dell\u2019indice x[i] seleziona la componente di indice i (i varia tra 0 ed n-1)</p> <p>Array \u2013 aggiornamento di una componente \u2022 Sia x un array di n elementi \u2013 Aggiornamento: l\u2019aggiornamento del valore della componente di indice i si pu\u00f2 ottenere: \u2022 Mediante una istruzione di assegnazione: x[i] = v \u2022 Mediante la lettura di un valore: scanf(\u00ab%d\u00bb, &amp;x[i])</p> <p>Rappresentazione in memoria centrale \u2022 Una variabile array \u00e8 rappresentata in memoria centrale in modo sequenziale, cio\u00e8 le diverse componenti sono organizzate in locazioni di memoria contigue x[0] x[1] \u2026 \u2026 \u2026 \u2026 \u2026 x[n-1]</p> <p>Rappresentazione in memoria centrale \u2022 Sia x un array di n componenti (con n costante), e sia i l\u2019indice variabile da 0 a n-1 \u2022 Le componenti di x sono rappresentate in memoria a partire dall'indirizzo iniziale di x, ind(x), uguale all\u2019indirizzo della prima componente x[0] x[1] \u2026 \u2026 \u2026 \u2026 \u2026 x[n-1]</p> <p>Rappresentazione in memoria centrale \u2022 Sia L l\u2019occupazione di memoria in byte di una componente di x, dipendente dal tipo base \u2013 L\u2019occupazione di memoria della variabile x \u00e8 data da n*L \u2013 L\u2019indirizzo di un generico elemento i \u00e8 dato da ind(x[i]) = ind(x) + i*L x[0] x[1] \u2026 \u2026 \u2026 \u2026 \u2026 x[n-1]</p> <p>Strutture dati - omogeneit\u00e0 \u2022 Un linguaggio di programmazione offre diversi metodi di strutturazione dei dati: \u2013 Si possono aggregare dati dello stesso tipo, ad esempio in un array \u2013 Oppure di tipo diverso, ad esempio in un record</p> <p>Strutture dati - accesso \u2022 Si possono avere diversi metodi di accesso alle diverse componenti \u2013 Accesso diretto ad ogni componente \u2013 Accesso sequenziale ad ogni componente \u2013 Accesso diretto solo ad alcune componenti</p> <p>Strutture dati - dimensione \u2022 Strutture dati a dimensione fissa \u2013 il numero delle componenti non cambia \u2022 Strutture dati a dimensione variabile - il numero delle componenti \u00e8 variabile</p>"},{"location":"Anno_I/Programmazione/esercizi/10-08-21/","title":"Esercizi del 08/10/2021","text":""},{"location":"Anno_I/Programmazione/esercizi/10-08-21/#esercizio-1-somma-di-due-numeri","title":"Esercizio 1 \u2013 Somma di due numeri","text":"<p>Dati due numeri interi \\(a\\) e \\(b\\), calcolarne la somma. Non \u00e8 accettabile come soluzione \\(a + b\\).</p> <p>Prendiamo, ad esempio, due numeri \\(5, 7\\). Siamo in grado di sommare questi due numeri utilizzando le dita della mano e il risultato \u00e8 \\(12\\). Come \u00e8 stato ottenuto questo risultato? Incrementando di uno, tante volte il primo numero quante volte \u00e8 il secondo numero, ovvero \\(5 + 1 + \\cdots + 1\\).</p> <p>Il problema \u00e8 stato appena risolto, \u00e8 ora necessario descriverlo in modo tale che chiunque sia in grado di comprendere le operazioni che sono state appena effettuate, dunque:</p> Somma, v1<pre><code>Prendere il valore di a\nPrendere il valore di b\nIncrementare a di 1\nDecrementare b di 1\nSE (b &gt; 0) ANDARE a 3\nrisultato := a\n</code></pre> <p>Il precedente \u00e8 un possibile metodo di risoluzione. \u00c8 necessario notare che la parola-chiave <code>ANDARE</code> \u00e8 un termine bandito. Bisogna scrivere questa soluzione in maniera differente.</p> <p>Cosa accadrebbe nel caso in cui \\(a, b \\geq 0\\)?</p> <p>Cambiare il valore di \\(a\\) non fa differenza, ma cambiando il valore di  \\(b\\) la soluzione potrebbe essere errata e quindi la procedura  restituirebbe un risultato diverso da quello atteso.</p> <p>Quindi:</p> Somma, v2<pre><code>Prendere il valore di a\nPrendere il valore di b\nSE (b = 0) ANDARE a 7\nIncrementare a di 1\nDecrementare b di 1\nSE (b &gt; 0) ANDARE a 4\nrisultato := a\n</code></pre> <p>Anche questo procedimento non \u00e8 scritto correttamente dato l'uso di <code>ANDARE</code>.</p> <p>Cosa succederebbe se \\(b &lt; 0\\)?</p> <p>La procedura non restituirebbe alcun risultato.</p> <p>Ogni vincolo specificato nei dati va sempre controllato e non va mai dato per scontato.</p> <p>\u00c8 necessario scrivere una procedura che non contenga alcun salto arbitrario, tenendo sempre conto del fatto che le operazioni vengono eseguite dall'alto verso il basso. Per effettuare dei salti, questi devono essere controllati da delle condizioni specifiche che vedremo in seguito.</p> <p>Questa soluzione \u00e8, per ora, accettabile. Una volta visto come effettuare dei salti in maniera controllata, non lo sar\u00e0 pi\u00f9.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-08-21/#esercizio-2-conversione-da-binario-a-decimale","title":"Esercizio 2 \u2013 Conversione da binario a decimale","text":"<p>Dato un numero in base binaria \\(a_{2}\\), convertire lo stesso in base decimale \\(a_{10}\\). Dunque:</p> Conversione, v1<pre><code>Prendere la prima cifra di a2\nMoltiplicare questa per 2 elevato alla posizione della cifra\n</code></pre> <p>Non \u00e8 possibile scrivere <code>ANDARE a 1</code>, tantomeno di prendere la penultima cifra poich\u00e9 la lunghezza del numero non \u00e8 nota.</p> <p>\u00c8 necessario utilizzare un contatore il cui valore venga incrementato di uno dopo ogni iterazione. Poich\u00e9 non conosciamo la lunghezza del numero, \u00e8 necessario esplicitare quest'ultima tramite altri mezzi, dunque:</p> Conversione, v2<pre><code>p := 0\nPrendere la cifra di a2 in posizione p\nMoltiplicare questa per 2^p\nIncrementare il valore di p di 1\nANDARE a 2\n</code></pre> <p>Nonostante l'utilizzo del contatore <code>p</code>, questa soluzione non \u00e8 funzionale. Come \u00e8 possibile capire quando fermarsi? Ovviamente quando terminano le cifre, ma come lo si pu\u00f2 determinare? Bisogna inserire un controllo.</p> Conversione, v3<pre><code>p := 0\nPrendere la cifra di a2 in posizione p\nMoltiplicare questa per 2^p\nIncrementare il valore di p di 1\nSE (p &lt; C )ANDARE a 2\n</code></pre> <p>Dove \\(C\\) indica la lunghezza di \\(a_2\\).</p> <p>Questa procedura rende l'idea di come risolvere il problema, ma non \u00e8 ancora corretta poich\u00e9 bisogna sommare le cifre ottenute al risultato finale.</p> Conversione, v4<pre><code>p := 0\nPrendere la cifra di a2 in posizione p\nMoltiplicare questa per 2^p\nSommare questo valore al risultato\nIncrementare il valore di p di 1\nSE (p &lt; C) ANDARE a 2\n</code></pre> <p>Sono spesso necessarie delle informazioni che il problema non fornisce e spetta a chi trova la soluzione individuarle. Ad esempio, se sono presenti delle sequenze di simboli e/o di numeri, \u00e8 necessario conoscere la lunghezza degli stessi, anche se la traccia non lo esplicita.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-14-21/","title":"Esercizio del 14/10/2021","text":"<p>Dati due insiemi di elementi \\(I_1\\) e \\(I_2\\), di cardinalit\u00e0 rispettivamente \\(n, m\\), scrivere un algoritmo in grado di individuare gli elementi comuni ai due insiemi.</p> <p>Iniziamo ad elencare i dati.</p> INPUT \\(I_1\\) \u2013 insieme di elementi, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_1\\), appartiene a \\(\\N^\\ast\\) \\(I_2\\) \u2013 insieme di elementi, insieme \\(m\\) \u2013 cardinalit\u00e0 di \\(I_2\\), appartiene a \\(\\N^\\ast\\) OUTPUT \\(I_3\\) \u2013 insieme di elementi comuni a \\(I_1\\) e \\(I_2\\) <p>Consideriamo ad esempio \\(I_1 = \\{3, 12, 7, 41, 35\\}\\) e \\(I_2 = \\{8, 5, 62, 7, 27, 56\\}\\), ne risulta che \\(I_3 = \\{7\\}\\). Che procedimento \u00e8 stato utilizzato?</p> Bozza<pre><code>Prendere ogni elemento di I1\nControllare se \u00e8 presente in I2\nSe \u00e8 presente, aggiungerlo a I3\n</code></pre> <p>Non \u00e8 un algoritmo, ma il procedimento \u00e8 sostanzialmente questo. Vediamolo:</p> Algoritmo, v1<pre><code>p := 1\nMENTRE (p &lt;= n)\n  q := 1\n  MENTRE (q &lt;= m)\n    SE (elemento p-esimo di I1 = elemento q-esimo di I2) ALLORA \n      inserire l'elemento p-esimo di I1 in I3\n    FINE SE\n    q := q + 1\n  FINE MENTRE\n  p := p + 1\nFINE MENTRE\n</code></pre> <p>Questa \u00e8 una possibile soluzione. Iteriamo all'interno del primo insieme e confrontiamo il primo elemento di questo con tutti gli elementi dell'altro insieme, e cos\u00ec via. C'\u00e8 tuttavia un errore, non viene specificato l'inserimento dell'elemento nell'insieme \\(I_3\\). Inoltre l'algoritmo potrebbe essere reso pi\u00f9 efficiente interrompendo il ciclo dopo aver trovato il numero in comune. Dunque</p> Algoritmo, v2<pre><code>p := 1\nr := 1\nMENTRE (p &lt;= n)\n  q := 1\n  MENTRE (q &lt;= m)\n    SE (elemento p-esimo di I1 = elemento q-esimo di I2)\n      ALLORA elemento r-esimo di I3 := elemento p-esimo di I1\n      r := r + 1\n    FINE\n    q := q + 1\n  FINE\n  p := p + 1\nFINE\n</code></pre> <p>Questo algoritmo per\u00f2 non funziona tutte le volte poich\u00e9 nel caso in cui l'insieme \\(I_3\\) sia vuoto, questo dovrebbe essere \\(I_3 = \\emptyset\\) ma il valore di \\(r\\) parte da uno e non da zero. Bisogna tener conto del fatto che la cardinalit\u00e0 \u00e8 maggiorata di uno nel momento in cui sia necessario dare la soluzione, dunque <code>r - 1 = 0</code>, allora \\(I_3 = \\emptyset\\).</p> <p>Dopo aver letto la sezione sull'Algebra Booleana, \u00e8 possibile scrivere un algoritmo migliore, che utilizza un valore booleano che indica se l'elemento \u00e8 presente o meno nell'insieme \\(I_2\\).</p> Algoritmo, v3<pre><code>p := 1\nr := 1\ntrovato := FALSO\nMENTRE (p &lt;= n) \u2227 (trovato = FALSO)\n  q := 1\n  MENTRE (q &lt;= m)\n    SE (elemento p-esimo di I1 = elemento q-esimo di I2)\n      ALLORA elemento r-esimo di I3 := elemento p-esimo di I1\n      trovato := VERO\n      r := r + 1\n    FINE\n    q := q + 1\n  FINE\n  p := p + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-14-21/#controllo","title":"Controllo","text":"<p>Controlliamo che l'algoritmo sia corretto. Siano \\(I_1 = \\set{5, 10, 31}\\) e \\(I_2 = \\set{7, 10}\\), dunque \\(I_3 = \\set{10}\\). Inoltre \\(n = 3\\) e \\(m = 2\\).</p> Controllo<pre><code>I1 = {5, 10, 31}    n = 3\nI2 = {7, 10}        m = 2\nr -&gt; 1; 2;\np -&gt; 1; 2; 3; 4;\nq -&gt; 1; 2; 3; / 1; 2; 3; / 1; 2; 3; /\ntrovato -&gt; FALSO\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-21-21/","title":"Esercizi del 21/10/2021","text":""},{"location":"Anno_I/Programmazione/esercizi/10-21-21/#esercizio-1","title":"Esercizio 1","text":"<p>Leggere in input due interi \\(n, k &gt; 0\\) e calcolare i primi \\(n\\) multipli di \\(k\\). Realizzare l'algoritmo in pseudo-codice, considerando i controlli sull'input.</p> <p>Esempio:</p> <p>Dati \\(n = 3\\) e \\(k = 4\\), i primi \\(3\\) multipli di \\(4\\) sono \\(4, 8, 12\\).</p> INPUT: \\(n\\) \u2013 numero di multipli di \\(k\\) da calcolare, \\(n \\in \\N^\\ast\\) \\(k\\) \u2013 numero di cui calcolare gli \\(n\\) multipli, \\(n \\in \\N^\\ast\\) OUTPUT: <code>multipli</code> \u2013 Insieme di \\(n\\) multipli di \\(k\\), insieme di naturali,   cardinalit\u00e0 \\(n\\). <p>ALGORITMO</p> Bozza<pre><code>leggere n\nleggere k\ncontrollare n e k   // si pu\u00f2 operare in due modi\ncalcolare i multipli\n</code></pre> <p>Il precedente non \u00e8 un algoritmo ma, come sempre, un'idea di come risolvere il problema. Il controllo, come accennato, \u00e8 possibile effettuarlo in due modi.</p> Primo modoSecondo modo Bozza, v2a<pre><code>leggere n\nleggere k\nSE (n e k soddisfano i vincoli)\n  ALLORA calcolare i multipli\nFINE\n</code></pre> Bozza, v2b<pre><code>leggere n\nleggere k\nSE (n e k soddisfano i vincoli)\n  ALLORA ANDARE a 1\n  ALTRIMENTI calcolare i multipli\nFINE\n</code></pre> <p>\u00c8 presente l'istruzione <code>ANDARE</code>, ma questa \u00e8 solo una bozza, verr\u00e0 rimossa nell'algoritmo.</p> <p>Bisogna rendere chiari i vincoli, magari con un messaggio che li specifichi o che chiarisca il comportamento aspettato. Poich\u00e9 vengono richiesti due valori positivi dando in input, ad esempio, \\(5, -1\\) l'algoritmo tornerebbe al primo punto e richiederebbe entrambi i numeri, nonostante il primo fosse corretto. Sarebbe quindi consigliato controllare ogni dato separatamente.</p> Bozza, v2b.1<pre><code>leggere n\nSE (n non soddisfa i vincoli)\n  ALLORA TORNARE a 1\nFINE\nleggere k\nSE (k non soddisfa i vincoli)\n  ALLORA TORNARE a 5\nFINE\ncalcolare i multipli\n</code></pre> <p>In questo modo vengono evitate operazioni inutili. Dunque, traducendo:</p> Algoritmo, v1<pre><code>n := 0\nMENTRE (n &lt; 0)\n  leggere n\nFINE\n\nk := 0\nMENTRE (k &lt; 0)\n  leggere k\nFINE\ncalcolare i multipli\n</code></pre> <p>Con questa sintassi l'algoritmo non procede finch\u00e9 non riceve i dati corretti in input, per questo \u00e8 possibile aggiungere un messaggio che renda noto che il valore di \\(n\\) o di \\(k\\) \u00e8 errato.</p> <p>Una possibile alternativa sarebbe:</p> Algoritmo, v1a<pre><code>ESEGUI\n  scrivere messaggio\n  leggere n\nFINCH\u00c9 (n &lt;= 0)\nFINE\n\nESEGUI\n  scrivere messaggio\n  leggere k\nFINCH\u00c9 (k &lt;= 0)\nFINE\n\ncalcolare i multipli\n</code></pre> <p>Dal punto di vista dell'efficienza, questo algoritmo \u00e8 migliore. Inoltre rimuove il problema di assegnare dei valori sia ad \\(n\\) che a \\(k\\). Entrambe le soluzioni sono valide, ma in questo caso \u00e8 preferibile utilizzare il blocco <code>ESEGUI [...] FINCH\u00c9</code>.</p> <p>Dopo aver migliorato la struttura di controllo, ora \u00e8 necessario specificare cosa significhi <code>calcolare i multipli</code>. Bisogna calcolare \\(n\\) volte i multipli di \\(k\\) e poich\u00e9 \u00e8 presente una ripetizione \u00e8 necessario usare un'iterazione. Dunque:</p> Calcolo dei multipli<pre><code>p := 1\nMENTRE (p &lt;= n)\n  elemento p-esimo di multipli := k * p\n  p := p + 1\nFINE\n</code></pre> <p>Attenzione</p> <p>una cosa che non \u00e8 possibile fare \u00e8 la seguente</p> Text Only<pre><code>multipli := k * p\n</code></pre> <p>poich\u00e9 <code>multipli</code> \u00e8 un insieme e non un singolo elemento. Questo significa che bisogna assegnare un valore in una posizione specifica.</p> <p>Bisogna ora specificare il messaggio da mostrare nel caso in cui vengano inseriti dei dati non corretti.</p> <p>Nel C sono presenti funzioni che permettono di stampare a video ci\u00f2 che si desidera (<code>printf()</code>), nello pseudo-codice scriveremo <code>StampareAVideo()</code>, quindi, ad esempio:</p> Text Only<pre><code>StampareAVideo(\"Inserire il numero di multipli da calcolare\")\n</code></pre> <p>Leggere in input</p> <p>Per leggere dei dati in input, il C offre la funzione <code>scanf()</code>, in pseudo-codice useremo <code>LeggereDaTastiera()</code>. In questo modo il programma si blocca finch\u00e9 non riceve un dato in input.</p> <p>Mettendo tutto insieme si ottiene:</p> ALgoritmo<pre><code>ESEGUI\n  StampareAVideo(\"Inserire il numero di multipli da calcolare, maggiore di 0\")\n  n := LeggereDaTastiera()\nFINCH\u00c9 (n &lt;= 0)\nFINE\n\nESEGUI\n  StampareAVideo(\"Inserire il numero di cui calcolare i multipli, maggiore di 0\")\n  k := LeggereDaTastiera()\nFINCH\u00c9 (k &lt;= 0)\nFINE\n\np := 1\nMENTRE (p &lt;= n)\n  elemento p-esimo di multipli := k * p\n  p := p + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-21-21/#esercizio-2","title":"Esercizio 2","text":"<p>Leggere in input due interi \\(n,k  &gt; 0\\) e verificare se \\(n\\) \u00e8 divisibile per \\(k\\). Realizzare l\u2019algoritmo in pseudo-codice, considerando i controlli sugli input.</p> <p>Esempio: Dati \\(n = 3\\) e \\(k = 4\\), \\(n\\) non \u00e8 divisibile per \\(k\\).</p> INPUT: \\(n\\) - numero di cui verificare la divisibilit\u00e0 per \\(k\\), \\(n \\in \\N^\\ast\\) \\(k\\) - numero di cui verificare se sia divisore di \\(n\\), \\(k \\in \\N^\\ast\\) OUTPUT: divisibile - indica se \\(n\\) sia divisibile (vero) o meno (falso) per \\(k\\), booleano <p>La prima bozza di questo algoritmo \u00e8 molto simile a quella del'algoritmo dell'esercizio precedente, l'unica differenza consiste nel verificare la divisibilit\u00e0 anzich\u00e9 calcolare i multipli.</p> Algoritmo, v1<pre><code>SE (n modulo k = 0)\n  ALLORA divisibile := vero\n  ALTRIMENTI divisibile := falso\nFINE\n</code></pre> <p>Nel caso in cui il resto (ovvero il modulo) sia zero, allora \\(n\\) \u00e8 divisibile per \\(k\\). Ma com'\u00e8 di preciso definita l'operazione <code>modulo</code>? Va specificata.</p> <p>\u00c8 possibile risolvere il problema senza utilizzare l'operazione <code>modulo</code> facendo uso di sottrazioni ripetute. Nel caso in cui il risultato sia zero allora non \u00e8 presente resto, se invece il risultato fosse maggiore di zero, allora il resto \u00e8 presente.</p> Algoritmo, v2<pre><code>MENTRE (n &gt;= k)\n  n := n - k\nFINE\n\nSE (n = 0)\n  ALLORA divisibile := vero\n  ALTRIMENTI divisibile := falso\nFINE\n</code></pre> <p>In questo algoritmo si va a perdere il valore di \\(n\\) e sarebbe meglio preservarlo utilizzando una variabile come <code>temp</code>.</p> <p>\u00c8 importante notare come la prima versione dell'algoritmo nel caso in cui venga tradotto in un linguaggio che non possegga l'operazione <code>modulo</code>, l'esecutore non saprebbe come fare. Dunque o si risolve il problema in maniera differente, oppure si specifica cosa fa l'operazione <code>modulo</code>.</p> <p>Abbiamo dato per scontato che esista una funzione</p> Text Only<pre><code>r := modulo(n, k)\n</code></pre> <p>il che non \u00e8 sempre vero ed \u00e8 quindi un errore.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/","title":"Esercizio del 28/10/21","text":"<p>Letti in input due insiemi di elementi \\(I_1\\) e \\(I_2\\), di cardinalit\u00e0 rispettivamente \\(n\\) e \\(m\\), scrivere un algoritmo in grado di:</p> <ul> <li>individuare gli elementi comuni ai due insiemi;</li> <li>unire i due insiemi in un unico insieme;</li> <li>calcolare la differenza tra i due insiemi;</li> <li>stampare a video tutti i risultati.</li> </ul> <p>Considerare i controlli sui dati di input. Realizzare come prima cosa la decomposizione funzionale.</p> <p>Iniziare immediatamente con lo pseudo-codice potrebbe essere controproducente, dunque analizziamo prima le macro-operazioni.</p> <p>Come prima cosa \u00e8 necessario ricevere gli insiemi in input, dunque</p> Text Only<pre><code>leggere insieme I1\nleggere insieme I2\n</code></pre> <p>Successivamente sono presenti le operazioni sugli insiemi, quindi:</p> Text Only<pre><code>calcolare I1 \u2229 I2\ncalcolare I1 \u222a I2\ncalcolare I1 \u2216 I2\n</code></pre> <p>e, infine:</p> Text Only<pre><code>stampare i risultati\n</code></pre> <p>Si tratta di una sequenza di azioni. Quelle appena elencate non sono altro che delle sotto-operazioni dell'operazione principale.</p> <p>Tralasciando ancora lo pseudo-codice, leggere <code>leggere insieme [...]</code> fa immediatamente pensare a <code>LeggereDaTastiera()</code>, ma per fare questo \u00e8 necessaria la cardinalit\u00e0 dell'insieme, dopodich\u00e9 i valori dell'insieme e infine verificare i vincoli sui dati. Quindi le operazioni distinte da effettuare sono quattro.</p> <p>Analizzando ora <code>stampare i risultati</code>, bisogna stampare gli insiemi Unione, Intersezione e Differenza, vedremo dopo come.</p> <p>Per quanto riguarda le operazioni sugli insiemi, il calcolo dell'intersezione \u00e8 stato visto precedentemente. Il calcolo dell'unione \u00e8 molto simile, bisogna prima inserire tutti gli elementi del primo insieme e poi controllare quali elementi del primo sono presenti nel secondo e se non \u00e8 presente, aggiungerlo. Anche la differenza \u00e8 simile in quanto si effettua una ricerca.</p> <p>L'algoritmo va ora risolto per ogni operazione separata, ogni operazione ha un suo algoritmo separato delle altre.</p> <p>Ora che son state analizzate brevemente le varie operazioni, possiamo creare un albero di lavoro:</p> TestoDiagramma Albero di lavoro<pre><code>Operazioni su insiemi\n  Leggere insieme I1\n    leggere cardinalit\u00e0 n di I1\n    verificare i vincoli di n\n    leggere i valori di I1\n    verificare i vincoli di I1\n  Leggere insieme I2\n    leggere cardinalit\u00e0 m di I2\n    verificare i vincoli di m\n    leggere i valori di I2\n    verificare i vincoli di I2\n  Calcolare intersezione\n    ricercare elemento in insieme\n  Calcolare unione\n    ricercare elemento in insieme\n  Calcolare Differenza\n    ricercare elemento in insieme\n  Stampare i risultati\n    stampare l'insieme intersezione\n    stampare l'insieme unione\n    stampare l'insieme differenza\n</code></pre> <pre><code>flowchart LR;\n  %% main node\n  ops(Operazioni su insiemi);\n\n  %%% secondary nodes\n  rI1(\"leggere l'insieme I\u2081\"); rI2(\"leggere l'insieme I\u2082\");\n  cc(calcolare l'insieme);\n  pp(stampare i risultati); ppi(stampare l'insieme);\n\n  %%%% tertiary nodes\n  rcI1(leggere la cardinalit\u00e0 n); rcI2(leggere la cardinalit\u00e0 m);\n  vvn(verificare i vincoli di n); vvm(verificare i vincoli di m);\n  rvI1(\"leggere i valori di I\u2081\"); rvI2(\"leggere i valori di I\u2082\");\n  vvI1(\"verificare i vincoli di I\u2081\"); vvI2(\"verificare i vincoli di I\u2082\");\n\n  cint(intersezione); cuni(unione); cdif(differenza);\n  pint(intersezione); puni(unione); pdif(differenza);\n\n  %% from main\n  ops ---&gt; rI1 &amp; rI2 &amp; cc &amp; pp;\n\n  %%% from secondary\n  rI1 --&gt; rcI1 --&gt; vvn;\n  rI1 --&gt; rvI1 --&gt; vvI1;\n\n  rI2 --&gt; rcI2 --&gt; vvm;\n  rI2 --&gt; rvI2 --&gt; vvI2;\n\n  cc --&gt; cint &amp; cuni &amp; cdif;\n\n  pp ---&gt; ppi --&gt; pint &amp; puni &amp; pdif;</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#operazioni-sugli-insiemi","title":"Operazioni sugli insiemi","text":"<p>Rappresenta il problema nella sua interezza.</p> INPUT: \\(I_1\\) \u2013 primo insieme di \\(n\\) elementi, insieme \\(I_2\\) \u2013 secondo insieme di \\(m\\) elementi, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_1\\), con \\(n \\in \\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_2\\), con \\(m \\in \\N^\\ast\\) OUTPUT: <code>intersezione</code> \u2013 insieme di elementi comuni a \\(I_1\\) e \\(I_2\\), insieme <code>unione</code> \u2013 insieme di elementi di \\(I_1\\) e \\(I_2\\) distinti, insieme <code>differenza</code> \u2013 insieme di elementi di \\(I_1\\) non comuni a \\(I_2\\), insieme Bozza<pre><code>leggere insieme I1\nleggere insieme I2\ncalcolare intersezione\ncalcolare unione\ncalcolare differenza\nstampare risultati\n</code></pre> <p>Questa \u00e8 un'idea di come l'algoritmo debba funzionare. Poich\u00e9 diventi un vero algoritmo andrebbe scritto in pseudo-codice.</p> <p>ALGORITMO:</p> <p>La lettura degli insiemi, come le altre operazioni saranno delle funzioni:</p> Operazioni<pre><code>n := LeggereCardinalit\u00e0()\nI1 := LeggereInsieme(n)\nm := LeggereCardinalit\u00e0()\nI2 := LeggereInsieme(m)\n\nIntersezione := CalcolareIntersezione(I1, n, I2, m)\nUnione := CalcolareUnione(I1, n, I2, m)\nDifferenza := CalcolareDifferenza(I1, n, I2, m)\n\nStampareRisultati(\n  Intersezione, cardinalit\u00e0Intersezione,\n  Differenza, cardinalit\u00e0Differenza,\n  Unione, cardinalit\u00e0Unione,\n)\n</code></pre> <p>L'algoritmo non si discosta molto dall'albero di lavoro.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#leggere-cardinalita","title":"Leggere cardinalit\u00e0","text":"<p>Poich\u00e9 la cardinalit\u00e0 degli insiemi \u00e8 un dato continuamente utilizzato, \u00e8 necessario richiederlo in input.</p> INPUT: vuoto \u2013 non \u00e8 presente input OUTPUT: <code>cardinalit\u00e0</code> \u2013 numero di elementi di un insieme, naturale <p>ALGORITMO:</p> Text Only<pre><code>ESEGUI\n  StampareAVideo(\"Inserire il numero di elementi dell'insieme: \")\n  cardinalit\u00e0 := LeggereDaTastiera()\nFINCH\u00c9 (cardinalit\u00e0 &lt;= 0)\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#leggere-insieme","title":"Leggere insieme","text":"INPUT: <code>cardinalit\u00e0</code> \u2013 numero di elementi dell'insieme \\(I\\), appartiene a \\(\\N^\\ast\\) OUTPUT: \\(I\\) \u2013 insieme di elementi, insieme <p>ALGORITMO:</p> Text Only<pre><code>SE (cardinalit\u00e0 &gt; 0)\n  ALLORA leggere i valori di I\n  verificare i vincoli di I\n  ALTRIMENTI StampareAVideo(\"Il numero immesso \u00e8 negativo\")\nFINE\n</code></pre> <p>\u00c8 necessario dare la possibilit\u00e0 di controllare la cardinalit\u00e0 e, finch\u00e9 questa non sia corretta, l'algoritmo non produce risultato.</p> <p>Alcune di queste operazioni possono essere riscritte, ad esempio:</p> Text Only<pre><code>cardinalit\u00e0 := LeggereCardinalit\u00e0()\nI := LeggereValoriInsieme(cardinalit\u00e0)\n</code></pre> <p>Per quanto riguarda la verifica dei vincoli, sarebbe meglio che questi vengano uniti alla lettura dei valori dell'insieme:</p> Text Only<pre><code>ESEGUI\n  I := LeggereValoriInsieme(cardinalit\u00e0)\n  verificato := VerificareVincoli(I)\nFINCH\u00c9 (verificato = FALSO)\nFINE\n</code></pre> <p>La precedente soluzione \u00e8 funzionale, per\u00f2 non risulta essere comoda per l'utente poich\u00e9 nel caso in cui anche un singolo valore sia errato, \u00e8 necessario reinserire anche gli altri.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#calcolare","title":"Calcolare","text":""},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#intersezione","title":"Intersezione","text":"INPUT: \\(I_1\\) \u2013 primo insieme di cui effettuare l'intersezione, insieme \\(I_2\\) \u2013 secondo insieme di cui effettuare l'intersezione, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_1\\), appartiene a \\(\\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_2\\), appartiene a \\(\\N^\\ast\\) OUTPUT: <code>intersezione</code> \u2013 insieme risultante dell'intersezione tra \\(I_1\\) e \\(I_2\\), insieme LAVORO: \\(p\\) \u2013 posizione degli elementi di \\(I_1\\), appartiene a \\(\\N^\\ast\\) \\(q\\) \u2013 posizione degli elementi di <code>intersezione</code>, appartiene a \\(\\N^\\ast\\) <code>trovato</code> \u2013 indica se un elemento \u00e8 presente in un insieme, booleano <p>ALGORITMO:</p> Text Only<pre><code>q := 1\np := 1\nMENTRE ( p &lt;= n)\n  trovato := RicercaElemento(p-esimo elemento di I1, I2, m)\n  SE (trovato = VERO)\n    ALLORA q-esimo elemento di intersezione := p-esimo elemento di I1\n    q := q + 1\n  FINE\n  p := p + 1\nFINE\n\n&gt;&gt; per rappresentare la fine dell'insieme\n&gt;&gt; q-esimo elemento di intersezione := VALORE_FINALE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#differenza","title":"Differenza","text":"INPUT: \\(I_1\\) \u2013 primo insieme di cui effettuare l'intersezione, insieme \\(I_2\\) \u2013 secondo insieme di cui effettuare l'intersezione, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_1\\), appartiene a \\(\\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_2\\), appartiene a \\(\\N^\\ast\\) OUTPUT: <code>differenza</code> \u2013 insieme risultante dell'intersezione tra \\(I_1\\) e \\(I_2\\), insieme LAVORO: \\(p\\) \u2013 posizione degli elementi di \\(I_1\\), appartiene a \\(\\N^\\ast\\) \\(q\\) \u2013 posizione degli elementi di <code>differenza</code>, appartiene a \\(\\N^\\ast\\) <code>trovato</code> \u2013 indica se un elemento \u00e8 presente in un insieme, booleano <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nq := 1\nMENTRE (p &lt;= n)\n  trovato := RicercareElemento(p-esimo elemento di I1, I2, m)\n  SE (Trovato=FALSO)\n    ALLORA q-esimo elemento di differenza := p-esimo elemento di I1\n    q := q+1\n  FINE\n  p := p+1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#unione","title":"Unione","text":"INPUT: \\(I_1\\) \u2013 primo insieme di cui effettuare l'intersezione, insieme \\(I_2\\) \u2013 secondo insieme di cui effettuare l'intersezione, insieme \\(n\\) \u2013 cardinalit\u00e0 di \\(I_1\\), appartiene a \\(\\N^\\ast\\) \\(m\\) \u2013 cardinalit\u00e0 di \\(I_2\\), appartiene a \\(\\N^\\ast\\) OUTPUT: <code>unione</code> \u2013 insieme risultante dell'intersezione tra \\(I_1\\) e \\(I_2\\), insieme LAVORO: \\(p\\) \u2013 posizione degli elementi di \\(I_1\\), appartiene a \\(\\N^\\ast\\) \\(q\\) \u2013 posizione degli elementi di <code>unione</code>, appartiene a \\(\\N^\\ast\\) <code>trovato</code> \u2013 indica se un elemento \u00e8 presente in un insieme, booleano <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nMENTRE (p &lt;= n)\n  p-esimo elemento di unione := p-esimo elemento di I1\n  p := p+1\nFINE\n\nq := 1\nMENTRE (q &lt;= m)\n  trovato := RicercareElemento(p-esimo elemento di I2, Unione, p - 1)\n  SE (trovato = FALSO)\n    ALLORA p-esimo elemento di unione := p-esimo elemento di I2\n    p := p + 1\n  FINE\n  q := q + 1\nFINE\n</code></pre>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#stampare-risultati","title":"Stampare risultati","text":"INPUT: <code>intersezione</code> \u2013 insieme di elementi comuni a \\(I_1\\) e \\(I_2\\), insieme <code>differenza</code> \u2013 insieme di elementi di \\(I_1\\) non comuni a \\(I_2\\), insieme <code>unione</code> \u2013 insieme di elementi di \\(I_1\\) e \\(I_2\\) distinti, insieme <code>cardinalit\u00e0Intersezione</code> \u2013 numero di elementi di <code>intersezione</code>, appartiene a \\(\\N^\\ast\\) <code>cardinalit\u00e0Differenza</code> \u2013 numero di elementi di <code>differenza</code>, appartiene a \\(\\N^\\ast\\) <code>cardinalit\u00e0Unione</code> \u2013 numero di elementi di <code>unione</code>, appartiene a \\(\\N^\\ast\\) OUTPUT: nullo \u2013 non \u00e8 previsto output <p>ALGORITMO:</p> Algoritmo 1<pre><code>p := 1\nMENTRE (p &lt; cardinalit\u00e0Intersezione)\n  StampareAVideo(p-esimo elemento di intersezione)\n  p := p + 1\nFINE\n\np := 1\nMENTRE (p &lt; cardinalit\u00e0Differenza)\n  StampareAVideo(p-esimo elemento di differenza)\n  p := p + 1\nFINE\n\np := 1\nMENTRE (p &lt; cardinalit\u00e0Unione)\n  StampareAVideo(p-esimo elemento di unione)\n  p := p + 1\nFINE\n</code></pre> <p>Questa soluzione \u00e8 certamente funzionale ma risulta essere estremamente brutta. L'alternativa pi\u00f9 piacevole \u00e8 la seguente:</p> Algoritmo 2<pre><code>StampareInsieme(Intersezione, cardinalit\u00e0Intersezione)\nStampareInsieme(Differenza, cardinalit\u00e0Differenza)\nStampareInsieme(Unione, cardinalit\u00e0Unione)\n</code></pre> <p>In questo modo introduciamo una nuova funzione, <code>StampareInsieme()</code>, la quale va specificata con le appropriate liste di input, output, etc. Quindi:</p> INPUT: \\(I\\) \u2013 insieme di elementi da stampare, insieme <code>cardinalit\u00e0</code> \u2013 numero di elementi dell'insieme da stampare, appartiene a \\(\\N^\\ast\\) OUTPUT: nullo \u2013 non \u00e8 previsto output LAVORO: \\(p\\) \u2013 posizione degli elementi dell'insieme \\(I\\), appartiene a \\(\\N^\\ast\\) <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nMENTRE (p &lt; cardinalit\u00e0)\n  StampareAVideo(p-esimo elemento di I)\n  p := p + 1\nFINE\n</code></pre> <p>In questo modo, anzich\u00e9 avere tre cicli <code>MENTRE</code> diversi, utilizziamo una funzione, che risulta essere una soluzione pi\u00f9 elegante.</p>"},{"location":"Anno_I/Programmazione/esercizi/10-28-21/#calcolo-della-cardinalita","title":"Calcolo della cardinalit\u00e0","text":"<p>Per ovviare al problema di chiedere continuamente come dato di input la cardinalit\u00e0 di ogni insieme, sarebbe possibile calcolarla.</p> INPUT: \\(I\\) \u2013 insieme di elementi di cui calcolare la cardinalit\u00e0, insieme OUTPUT: \\(C\\) \u2013 cardinalit\u00e0 dell'insieme \\(I\\), appartiene a \\(\\N^\\ast\\) <p>ALGORITMO:</p> Text Only<pre><code>p := 1\nMENTRE (p-esimo elemento di I != VALORE_FINALE)\n  p := p + 1\nFINE\nC := p - 1\n</code></pre> <p>Ma cos'\u00e8 <code>VALORE_FINALE</code>? Si tratta di un elemento di controllo che non contribuisce ad aumentare la cardinalit\u00e0 dell'insieme ma permette all'algoritmo di terminare. Un insieme potrebbe dunque essere il seguente:</p> Text Only<pre><code>I = {1, 3, 7, 9 VALORE_FINALE}\n</code></pre> <p>In questo modo \u00e8 possibile calcolare la cardinalit\u00e0 di un insieme, avendo la certezza di fermare l'iterazione al momento corretto.</p> <p>\u00c8 importante notare che, se la cardinalit\u00e0 viene utilizzata molte volte, risulta pi\u00f9 efficiente<sup>1</sup> o conservare il valore della stessa o chiederla in input.</p> <ol> <li> <p>Pi\u00f9 efficiente dal punto di vista computazionale.\u00a0\u21a9</p> </li> </ol>"}]}